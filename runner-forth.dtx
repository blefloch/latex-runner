% \iffalse
%% File: runner-forth.dtx Copyright (C) 2013 Bruno Le Floch
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% -----------------------------------------------------------------------
% \fi
%
% \begin{runner-documentation}
%
% \newcommand{\kw}[1]{\texttt{#1}}
%
% \section{The \plang{forth} language}
%
% This is not the place for an introduction to Forth, many can be found
% online.  ^^A todo: add a bunch of refs
%
% The \plang{forth} interpreter can be called in interactive or in
% non-interactive mode.  In interactive mode, invoked with the command
% \begin{verbatim}
%   \runner{forth}[interactive]||||
% \end{verbatim}
% the interpreter follows the ANS Forth 1994 specification: it is a
% Standard System with Environmental Restriction as follows.
% \begin{itemize}
% \item The core word |KEY| is not implemented.
% \item The core word |ACCEPT| is not implemented.
% \item The prompt is incorrect after |ABORT|.
% \item The environment variable |/COUNTED-STRING| is not recognized.
% \end{itemize}
% In non-interactive mode, the interpreter does not have a prompt, but
% otherwise behaves as a standard system, subject to the environmental
% restrictions above.
%
% For example, one can define the factorial function as follows.
% \begin{verbatim}
%   \runner{forth}[output = \result]|
%     : FACTORIAL ( +n1 -- +n2)
%     DUP 2 < IF DROP 1 EXIT THEN ( 0! = 1! = 1)
%     DUP 1- RECURSE * ; ( n1! = n1 * [n1 - 1]!)
%   ||
%   CR 0 FACTORIAL . ( prints 1)
%   CR 3 FACTORIAL . ( prints 6)
%   CR 24 FACTORIAL . ( prints -4194304)|
%   \typeout{\result}
% \end{verbatim}
% This types three lines to the terminal, containing \(1\), \(6\) and
% \(-4194304\).  The last number is incorrect, because the result
% overflows the size of a single-cell unsigned integer.  We can easily
% check that it is the correct result modulo \(2^{24}\).
%
% ^^A todo: doc that |STOP| can be used in interactive mode.
%
% ^^A todo: |QUIT| should have a prompt in interactive mode, |ABORT| not.
% ^^A Done by redefining
% ^^A \cs_set_protected:Npn \@@_forth_quit: #1 \@@_forth_quit_point:
% ^^A   { \tl_if_eq:nnTF {#1} { \@@_forth_exit_point: } { <prompt> } { } }
% ^^A and adding a dummy token to definition of |ABORT| after do_quit:.
%
% ^^A todo: clarify what to do with character code points >= 256.
%
% Implementation specificities are as follows.
% \begin{itemize}
% \item All addresses are aligned and are character-aligned.
% \item Behaviour of |EMIT| for non-graphic character: ?
% \item Character editing of |ACCEPT|: ?
% \item Character set: ?
% \item Character-set-extensions matching characteristics: ?
% \item Conditions under which control characters match a space
%   delimiter: whenever a space delimiter (character code \(32\)) is
%   called for, all characters in \([0,32]\) will match.  Even in the
%   case of |WORD|.
% \item Format of the control-flow stack: integers, indicating what was
%   the last control-flow construct used, \(-1\) for |DOES>|, \(0\) for
%   |:|, \(1\) for |IF|, \(2\) for |ELSE|, \(3\) for |DO|, \(4\) for
%   |BEGIN|, \(5\) for |WHILE|.
% \item Conversion of digits larger than thirty-five: this never arises,
%   as the base used in conversion is automatically truncated to the
%   interval \([2, 36]\).
% \item Display after input terminates in |ACCEPT|: ?
% \item Exception abort sequence (as in |ABORT"|): message to the \TeX{}
%   terminal, with the non-zero value that was on the stack, and the
%   compile-time string.
% \item Input line terminator: ?  User input device: ?
% \item Maximum size of a counted string, in chars: ?
% \item Maximum size of a parsed string: ?
% \item Maximum size of a definition name, in chars: ?
% \item Maximum string length for |ENVIRONMENT?|, in chars: ?
% \item Method of selecting a user input device: ?
% \item Method of selecting a user output device: ?
% \item Methods of dictionary compilation: ?
% \item Number of bits in one address unit: \(24\).
% \item Number representation and arithmetic: internally represented as
%   \(24\)-bit unsigned integers (well, further down as \TeX{}
%   dimensions in a \tn{fontdimen} array).
% \item Integers \([-2^{23}, 2^{23} - 1]\), non-negative integers \([0,
%   2^{23} - 1]\), unsigned integers \([0, 2^{24} - 1]\), double
%   integers \([-2^{47}, 2^{47} - 1]\), non-negative double integers
%   \([0, 2^{47} - 1]\), unsigned double integers \([0, 2^{48} - 1]\).
% \item Read-only data-space regions: ?
% \item Size of buffer at |WORD|: ?
% \item One cell is one address unit.
% \item One character is one address unit.
% \item Size of the keyboard terminal input buffer: fixed upon starting
%   the Forth interpreter, at least \(128\).
% \item Size of the pictured numeric output string buffer: fixed upon
%   starting the Forth interpreter, at least \(127\).
% \item Size of the scratch area whose address is returned by |PAD|:
%   fixed upon starting the Forth interpreter, at least \(128\).
% \item Case-sensitivity: yes. (?)
% \item Prompt (see |QUIT|): ?
% \item Division rounding: symmetric (the quotient is rounded towards
%   zero, the remainder has the sign of the numerator).
% \item Value of |STATE| when true: all bits set.
% \item Values returned after arithmetic overflow: correct result,
%   modulo \(2^{24}\).
% \item In a |: X ... DOES> ... ;| construction, the definition of |X|
%   can only be found after the semicolon.
% \end{itemize}
% ^^A todo: ensure that picnum buffer is >= 127 cells wide.
% ^^A todo: ensure that input buffer and pad are >= 128 cells wide.
%
% Behaviour upon encountering ambiguous conditions.
% \begin{itemize}
% \item A name is neither a valid definition name nor a valid number
%   during text interpretation triggers a \TeX{} error.
% \item There is no maximum on the length of a definition name.
% \item Addressing a region outside data space can yield arbitrary data.
% \item No type checking is performed.
% \item The execution token obtained when applying |'| or |FIND| to a
%   word with undefined interpretation semantics is a valid token, whose
%   code triggers a \TeX{} error.
% \item Dividing by zero in |*/|, |*/MOD|, |/|, |/MOD|, |FM/MOD|, |MOD|,
%   |SM/REM|, |UM/MOD|, |M*/| triggers a \TeX{} error, and the
%   corresponding division yields \(0\) or the largest allowed integer,
%   depending on the operation.
% \item Stack overflow or underflow triggers a \TeX{} error, and the
%   stack pointer is not updated.  This includes the case of
%   insufficient data-stack space or return-stack space, insufficient
%   space for loop-control parameters, and overflow of the pictured
%   numeric output.  This also includes reading from an empty data stack
%   or return stack.
% \item Insufficient space for new words crashes \TeX{}.
% \item Interpreting a word with undefined interpretation semantics
%   triggers a \TeX{} error, and the word is ignored.
% \item Modifying the contents of the input buffer or a string literal
%   is harmless.
% \item Parsed string overflow: ?
% \item Arithmetic that produces out of range results yields the correct
%   result modulo \(2^{24}\) (size of the cell).
% \item Unexpected end of input buffer, resulting in an attempt to use a
%   zero-length string as a name: ?
% \item |>IN| greater than size of input buffer: ?
% \item If |RECURSE| appears after |DOES>|, it inserts the execution
%   token of the word defined by~|:| into the code that is added at
%   run-time to the execution semantics of the last defined word.
% \item Argument input source different than current input source for
%   |RESTORE-INPUT|: ?
% \item Data space containing definitions can never be de-allocated, since
%   it is inaccessible.
% \item Data space read/write with incorrect alignment cannot happen,
%   since all addresses are aligned.
% \item Less than \(u+2\) stack items for |PICK| or |ROLL|.
% \item Loop-control parameters are not available for |+LOOP|, |I|, |J|,
%   |LEAVE|, |LOOP|, |UNLOOP|: ?
% \item Most recent definition does not have a name for |IMMEDIATE|: ?
% \item Name not defined by |VALUE| used by |TO|: ?
% \item Name not found |'|, |POSTPONE|, |[']|, |[COMPILE]|: ?
% \item |POSTPONE| or |[COMPILE]| applied to |TO|: ?
% \item String longer than a counted string returned by |WORD|: ?
% \item |LSHIFT| or |RSHIFT| with \(u \geq 24\): ?
% \item Using |>BODY| or |DOES>| for a word not defined via |CREATE|: ?
% \item Using |#|, |#S|, |HOLD| or |SIGN| improperly outside |<#| and
%   |#>| correctly places data into the pictured numeric buffer, but
%   this is later ignored.
% \end{itemize}
%
% Here is a list of data types and their sizes in this implementation.
% \begin{center}
%   \begin{tabular}{ccc}
%     \toprule
%     Symbol    & Data type  & \# bits \\
%     \midrule
%     flag      & flag (true or false)            & 24 \\
%     char      & character                       & 24 \\
%     n         & signed number                   & 24 \\
%     +n        & non-negative number             & 24 \\
%     u         & unsigned number                 & 24 \\
%     x         & unspecified cell                & 24 \\
%     xt        & execution token                 & 24 \\
%     addr      & address ($=\text{a-addr}=\text{c-addr}$) & 24 \\
%     \midrule
%     d         & double-cell signed number       & 48 \\
%     +d        & double-cell non-negative number & 48 \\
%     ud        & double-cell unsigned number     & 48 \\
%     xd        & unspecified cell pair           & 48 \\
%     \midrule
%     ^^A todo: clarify what those '-sys' types are in this implementation.
%     colon-sys & definition compilation          & dep \\
%     do-sys    & do-loop structures              & dep \\
%     case-sys  & CASE structures                 & dep \\
%     of-sys    & OF structures                   & dep \\
%     orig      & control-flow origins            & dep \\
%     dest      & control-flow destinations       & dep \\
%     loop-sys  & loop-control parameters         & dep \\
%     nest-sys  & definition calls                & dep \\
%     i*x, j*x, k*x (3) & any data type           & \(\geq 0\) \\
%     \bottomrule
%   \end{tabular}
% \end{center}
%
% \end{runner-documentation}
%
% \begin{runner-implementation}
%
% \section{\plang{forth} implementation}
%
% Sections to be re-read:
% \begin{itemize}
% \item 3.1.5. System types
% \item 3.2.1.2. Digit conversion
% \item 3.2.3.3. Return stack
% \item 3.2.4. Operator terminal (decide whether the Forth program can
%   change where it gets its input from)
% \item 3.3.
% \end{itemize}
%
% Maybe relevant text in the 1994 standard.
% \begin{quote}
%   This Standard designates the following words as obsolescent:
%   \begin{itemize}
%   \item 6.2.0060  |#TIB|
%   \item 15.6.2.1580  |FORGET|
%   \item 6.2.2240  |SPAN|
%   \item 6.2.0970  |CONVERT|
%   \item 6.2.2040  |QUERY|
%   \item 6.2.2290  |TIB|
%   \item 6.2.1390  |EXPECT|
%   \end{itemize}
%   [...]\\
%   A system need not provide any standard words for accessing mass
%   storage.  If a system provides any standard word for accessing mass
%   storage, it shall also implement the Block word set.
%   [...]\\
% \end{quote}
%
% The standard says ``char'' is a subtype of ``+n'', so characters are
% only allowed to take values in the range \([0, 2^{23}-1]\)?  Addresses
% are only allowed to take values in the range \([-2^{23}, 2^{23}-1]\)?
%
% Am I allowed to always consider the data-space pointer to be aligned,
% separating cells by \(1\) address unit?
%
% \subsection{Generic helpers}
%
% Useful variants.
%    \begin{macrocode}
\cs_generate_variant:Nn \prop_gput:Nnn { Nx }
\cs_generate_variant:Nn \prop_get:NnNTF { Nx }
\cs_generate_variant:Nn \prop_put:Nnn { Nxx }
\cs_generate_variant:Nn \tl_item:nn { o }
%    \end{macrocode}
%
% ^^A todo: try to only put the marker on actual definitions.
% \begin{macro}[int]{\@@_forth_exit:, \@@_forth_exit_point:}
%   When executing code given an execution token (see
%   \cs{@@_forth_execute:n}), a \texttt{exit_point} marker is placed
%   after the code, so that |EXIT| can safely leave definitions.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_exit:
  #1 \@@_forth_exit_point: { }
\cs_new_eq:NN \@@_forth_exit_point: \scan_stop:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_quit:, \@@_forth_quit_point:}
%   A \texttt{quit_point} marker is placed at every iteration of the
%   interpreter/compiler loop, so that |QUIT| can safely cleanup all
%   remaining code and go to the next iteration.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_quit:
  #1 \@@_forth_quit_point: { }
\cs_new_eq:NN \@@_forth_quit_point: \scan_stop:
%    \end{macrocode}
% \end{macro}
%
% \subsection{Data structures}
%
% The data necessary to run Forth consists of
% \begin{itemize}
% \item the data stack, manipulated by the program, contains cells,
% \item the control-flow stack, which contains ``-sys'' types, and can
%   be implemented using the data stack,
% \item the return stack, which can be used by the program, but is
%   mostly used by the system, for definitions, do-loops, nesting info,
% \end{itemize}
% as well as
% \begin{itemize}
% \item the name space (mapping words to execution tokens),
% \item the code space (code for the execution tokens),
% \item the data space accessible to programs, which consists in
%   \begin{itemize}
%   \item contiguous regions,
%   \item variables,
%   \item text-literal regions,
%   \item input buffers,
%   \item and other transient regions.
%   \end{itemize}
% \end{itemize}
%
% The name space is implemented as a property list, mapping words to a
% flag in \(\{1,2,3\}\) and an execution token (integer in
% \([0,65535]\)) associated to this word.
%
% The code space is implemented using \tn{toks} registers: execution
% tokens are register numbers.
%
% Everything else is stored as one global array, \cs{g_@@_forth_array},
% of \(24\)-bit unsigned integers.  See \texttt{runner.dtx} for the
% array implementation.
%
% \subsubsection{Defining data space and stacks}
%
% The array \cs{g_@@_forth_array} is split into several regions, in the
% following order (from low-numbered to high-numbered items).  For
% conciseness we refer in this list to integer variables by shorthands;
% \texttt{min} and \texttt{max} variables are global and can only change
% between Forth runs; other integers are local and change during runs.
% \begin{itemize}
% \item The pictured numeric output is from \texttt{picnum_min}
%   (included) to \texttt{picnum_max} (excluded): this contains material
%   from \texttt{picnum_here} (included) to \texttt{picnum_max}
%   (excluded).
% \item The terminal input buffer contains text from \texttt{term_min}
%   (included) to \texttt{term_end} (excluded), which can go up to
%   \texttt{term_max}.  The actual input source lies from
%   \texttt{source_begin} (included) to \texttt{source_end} (excluded),
%   which are normally equal to \texttt{term_min} and \texttt{term_end},
%   unless modified by |EVALUATE|.  The integer \texttt{source_parsed}
%   is used temporarily to store the sum of \texttt{source_end} and of
%   the value at~|>IN|.
% \item The pad is from \texttt{pad_min} (included) to \texttt{pad_max}
%   (excluded).
% \item The data space lies from \texttt{data_min} (included) to
%   \texttt{data_max} (excluded), and is split further.
%   \begin{itemize}
%   \item Contiguous regions of the data space, intermixed with
%     variables, lie between \texttt{data_min} (included) and
%     \texttt{data_here} (excluded).
%   \item The transient regions provided by |WORD| or |#>| start at
%     \texttt{data_here} (included) and end at \texttt{data_word}
%     (excluded).
%   \item Text literals are allocated at the end of the data space, and
%     lie between \texttt{data_text} (included) and \texttt{data_max}
%     (excluded).
%   \end{itemize}
% \item The data stack lies from \texttt{stack_min} to
%   \texttt{stack_max}, and the position where a new value would be
%   pushed is at \texttt{stack_here}.
% \item The control-flow stack lies from \texttt{control_min} to
%   \texttt{control_max}, and the position where a new value would be
%   pushed is \texttt{control_here}.
% \item The return stack lies from \texttt{return_min} to
%   \texttt{return_max}, and the position where a new value would be
%   pushed is at \texttt{return_here}.
% \end{itemize}
%
% In each slot of the array, we store a \(24\) bit unsigned integer,
% \ie, a number in the range \([0, 2^{24}-1]\) (note that we could go up
% to \(26\) bits with no adverse effect).  Address units are \(24\) bits
% wide.  Characters are one address unit wide (note that all Unicode
% code points are less than \(2^{23}\)).  Cells are one character wide.
% We do not use \(8\) bit characters (and addresses) for four reasons:
% only \(256\) cells could be addressed; counted strings would be
% bounded to \(255\) characters; extracting an \(8\)-bit part from a
% \(24\) bit value in \TeX{} is not fast; and we would need to chose an
% encoding for Unicode (this is still needed in \pdfTeX{}, but only at
% the very last step of output).
%
% \begin{variable}
%   {
%     \g_@@_forth_picnum_min_int,
%     \l_@@_forth_picnum_here_int,
%     \g_@@_forth_picnum_max_int,
%   }
%   The pictured numeric output, ranging from
%   \cs{l_@@_forth_picnum_here_int} to \cs{g_@@_forth_picnum_max_int}.
%    \begin{macrocode}
\int_new:N \g_@@_forth_picnum_min_int
\int_new:N \l_@@_forth_picnum_here_int
\int_new:N \g_@@_forth_picnum_max_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \g_@@_forth_term_min_int,
%     \l_@@_forth_term_end_int,
%     \g_@@_forth_term_max_int,
%     \l_@@_forth_source_begin_int,
%     \l_@@_forth_source_parsed_int,
%     \l_@@_forth_source_end_int,
%     \l_@@_forth_in_address_int,
%     \l_@@_forth_sources_seq
%   }
%   The terminal input buffer lies from \cs{g_@@_forth_term_min_int}
%   (included) to \cs{g_@@_forth_term_max_int} (excluded), and contains
%   text until \cs{l_@@_forth_term_end_int} (excluded).  The source
%   specification can be changed by |EVALUATE|: parsing words read the
%   buffer from \cs{l_@@_forth_source_begin_int} to
%   \cs{l_@@_forth_source_end_int}.  The integer
%   \cs{l_@@_forth_source_parsed_int} is set to the sum of
%   \cs{l_@@_forth_source_begin_int} and the value at~|>IN| (whose address
%   is \cs{l_@@_forth_in_address_int} before each parsing operation.
%   The stack \cs{l_@@_forth_sources_seq} stores the previous source
%   specification for nested |EVALUATE| calls.
%    \begin{macrocode}
\int_new:N \g_@@_forth_term_min_int
\int_new:N \l_@@_forth_term_end_int
\int_new:N \g_@@_forth_term_max_int
\int_new:N \l_@@_forth_source_begin_int
\int_new:N \l_@@_forth_source_parsed_int
\int_new:N \l_@@_forth_source_end_int
\int_new:N \l_@@_forth_in_address_int
\seq_new:N \l_@@_forth_sources_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_forth_pad_min_int, \g_@@_forth_pad_max_int}
%   The pad returned by |PAD| is fixed and ranges from
%   \cs{g_@@_forth_pad_min_int} (included) to
%   \cs{g_@@_forth_pad_max_int} (excluded).
%    \begin{macrocode}
\int_new:N \g_@@_forth_pad_min_int
\int_new:N \g_@@_forth_pad_max_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \g_@@_forth_data_min_int,
%     \l_@@_forth_data_here_int,
%     \l_@@_forth_data_word_int,
%     \l_@@_forth_data_text_int,
%     \g_@@_forth_data_max_int,
%   }
%   Allotted data, and variables, range from
%   \cs{g_@@_forth_data_min_int} (included) to
%   \cs{l_@@_forth_data_here_int} (excluded).  The latter integer is
%   what |HERE| returns.  Transient regions created by |WORD| or |#>|
%   lie between this address (included) and
%   \cs{l_@@_forth_data_word_int} (excluded).  Finally, text strings are
%   stored from \cs{l_@@_forth_data_text_int} (included) to
%   \cs{g_@@_forth_data_max_int} (excluded).
%    \begin{macrocode}
\int_new:N \g_@@_forth_data_min_int
\int_new:N \l_@@_forth_data_here_int
\int_new:N \l_@@_forth_data_word_int
\int_new:N \l_@@_forth_data_text_int
\int_new:N \g_@@_forth_data_max_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \g_@@_forth_stack_min_int,
%     \l_@@_forth_stack_here_int,
%     \g_@@_forth_stack_max_int
%   }
%   The data stack lies in this range, with the bottom item at
%   \cs{g_@@_forth_stack_min_int} and the top item just below
%   \cs{l_@@_forth_stack_here_int}.
%    \begin{macrocode}
\int_new:N \g_@@_forth_stack_min_int
\int_new:N \l_@@_forth_stack_here_int
\int_new:N \g_@@_forth_stack_max_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \g_@@_forth_control_min_int,
%     \l_@@_forth_control_here_int,
%     \g_@@_forth_control_max_int
%   }
%   The control flow stack lies in this range, with the bottom item at
%   \cs{g_@@_forth_control_min_int} and the top item just below
%   \cs{l_@@_forth_control_here_int}.
%    \begin{macrocode}
\int_new:N \g_@@_forth_control_min_int
\int_new:N \l_@@_forth_control_here_int
\int_new:N \g_@@_forth_control_max_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \g_@@_forth_return_min_int,
%     \l_@@_forth_return_here_int,
%     \g_@@_forth_return_max_int
%   }
%   The return stack lies there, with the bottom item at
%   \cs{g_@@_forth_return_min_int} and the top of the stack just below
%   \cs{l_@@_forth_return_here_int}.
%    \begin{macrocode}
\int_new:N \g_@@_forth_return_min_int
\int_new:N \l_@@_forth_return_here_int
\int_new:N \g_@@_forth_return_max_int
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\@@_forth_init_data:}
%   When starting a Forth run, one must reset the pointers that vary, to
%   the appropriate boundary of their region.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_init_data:
  {
    \int_set_eq:NN \l_@@_forth_picnum_here_int
      \g_@@_forth_picnum_max_int
    \int_set_eq:NN \l_@@_forth_term_end_int
      \g_@@_forth_term_min_int
    \int_set_eq:NN \l_@@_forth_source_begin_int
      \g_@@_forth_term_min_int
    \int_set_eq:NN \l_@@_forth_source_parsed_int
      \g_@@_forth_term_min_int
    \int_set_eq:NN \l_@@_forth_source_end_int
      \g_@@_forth_term_min_int
    \seq_clear:N \l_@@_forth_sources_seq
    \int_set_eq:NN \l_@@_forth_data_here_int
      \g_@@_forth_data_min_int
    \int_set_eq:NN \l_@@_forth_data_word_int
      \g_@@_forth_data_min_int
    \int_set_eq:NN \l_@@_forth_data_text_int
      \g_@@_forth_data_max_int
    \int_set_eq:NN \l_@@_forth_stack_here_int
      \g_@@_forth_stack_min_int
    \int_set_eq:NN \l_@@_forth_control_here_int
      \g_@@_forth_control_min_int
    \int_set_eq:NN \l_@@_forth_return_here_int
      \g_@@_forth_return_min_int
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: make the array size dynamical
%
% \begin{variable}{\g_@@_forth_array}
%   This array contains most of the data needed by Forth.  We also give
%   here initial values for the array parameters, all at once to avoid
%   mistakes.
%    \begin{macrocode}
\int_gset:Nn \g_@@_forth_picnum_min_int { 1 }
\int_gset:Nn \g_@@_forth_picnum_max_int { 128 }
\int_gset:Nn \g_@@_forth_term_min_int { 128 }
\int_gset:Nn \g_@@_forth_term_max_int { 256 }
\int_gset:Nn \g_@@_forth_pad_min_int { 256 }
\int_gset:Nn \g_@@_forth_pad_max_int { 384 }
\int_gset:Nn \g_@@_forth_data_min_int { 384 }
\int_gset:Nn \g_@@_forth_data_max_int { 65152 }
\int_gset:Nn \g_@@_forth_stack_min_int { 65152 }
\int_gset:Nn \g_@@_forth_stack_max_int { 65280 }
\int_gset:Nn \g_@@_forth_control_min_int { 65280 }
\int_gset:Nn \g_@@_forth_control_max_int { 65408 }
\int_gset:Nn \g_@@_forth_return_min_int { 65408 }
\int_gset:Nn \g_@@_forth_return_max_int { 65536 }
\@@_array_new:Nn \g_@@_forth_array { 65536 }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\c_@@_forth_mod_int}
%   Cells can take up to \(2^{24}\) values.  Arithmetic is often
%   performed modulo that number.
%    \begin{macrocode}
\int_const:Nn \c_@@_forth_mod_int { 16777216 }
%    \end{macrocode}
% \end{variable}
%
% \subsubsection{Manipulating data space}
%
% \begin{macro}[int, EXP]{\@@_forth_data_get:N, \@@_forth_data_get:n}
%   Retrieving unsigned integers from data space.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_forth_data_get:N
  { \@@_array_item:NN \g_@@_forth_array }
\cs_new_nopar:Npn \@@_forth_data_get:n
  { \@@_array_item:Nn \g_@@_forth_array }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_data_gset:nn}
%   Storing unsigned integers into data space.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_data_gset:nn
  { \@@_array_gset:Nnn \g_@@_forth_array }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_put_here:n}
%   Put a value at the position given by the \texttt{data_here} integer,
%   then increment that integer.  Check before-hand that we do not reach
%   the region occupied by text literals.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_put_here:n #1
  {
    \int_compare:nNnTF
      \l_@@_forth_data_here_int < \l_@@_forth_data_text_int
      {
        \@@_forth_data_gset:nn { \l_@@_forth_data_here_int } {#1}
        \int_incr:N \l_@@_forth_data_here_int
      }
      { \msg_error:nn { runner/forth } { out-of-memory } }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Manipulating the data stack}
%
% \begin{macro}[int]{\@@_forth_pop_int:N}
%   Get data from the stack.  The stack is empty if \texttt{stack_here}
%   is \texttt{stack_min}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_pop_int:N #1
  {
    \int_compare:nNnTF
      \l_@@_forth_stack_here_int > \g_@@_forth_stack_min_int
      {
        \int_decr:N \l_@@_forth_stack_here_int
        \int_set:Nn #1
          {
            \@@_array_item:NN \g_@@_forth_array
              \l_@@_forth_stack_here_int
          }
      }
      { \msg_error:nn { runner/forth } { empty-stack } }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: Improve bound-checking.
% ^^A todo: Are the multi-pop useful?  Yes, if single bound checking.
% \begin{macro}[int]
%   {
%     \@@_forth_pop_int:NN,
%     \@@_forth_pop_int:NNN,
%     \@@_forth_pop_int:NNNN
%   }
%   Get multiple integers from stack.  Note that things are popped
%   backwards, so that the last argument gets the top of the stack.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_pop_int:NN #1#2
  {
    \@@_forth_pop_int:N #2
    \@@_forth_pop_int:N #1
  }
\cs_new_protected:Npn \@@_forth_pop_int:NNN #1#2#3
  {
    \@@_forth_pop_int:N #3
    \@@_forth_pop_int:N #2
    \@@_forth_pop_int:N #1
  }
\cs_new_protected:Npn \@@_forth_pop_int:NNNN #1#2#3#4
  {
    \@@_forth_pop_int:N #4
    \@@_forth_pop_int:N #3
    \@@_forth_pop_int:N #2
    \@@_forth_pop_int:N #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_push:n}
%   Push an unsigned integer onto the stack, at \texttt{stack_here},
%   failing if the stack is full.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_push:n #1
  {
    \int_compare:nNnTF
      \l_@@_forth_stack_here_int < \g_@@_forth_stack_max_int
      {
        \@@_array_gset:Nnn \g_@@_forth_array
          \l_@@_forth_stack_here_int {#1}
        \int_incr:N \l_@@_forth_stack_here_int
      }
      { \msg_error:nn { runner/forth } { out-of-memory } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]
%   {
%     \@@_forth_push:nn,
%     \@@_forth_push:nnn,
%     \@@_forth_push:nnnn,
%     \@@_forth_push:nnnnn,
%     \@@_forth_push:nnnnnn,
%   }
%   Push multiple unsigned integers.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_push:nn #1#2
  {
    \@@_forth_push:n {#1}
    \@@_forth_push:n {#2}
  }
\cs_new_protected:Npn \@@_forth_push:nnn #1#2#3
  {
    \@@_forth_push:n {#1}
    \@@_forth_push:n {#2}
    \@@_forth_push:n {#3}
  }
\cs_new_protected:Npn \@@_forth_push:nnnn #1#2#3#4
  {
    \@@_forth_push:n {#1}
    \@@_forth_push:n {#2}
    \@@_forth_push:n {#3}
    \@@_forth_push:n {#4}
  }
\cs_new_protected:Npn \@@_forth_push:nnnnn #1#2#3#4#5
  {
    \@@_forth_push:n {#1}
    \@@_forth_push:n {#2}
    \@@_forth_push:n {#3}
    \@@_forth_push:n {#4}
    \@@_forth_push:n {#5}
  }
\cs_new_protected:Npn \@@_forth_push:nnnnnn #1#2#3#4#5#6
  {
    \@@_forth_push:n {#1}
    \@@_forth_push:n {#2}
    \@@_forth_push:n {#3}
    \@@_forth_push:n {#4}
    \@@_forth_push:n {#5}
    \@@_forth_push:n {#6}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_push_false:, \@@_forth_push_true:}
%   The \texttt{false} value is \(0\), the true value is \(-1\), which
%   we store as a positive integer by shifting by
%   \cs{c_@@_forth_mod_int}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_push_false:
  { \@@_forth_push:n { 0 } }
\cs_new_protected_nopar:Npx \@@_forth_push_true:
  {
    \@@_forth_push:n
      { \int_eval:n { \c_@@_forth_mod_int - 1 } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_forth_signed:N}
%   Turn the unsigned |#1| into a signed number, by subtracting
%   \(2^{24}\) if it is not less than \(2^{23}\).  We make use of
%   \eTeX{}'s rounding behaviour: dividing |#1| by \(2^{24}\) yields
%   \(0\) for numbers less than \(2^{23}\) and \(1\) for numbers in
%   \([2^{23}, 2^{24}-1]\).
%    \begin{macrocode}
\cs_new:Npn \@@_forth_signed:N #1
  {
    \int_eval:n
      { #1 - #1 / \c_@@_forth_mod_int * \c_@@_forth_mod_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_push_signed:n}
% \begin{macro}[aux]{\@@_forth_push_signed_aux:n}
%   Given a signed integer in the range \([-2^{24}, 2^{24}-1]\) (note
%   the extra large range), push the corresponding unsigned
%   representation onto the stack.  This simply requires adding
%   \(2^{24}\) to negative numbers.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_push_signed:n #1
  {
    \exp_args:Nf \@@_forth_push_signed_aux:n
      { \int_eval:n {#1} }
  }
\cs_new_protected:Npn \@@_forth_push_signed_aux:n #1
  {
    \@@_forth_push:n
      {
        \int_compare:nNnTF {#1} < \c_zero
          { #1 + \c_@@_forth_mod_int } {#1}
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_push_mod:n}
%   Given a non-negative integer, push onto the stack its residue modulo
%   \(2^{24}\).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_push_mod:n #1
  {
    \@@_forth_push:n
      { \int_mod:nn {#1} { \c_@@_forth_mod_int } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_@@_forth_push_fp}
%   When turning a signed number to an unsigned value for pushing onto
%   the stack, one cannot use \cs{l_@@_tmpa_int}, as it may be used by
%   the caller.  Similarly for outputting floating points modulo some
%   number.
%    \begin{macrocode}
\fp_new:N \l_@@_forth_push_fp
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\@@_forth_push_fp:n, \@@_forth_push_fp_mod:n}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_push_fp:n #1
  { \@@_forth_push:n { \fp_to_int:n {#1} } }
\cs_new_protected:Npn \@@_forth_push_fp_mod:n #1
  {
    \fp_set:Nn \l_@@_forth_push_fp { round0(#1) }
    \@@_forth_push_fp:n
      {
        \l_@@_forth_push_fp - \c_@@_forth_mod_int
             * round- ( \l_@@_forth_push_fp / \c_@@_forth_mod_int )
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Manipulating the control-flow stack}
%
% \begin{macro}[int]{\@@_forth_control_open:n}
%   Push an unsigned integer onto the control-flow stack, at
%   \texttt{control_here}, failing if the control-flow stack is full.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_control_open:n #1
  {
    \int_compare:nNnTF
      \l_@@_forth_control_here_int < \g_@@_forth_control_max_int
      {
        \@@_array_gset:Nnn \g_@@_forth_array
          \l_@@_forth_control_here_int {#1}
        \int_incr:N \l_@@_forth_control_here_int
      }
      { \msg_error:nn { runner/forth } { out-of-memory } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, TF]{\@@_forth_control_close:n}
%   Read the top of the control-flow stack if not empty.  If this
%   matches with |#1|, remove it (by shifting \texttt{control_here}),
%   and return \texttt{true}, otherwise \texttt{false}.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \@@_forth_control_close:n #1 { TF }
  {
    \int_compare:nNnTF
      \l_@@_forth_control_here_int > \g_@@_forth_control_min_int
      {
        \int_compare:nNnTF
          {
            \@@_array_item:Nn \g_@@_forth_array
              { \l_@@_forth_control_here_int - 1 }
          }
          = {#1}
          {
            \int_decr:N \l_@@_forth_control_here_int
            \prg_return_true:
          }
          { \prg_return_false: }
      }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Manipulating the return stack}
%
% \begin{macro}[int]{\@@_forth_return_pop_int:N}
%   Get data from the return stack.  The return stack is empty if
%   \texttt{return_here} is \texttt{return_min}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_return_pop_int:N #1
  {
    \int_compare:nNnTF
      \l_@@_forth_return_here_int > \g_@@_forth_return_min_int
      {
        \int_decr:N \l_@@_forth_return_here_int
        \int_set:Nn #1
          {
            \@@_array_item:NN \g_@@_forth_array
              \l_@@_forth_return_here_int
          }
      }
      { \msg_error:nn { runner/forth } { empty-return-stack } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_return_push:n}
%   Push an unsigned integer onto the return stack, at
%   \texttt{return_here}, failing if the return stack is full.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_return_push:n #1
  {
    \int_compare:nNnTF
      \l_@@_forth_return_here_int < \g_@@_forth_return_max_int
      {
        \@@_array_gset:Nnn \g_@@_forth_array
          \l_@@_forth_return_here_int {#1}
        \int_incr:N \l_@@_forth_return_here_int
      }
      { \msg_error:nn { runner/forth } { out-of-memory } }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Name space and code space variables}
%
% The \TeX{} code to execute Forth words is stored within \tn{toks}
% registers, labelled by so-called ``execution tokens''.  An execution
% token is a cell restricted to the range \([0, 2^{16}-1]\) or \([0,
% 2^{15}-1]\) (depending on the engine's capabilities), and its
% execution semantics are simply to run the \TeX{} code in that
% \tn{toks} register.
%
% The mapping from words to their definitions is done by giving an
% execution token pointing to the \tn{toks} with the appropriate \TeX{}
% code.  In fact, one needs a little bit more: to each word is
% associated a digit in \(\{1, 2, 3\}\) and an execution token.
% \begin{itemize}
% \item \(1\) indicates normal words, whose interpretation semantics are
%   given by the execution token, and whose compilation semantics is to
%   append the execution token to the current definition;
% \item \(2\) indicates immediate words, whose interpretation and
%   compilation semantics are identical, and given by the execution
%   token;
% \item \(3\) indicates special words such as |ABORT"|, which may have
%   arbitrary interpretation and compilation semantics: the execution
%   token gives the intepretation semantics, and the compilation
%   semantics follows in the next \tn{toks} register.
% \end{itemize}
%
% \begin{variable}{\l_@@_forth_words_prop, \g_@@_forth_core_words_prop}
%   Keys of the \texttt{words} property list are words known to Forth at
%   a given time during the execution of the code.  Keys of the
%   \texttt{core_words} global property list are words from the core
%   set, with which the \texttt{words} property list is initialized.
%
%   Values are a digit \(d \in \{1, 2, 3\}\) followed by five (decimal)
%   digits forming an execution token \(\mathrm{xt}\), which lies in the
%   range \([0, 2^{15}-1]\) for \pdfTeX{} and \XeTeX{}, and in the range
%   \([0, 2^{16}-1]\) for \LuaTeX{}.  The code to be run upon execution
%   is always found in the \tn{toks} register given by this five-digit
%   integer.  The compilation semantics is to append \(\mathrm{xt}\) to
%   the current definition if \(d = 1\), to perform \(\mathrm{xt}\) if
%   \(d = 2\), and to perform \(\mathrm{xt} + 1\) if \(d = 3\).
%    \begin{macrocode}
\prop_new:N \l_@@_forth_words_prop
\prop_new:N \g_@@_forth_core_words_prop
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_forth_toks_int, \g_@@_forth_core_toks_int}
%   The next free \tn{toks} register, for use to store the code
%   corresponding to execution tokens.
%    \begin{macrocode}
\int_new:N \l_@@_forth_toks_int
\int_new:N \g_@@_forth_core_toks_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_forth_init_toks_tl}
%   Token list containing part of the initialization code, currently
%   many assignments to \tn{toks} registers.
%    \begin{macrocode}
\tl_new:N \g_@@_forth_init_toks_tl
%    \end{macrocode}
% \end{variable}
%
% \subsubsection{Accessing the code space}
%
% ^^A todo: expand this section
% \begin{macro}[int]{\@@_forth_execute:n}
%   Run the code saved in the \tn{toks} with number~|#1|.  This is
%   protected, which simplifies handling of expansion.  The trailing
%   space terminates the number returned by \cs{int_eval:n}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_execute:n #1
  { \tex_the:D \tex_toks:D \int_eval:n {#1} \@@_forth_exit_point: }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Adding to the name space}
%
% \begin{macro}[int]{\@@_forth_chk_if_core_free:n}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_chk_if_core_free:n #1
  {
    \prop_get:NnNT \g_@@_forth_core_words_prop {#1} \l_@@_tmpa_tl
      { \msg_error:nn { runner/forth } { internal } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]
%   {
%     \@@_forth_new_core:nn,
%     \@@_forth_new_immediate_core:nn,
%     \@@_forth_new_compilation_core:nn
%   }
% \begin{macro}[aux]{\@@_forth_new_aux:nnn}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_new_core:nn
  { \@@_forth_new_aux:nnn { 1 } }
\cs_new_protected_nopar:Npn \@@_forth_new_immediate_core:nn
  { \@@_forth_new_aux:nnn { 2 } }
\cs_new_protected:Npn \@@_forth_new_compilation_core:nn #1#2
  {
    \@@_forth_new_aux:nnn { 3 } {#1}
      { \msg_error:nnn { runner/forth } { no-interpretation } {#1} }
    \tl_gput_right:Nx \g_@@_forth_init_toks_tl
      {
        \tex_toks:D \int_use:N \g_@@_forth_core_toks_int
          { \exp_not:n {#2} }
      }
    \int_gincr:N \g_@@_forth_core_toks_int
  }
\cs_new_protected:Npn \@@_forth_new_aux:nnn #1#2#3
  {
    \@@_forth_chk_if_core_free:n {#2}
    \tl_gput_right:Nx \g_@@_forth_init_toks_tl
      {
        \tex_toks:D \int_use:N \g_@@_forth_core_toks_int
          { \exp_not:n {#3} }
      }
    \prop_gput:Nnx \g_@@_forth_core_words_prop {#2}
      { \int_eval:n { #1 00000 + \g_@@_forth_core_toks_int } }
    \int_gincr:N \g_@@_forth_core_toks_int
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_core_alias:nn}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_core_alias:nn #1#2
  {
    \@@_forth_chk_if_core_free:n {#1}
    \prop_get:NnN \g_@@_forth_core_words_prop {#2} \l_@@_tmpa_tl
    \prop_gput:NnV \g_@@_forth_core_words_prop {#1} \l_@@_tmpa_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]
%   {
%     \@@_forth_set_word:nn,
%     \@@_forth_set_word:nx,
%     \@@_forth_set_word:ox
%   }
%   The name |#1| is stored (for |IMMEDIATE|).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_set_word:nn #1#2
  {
    \str_set:Nn \l_@@_forth_def_name_str {#1}
    \cs_set_nopar:Npx \@@_forth_recurse:
      { \@@_forth_execute:n { \int_use:N \l_@@_forth_toks_int } }
    \use:x { \tex_toks:D \l_@@_forth_toks_int {#2} }
    \cs_set_eq:NN \@@_forth_recurse: ?
    \prop_put:Nnx \l_@@_forth_words_prop {#1}
      { \int_eval:n { 100000 + \l_@@_forth_toks_int } }
    \int_incr:N \l_@@_forth_toks_int
  }
\cs_generate_variant:Nn \@@_forth_set_word:nn { nx , ox }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Helpers}
%
% \subsubsection{Input}
%
% \begin{variable}{\l_@@_forth_input_word_str}
%   Token list containing the word being built.
%    \begin{macrocode}
\str_new:N \l_@@_forth_input_word_str
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_forth_input_str}
%   Store the part of the input string provided by \cs{@@_get_line:NTF}
%   that did not fit into the input buffer.
%    \begin{macrocode}
\str_new:N \l_@@_forth_input_str
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\@@_forth_str_put_char:Nn}
%   Append to the string |#1| the character with character code~|#2|.
%   This function is useful when converting from strings stored into
%   cells to displayed strings.
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_other:n { 0 }
  \cs_new_protected:Npn \@@_forth_str_put_char:Nn #1#2
    {
      \group_begin:
        \char_set_lccode:nn { 0 } {#2}
        \tex_lowercase:D
          {
            \group_end:
            \tl_put_right:Nn #1 { ^^@ }
          }
    }
\group_end:
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: document that |EVALUATE| can lead to |^^J| in the input buffer.
%
% \begin{macro}[int, TF]{\@@_forth_input_refill:}
% \begin{macro}[aux]{\@@_forth_input_refill_get:, \@@_forth_term_refill:}
%   This refills the input buffer, and returns \texttt{true} if
%   successful and \texttt{false} otherwise.  If the
%   \texttt{forth_input} string is non-empty (\ie, the buffer was too
%   short to hold the full line previously), call an auxiliary for the
%   transfer; otherwise we need to fetch a new line.  If the
%   \texttt{forth_sources} stack is not empty (we just exhausted a
%   string given to |EVALUATE|), then restore the previous Forth source:
%   the text that did not fit in the buffer is on top, then the values
%   of \texttt{source_end}, \texttt{source_parsed}, and
%   \texttt{source_begin}.  Otherwise, ask for more input using
%   \cs{@@_get_line:NTF} (adding |^^J|), before calling the transfer
%   function.  Note that even if \texttt{get_line} fails, we call it
%   back until the \texttt{sources_seq} is exhausted: this concatenates
%   program and input sources.  The transfer function
%   \texttt{term_refill:} (only called with the terminal input buffer as
%   a targe) starts by splitting the string if it is too long, then
%   going through the first part one character at a time, filling the
%   input buffer with the character codes, and makes sure to set
%   \texttt{term_end}, \texttt{source_begin}, \texttt{source_parsed},
%   and \texttt{source_end}.  Note that after this function, |>IN| is
%   correctly set, but \texttt{source_parsed} is not.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \@@_forth_input_refill: { TF }
  {
    \tl_if_empty:NTF \l_@@_forth_input_str
      { \@@_forth_input_refill_get: }
      { \@@_forth_term_refill: }
  }
\cs_new_protected_nopar:Npn \@@_forth_input_refill_get:
  {
    \seq_pop:NNTF \l_@@_forth_sources_seq \l_@@_forth_input_str
      {
        \seq_pop:NN \l_@@_forth_sources_seq \l_@@_tmpc_tl
        \seq_pop:NN \l_@@_forth_sources_seq \l_@@_tmpb_tl
        \seq_pop:NN \l_@@_forth_sources_seq \l_@@_tmpa_tl
        \int_set:Nn \l_@@_forth_source_begin_int { \l_@@_tmpa_tl }
        \@@_forth_data_gset:nn
          { \l_@@_forth_in_address_int }
          { \l_@@_tmpb_tl }
        \int_set:Nn \l_@@_forth_source_end_int { \l_@@_tmpc_tl }
        \prg_return_true:
      }
      {
        \@@_get_line:NTF \l_@@_forth_input_str
          {
            \str_put_right:Nn \l_@@_forth_input_str { ^^J }
            \@@_forth_term_refill:
          }
          {
            \seq_if_empty:NTF \l_@@_sources_seq
              { \prg_return_false: }
              { \@@_forth_input_refill_get: }
          }
      }
  }
\cs_new_protected_nopar:Npn \@@_forth_term_refill:
  {
    \int_set:Nn \l_@@_tmpa_int
      { \g_@@_forth_term_max_int - \g_@@_forth_term_min_int }
    \tl_set:Nx \l_@@_tmpb_tl
      {
        \str_range:Nnn \l_@@_forth_input_str
          { 1 } { \l_@@_tmpa_int }
      }
    \tl_set:Nx \l_@@_forth_input_str
      {
        \str_range:Nnn \l_@@_forth_input_str
          { \l_@@_tmpa_int + 1 } { -1 }
      }
    \int_set_eq:NN \l_@@_forth_term_end_int
      \g_@@_forth_term_min_int
    \tl_replace_all:Nnn \l_@@_tmpb_tl { ~ } { {~} }
    \tl_map_inline:Nn \l_@@_tmpb_tl
      {
        \@@_array_gset:Nnn \g_@@_forth_array
          { \l_@@_forth_term_end_int } { `##1 }
        \int_incr:N \l_@@_forth_term_end_int
      }
    \int_set_eq:NN \l_@@_forth_source_begin_int
      \g_@@_forth_term_min_int
    \@@_forth_data_gset:nn { \l_@@_forth_in_address_int } { 0 }
    \int_set_eq:NN \l_@@_forth_source_end_int
      \l_@@_forth_term_end_int
    \prg_return_true:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int, TF]{\@@_forth_read_char:N}
%   Unless at the end of the buffer, store in the first argument (an
%   integer variable) the character code of the next character in the
%   input and return \texttt{true}.  At the end of the buffer, simply
%   return \texttt{true}.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \@@_forth_read_char:N #1 { TF }
  {
    \int_compare:nNnTF
      \l_@@_forth_source_parsed_int < \l_@@_forth_source_end_int
      {
        \int_set:Nn #1
          {
            \@@_array_item:NN \g_@@_forth_array
              \l_@@_forth_source_parsed_int
          }
        \prg_return_true:
      }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_input_discard:n, \@@_forth_input_until:n}
% \begin{macro}[aux]
%   {\@@_forth_input_discard_aux:TFn, \@@_forth_input_discard_aux:NnTF}
%   Discarding or reading until a character is done by looping over
%   characters in the input buffer until some condition is met.  The
%   arguments of the \texttt{:TFn} auxiliary are code for characters
%   which match the delimiter, code for characters which do not match,
%   and the value of the delimiter.  Namely, \texttt{input_discard}
%   ignores delimiters by incrementing \texttt{source_parsed}, and stops
%   the loop when seeing a delimiter (by setting a boolean);
%   \texttt{input until} stops the loop when meeting a delimiter,
%   otherwise adds the character to the \texttt{input_word} string: in
%   both cases it goes to the next character in all cases (incrementing
%   \texttt{source_parsed}).  The \texttt{:TFn} auxiliary finds out
%   whether the delimiter is a space: in this case, characters in
%   \([0,32]\) match the delimiter, otherwise, only the delimiter itself
%   matches.  The \texttt{:NnTF} auxiliary receives a comparison
%   (\(<33\) or \(=|{#1}|\)), and the code for delimiters and
%   non-delimiters.  It sets \texttt{source_parsed} using~|>IN|, does
%   the loop, reading characters until either no character can be found
%   (\texttt{false} branch of \texttt{read_char}), or the loop is broken
%   by the code of |#3| or~|#4|.  Then set the value at~|>IN| correctly
%   for the outside world to see.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_input_discard:n
  {
    \@@_forth_input_discard_aux:TFn
      { \int_incr:N \l_@@_forth_source_parsed_int }
      { \bool_set_false:N \l_@@_tmpa_bool }
  }
\cs_new_protected_nopar:Npn \@@_forth_input_until:n
  {
    \tl_clear:N \l_@@_forth_input_word_str
    \@@_forth_input_discard_aux:TFn
      {
        \bool_set_false:N \l_@@_tmpa_bool
        \int_incr:N \l_@@_forth_source_parsed_int
      }
      {
        \@@_forth_str_put_char:Nn \l_@@_forth_input_word_str
          { \l_@@_tmpc_int }
          \int_incr:N \l_@@_forth_source_parsed_int
      }
  }
\cs_new_protected:Npn \@@_forth_input_discard_aux:TFn #1#2#3
  {
    \int_compare:nNnTF {#3} = { 32 }
      { \@@_forth_input_discard_aux:NnTF < { 33 } }
      { \@@_forth_input_discard_aux:NnTF = {#3} }
          {#1} {#2}
  }
\cs_new_protected:Npn \@@_forth_input_discard_aux:NnTF #1#2#3#4
  {
    \int_set:Nn \l_@@_forth_source_parsed_int
      {
        \l_@@_forth_source_begin_int
        + \@@_forth_data_get:n { \l_@@_forth_in_address_int }
      }
    \bool_set_true:N \l_@@_tmpa_bool
    \bool_while_do:Nn \l_@@_tmpa_bool
      {
        \@@_forth_read_char:NTF \l_@@_tmpc_int
          { \int_compare:nNnTF \l_@@_tmpc_int #1 {#2} {#3} {#4} }
          { \bool_set_false:N \l_@@_tmpa_bool }
      }
    \@@_forth_data_gset:nn { \l_@@_forth_in_address_int }
      {
        \l_@@_forth_source_parsed_int
        - \l_@@_forth_source_begin_int
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_input_word:}
%   Many functions read a word from the input.  This is a short-hand for
%   the task.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_input_word:
  {
    \@@_forth_input_discard:n { 32 }
    \@@_forth_input_until:n { 32 }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Numbers}
%
% \begin{macro}[int, TF]{\@@_forth_get_number:nN}
% \begin{macro}[int]{\@@_forth_get_number_aux:nNN}
%   Look for (and remove) a sign, and provide \(\pm 1\) as an argument
%   to \cs{@@_forth_get_number_aux:nNN}.  This auxiliary reads the
%   number itself, and builds it into \texttt{tmpa}.  The base is stored
%   in \texttt{tmpb} once and for all.  Find the bounds on allowed
%   digits: from |`0| to |`9| or less if the base is small, and from
%   |`A| to |`A| plus the base minus \(11\) (this works both for small
%   and large bases).  The upper bounds of those two ranges are stored
%   as \texttt{tmpc} and \texttt{tmpd}.  Loop through characters in the
%   string (we assume there is no space): for valid digits multiply
%   \texttt{tmpa} by the base and add the value of the digit (the
%   formula is different in the two ranges of digits).  Upon
%   encountering an invalid digit, set the boolean \texttt{tmpa}, which
%   marks a success, as false, and exit the loop.  Eventually, combine
%   the integer and the sign into |#3|, and return the value of the
%   \texttt{tmpa} boolean.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \@@_forth_get_number:nN #1#2 { TF }
  {
    \tl_if_head_eq_charcode:nNTF {#1} -
      {
        \exp_args:No \@@_forth_get_number_aux:nNN
          { \use_none:n #1 } - #2
      }
      { \@@_forth_get_number_aux:nNN {#1} + #2 }
  }
\cs_new_protected:Npn \@@_forth_get_number_aux:nNN #1#2#3
  {
    \int_zero:N \l_@@_tmpa_int
    \int_set:Nn \l_@@_tmpb_int { \@@_forth_base: }
    \int_set:Nn \l_@@_tmpc_int
      { \int_min:nn { `9 } { `0 + \l_@@_tmpb_int - 1 } }
    \int_set:Nn \l_@@_tmpd_int { `A + \l_@@_tmpb_int - 11 }
    \bool_set_true:N \l_@@_tmpa_bool
    \tl_map_inline:nn {#1}
      {
        \int_compare:nTF { `0 <= `##1 <= \l_@@_tmpc_int }
          {
            \int_set:Nn \l_@@_tmpa_int
              { \l_@@_tmpa_int * \l_@@_tmpb_int }
            \int_add:Nn \l_@@_tmpa_int { `##1 - `0 }
          }
          {
            \int_compare:nTF { `A <= `##1 <= \l_@@_tmpd_int }
              {
                \int_set:Nn \l_@@_tmpa_int
                  { \l_@@_tmpa_int * \l_@@_tmpb_int }
                \int_add:Nn \l_@@_tmpa_int { `##1 - `A + 10 }
              }
              {
                \bool_set_false:N \l_@@_tmpa_bool
                \tl_map_break:
              }
          }
      }
    \tl_set:Nx #3 { #2 \int_use:N \l_@@_tmpa_int }
    \bool_if:NTF \l_@@_tmpa_bool
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Misc}
%
% \begin{variable}{\l_@@_forth_stop_bool}
%   This boolean is set to be true by an empty word, which ends the
%   input.  This occurrence marks the end of the Forth code.
%    \begin{macrocode}
\bool_new:N \l_@@_forth_stop_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_forth_base_address_int}
% \begin{macro}[int, EXP]{\@@_forth_base:}
%   The address at which the base of the number system is stored, and a
%   function to retreive the base, reducing it to the interval \([2,
%   36]\).
%    \begin{macrocode}
\int_new:N \l_@@_forth_base_address_int
\cs_new:Npn \@@_forth_base:
  {
    \int_min:nn { 36 }
      {
        \int_max:nn { 2 }
          { \@@_forth_data_get:N \l_@@_forth_base_address_int }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{variable}
%
% \begin{variable}{\l_@@_forth_state_address_int}
%   Address of the |STATE| flag, \(0\) during interpretation,
%   \(2^{24}-1\) during compilation.
%    \begin{macrocode}
\int_new:N \l_@@_forth_state_address_int
%    \end{macrocode}
% \end{variable}
%
% \subsection{Core words}
%
% \subsubsection{Definition words}
%
% \begin{variable}{\l_@@_forth_def_word_str, \l_@@_forth_def_code_tl}
%   The word whose definition is being built (empty for, \eg, |:NONAME|
%   definitions), and the definition code.
%    \begin{macrocode}
\str_new:N \l_@@_forth_def_word_str
\tl_new:N \l_@@_forth_def_code_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_forth_def_seq}
%   A sequence holding information used when ending a definition.  Items
%   are of two types: words, and their partial definition.  When a
%   control-flow word is encountered, the partial definition is stored.
%   Once a definition finishes, the variables
%   \cs{l_@@_forth_def_word_str} and \cs{l_@@_forth_def_code_tl} are
%   restored to the values given at the top of the sequence.
%    \begin{macrocode}
\seq_new:N \l_@@_forth_def_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\@@_forth_def_code:x}
%   Add material to the definition.  Since all code is protected, and we
%   sometimes need to perform expansion, we only provide the expanding
%   variant.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_def_code:x #1
  { \tl_put_right:Nx \l_@@_forth_def_code_tl {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_@@_forth_def_name_str}
%   The last word that was defined: this is set just after the word's
%   meaning is changed, after the definition is fully read.
%    \begin{macrocode}
\tl_new:N \l_@@_forth_def_name_str
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{CONSTANT}
%    \begin{macrocode}
\@@_forth_new_core:nn { CONSTANT }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_input_word:
    \@@_forth_set_word:ox \l_@@_forth_input_word_str
      { \@@_forth_push:n { \int_use:N \l_@@_tmpa_int } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{CREATE}
%    \begin{macrocode}
\@@_forth_new_core:nn { CREATE }
  {
    \@@_forth_input_word:
    \@@_forth_set_word:ox \l_@@_forth_input_word_str
      {
        \@@_forth_push:n
          { \int_use:N \l_@@_forth_data_here_int }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{>BODY}
%   Pop execution token from the stack.  Hope that it has the form built
%   by |CREATE|: then the second item of its code (as a token list) is
%   an address, which we put onto the stack.  This is very fragile.
%    \begin{macrocode}
\@@_forth_new_core:nn { >BODY }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:n
      { \tl_item:on { \tex_the:D \tex_toks:D \l_@@_tmpa_int } { 2 } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{VARIABLE}
%   See code for |CREATE|.  Then reserve one cell by putting |0| there
%   (actually putting a fixed value is unnecessary, but that's the
%   available auxiliary).
%    \begin{macrocode}
\@@_forth_new_core:nn { VARIABLE }
  {
    \@@_forth_input_word:
    \@@_forth_set_word:ox \l_@@_forth_input_word_str
      {
        \@@_forth_push:n
          { \int_use:N \l_@@_forth_data_here_int }
      }
    \@@_forth_put_here:n { 0 }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: what is the compilation semantics of the colon word?
% \begin{macro}[int]{:}
%   Store the definition built previously in the \texttt{def} sequence
%   (to restore it once we are done).  Read a word and store it.  Then
%   switch to compiling state, and indicate in the control-flow stack
%   that a definition is in progress (magic number \(0\)).
%    \begin{macrocode}
\@@_forth_new_core:nn { : }
  {
    \seq_push:NV \l_@@_forth_def_seq \l_@@_forth_def_code_tl
    \tl_clear:N \l_@@_forth_def_code_tl
    \@@_forth_input_word:
    \seq_push:NV \l_@@_forth_def_seq \l_@@_forth_input_word_str
    \@@_forth_data_gset:nn
      { \l_@@_forth_state_address_int }
      { \c_@@_forth_mod_int - \c_one }
    \cs_set_eq:NN \@@_forth_perform:n \@@_forth_compile:n
    \@@_forth_control_open:n { 0 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{DOES>}
%   Check that the |DOES>| matches a start-of-definition on the control
%   stack (magic number \(0\)).  Save the code-so-far, and push the
%   magic number \(-1\) (for |DOES>|) onto the control stack.  Remain in
%   compilation mode.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { DOES> }
  {
    \@@_forth_control_close:nTF { 0 }
      {
        \seq_push:NV \l_@@_forth_def_seq \l_@@_forth_def_code_tl
        \tl_clear:N \l_@@_forth_def_code_tl
        \@@_forth_control_open:n { -1 }
      }
      { \msg_error:nnn { runner/forth } { misplaced } { DOES> } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{;}
% \begin{macro}[aux]{\@@_forth_compile_semicolon:x}
%   If the |;| matches a start-of-definition on the control stack (magic
%   number \(0\)), then get from the \texttt{def} stack the name of the
%   word to define, and assign it the definition code.  Then restore the
%   former value of \cs{l_@@_forth_def_code_tl}, and go back to
%   interpretation state.  If the |;| matches a |DOES>| (magic number
%   \(-1\)), then call an auxiliary function, because there is a lot of
%   work to do.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { ; }
  {
    \@@_forth_control_close:nTF { 0 }
      { \@@_forth_compile_semicolon:x { \l_@@_forth_def_code_tl } }
      {
        \@@_forth_control_close:nTF { -1 }
          { \@@_forth_compile_does: }
          { \msg_error:nnn { runner/forth } { misplaced } { ; } }
      }
  }
\cs_new_protected:Npn \@@_forth_compile_semicolon:x #1
  {
    \seq_pop:NN \l_@@_forth_def_seq \l_@@_tmpa_tl
    \@@_forth_set_word:ox \l_@@_tmpa_tl {#1}
    \seq_pop:NN \l_@@_forth_def_seq \l_@@_forth_def_code_tl
    \@@_forth_data_gset:nn
      { \l_@@_forth_state_address_int } { 0 }
    \cs_set_eq:NN \@@_forth_perform:n \@@_forth_interpret:n
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% ^^A todo: can |DOES>| be applied several times to the same word?
% ^^A : x DOES> 65 EMIT ; CREATE foo x x foo
% ^^A todo: what if we tick a |CREATE|d word then apply |DOES>|?
%
% \begin{macro}[int]{\@@_forth_compile_does:, \@@_forth_compiled_does:n}
%   The \texttt{compile_does} function is called when compiling a |;|
%   that closes a |DOES>|.  Retrieve the first part of the definition
%   from the \texttt{def} stack, then perform the definition of the
%   current word (the name is stored further down the stack, see the
%   \texttt{compile_semicolon} function), with the code before |DOES>|
%   and the \texttt{compiled_does} function, feeding it the code between
%   |DOES>| and~|;|.  At run-time, \texttt{compiled_does} fetches the
%   most recent definition, which hopefully was introduced via |CREATE|,
%   and redefines the word to perform the current execution token of the
%   word, followed by~|#1|, which is the code that followed |DOES>| in
%   the original definition.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_compile_does:
  {
    \seq_pop:NN \l_@@_forth_def_seq \l_@@_tmpc_tl
    \@@_forth_compile_semicolon:x
      {
        \l_@@_tmpc_tl
        \@@_forth_compiled_does:n
          { \l_@@_forth_def_code_tl }
      }
  }
\cs_new_protected:Npn \@@_forth_compiled_does:n #1
  {
    \prop_get:NVNTF
      \l_@@_forth_words_prop
      \l_@@_forth_def_name_str
      \l_@@_tmpa_tl
      {
        \@@_forth_set_word:ox \l_@@_forth_def_name_str
          {
            \@@_forth_execute:n { \tl_tail:N \l_@@_tmpa_tl }
            #1
          }
      }
      {
        \msg_error:nnx { runner/forth } { unknown-word }
          { \l_@@_forth_def_name_str }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{IMMEDIATE}
%   Change to \(2\) (immediate) the flag (\(\in\{1,2,3\}\)) of the last
%   defined word.
%    \begin{macrocode}
\@@_forth_new_core:nn { IMMEDIATE }
  {
    \prop_get:NVNTF
      \l_@@_forth_words_prop
      \l_@@_forth_def_name_str
      \l_@@_tmpa_tl
      {
        \prop_put:Nxx
          \l_@@_forth_words_prop
          { \l_@@_forth_def_name_str }
          { 2 \tl_tail:N \l_@@_tmpa_tl }
      }
      {
        \msg_error:nnx { runner/forth } { no-def-immediate }
          { \l_@@_forth_def_name_str }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{LITERAL}
%   The current top of stack is stored in the current definition: it
%   will be pushed back onto the stack at run-time.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { LITERAL }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_def_code:x
      { \@@_forth_push:n { \int_use:N \l_@@_tmpa_int } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{POSTPONE}
% \begin{macro}[aux, EXP]{\@@_forth_postpone:Nw}
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { POSTPONE }
  {
    \@@_forth_input_word:
    \prop_get:NoN
      \l_@@_forth_words_prop
      \l_@@_forth_input_word_str
      \l_@@_tmpa_tl
    \@@_forth_def_code:x
      {
        \exp_after:wN \@@_forth_postpone:Nw
          \l_@@_tmpa_tl \q_stop
      }
  }
\cs_new:Npn \@@_forth_postpone:Nw #1#2 \q_stop
  {
    \int_case:nnn {#1}
      {
        { 1 }
          { \@@_forth_def_code:x { \@@_forth_execute:n {#2} } }
        { 2 } { \@@_forth_execute:n {#2} }
      }
      { \@@_forth_execute:n { \int_eval:n { #2 + 1 } } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{RECURSE}
% \begin{macro}[aux]{\@@_forth_recurse:}
%   The command \cs{@@_forth_recurse:} is non-expandable, and goes
%   unchanged through all the expansions performed to collect the
%   definition.  At the very last step, just before storing the
%   definition into a \tn{toks} register, \cs{@@_forth_recurse:} is
%   defined to call the appropriate execution token to call the function
%   itself.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { RECURSE }
  { \@@_forth_def_code:x { \@@_forth_recurse: } }
\cs_new_eq:NN \@@_forth_recurse: ?
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Execution words}
%
% \begin{macro}[int]{'}
%   Push onto the data stack the execution token associated to a word
%   (read from the input).  The word is read from the input after
%   removing all leading spaces.
%    \begin{macrocode}
\@@_forth_new_core:nn { ' }
  {
    \@@_forth_input_word:
    \prop_get:NoN
      \l_@@_forth_words_prop
      \l_@@_forth_input_word_str
      \l_@@_tmpa_tl
    \@@_forth_push:n { \tl_tail:N \l_@@_tmpa_tl }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{[']}
%   Read a word, find it in the dictionary (prop), and find its
%   execution token (the tail).  Then add to the current definition some
%   code to place this execution token on the stack.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { ['] }
  {
    \@@_forth_input_word:
    \prop_get:NoN
      \l_@@_forth_words_prop
      \l_@@_forth_input_word_str
      \l_@@_tmpa_tl
    \@@_forth_def_code:x
      { \@@_forth_push:n { \tl_tail:N \l_@@_tmpa_tl } }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: take (tmpa mod 2^16 or 2^15).
% \begin{macro}[int]{EXECUTE}
%   Pop from the data stack an execution token.  Perform it.
%    \begin{macrocode}
\@@_forth_new_core:nn { EXECUTE }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_execute:n { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{[, ]}
%   Change the value at |STATE|, and redefine \cs{@@_forth_perform:n},
%   to interpret or to compile the words found in the input.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { [ }
  {
    \@@_forth_data_gset:nn
      { \l_@@_forth_state_address_int } { 0 }
    \cs_set_eq:NN \@@_forth_perform:n \@@_forth_interpret:n
  }
\@@_forth_new_immediate_core:nn { ] }
  {
    \@@_forth_data_gset:nn
      { \l_@@_forth_state_address_int }
      { \c_@@_forth_mod_int - \c_one }
    \cs_set_eq:NN \@@_forth_perform:n \@@_forth_compile:n
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_@@_forth_find_word_str}
%   String given to |FIND|, converted to a user representation.
%    \begin{macrocode}
\str_new:N \l_@@_forth_find_word_str
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{FIND}
%   Pop the address \(a\) of a counted string from the stack, and let
%   \(v\) be the value at \(a\) (length of the string).  The string
%   ranges from \(a+1\) to \(b = a+v\).  Go through these data cells,
%   appending the corresponding character to the \texttt{find_word}
%   string.
%    \begin{macrocode}
\@@_forth_new_core:nn { FIND }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \int_set:Nn \l_@@_tmpb_int
      { \l_@@_tmpa_int + \@@_forth_data_get:n { \l_@@_tmpa_int } }
    \tl_clear:N \l_@@_forth_find_word_str
    \int_step_inline:nnnn
      { \l_@@_tmpa_int + 1 } { 1 } { \l_@@_tmpb_int }
      {
        \@@_forth_str_put_char:Nn \l_@@_forth_find_word_str
          { \@@_forth_data_get:n {#1} }
      }
    \prop_get:NVNF
      \l_@@_forth_words_prop
      \l_@@_forth_find_word_str
      \l_@@_tmpa_tl
      { \tl_set:Nn \l_@@_tmpa_tl { 3 } }
    \int_compare:nNnTF { \tl_head:N \l_@@_tmpa_tl } = { 3 }
      { \@@_forth_push:nn { \l_@@_tmpa_int } { 0 } }
      {
        \@@_forth_push:n { \tl_tail:N \l_@@_tmpa_tl }
        \int_compare:nNnTF { \tl_head:N \l_@@_tmpa_tl } = { 2 }
          { \@@_forth_push:n { 1 } }
          { \@@_forth_push_signed:n { -1 } }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Stack words}
%
% \begin{macro}[int]{DEPTH}
%    \begin{macrocode}
\@@_forth_new_core:nn { DEPTH }
  {
    \@@_forth_push:n
      { \l_@@_forth_stack_here_int - \g_@@_forth_stack_min_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{>R}
%   Pop from the data stack onto the return stack.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { >R }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_return_push:n \l_@@_tmpa_int
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: |R>| and |R@| can blow up if return stack contains non-numbers.
% \begin{macro}[int]{R>}
%   Pop from the return stack onto the data stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { R> }
  {
    \@@_forth_return_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:n { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: optimize.
% \begin{macro}[int]{R@}
%   Copy from the return stack onto the data stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { R@ }
  {
    \@@_forth_return_pop_int:N \l_@@_tmpa_int
    \@@_forth_return_push:n { \l_@@_tmpa_int }
    \@@_forth_push:n { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{?DUP}
%   Duplicate top of stack if non-zero.
%    \begin{macrocode}
\@@_forth_new_core:nn { ?DUP }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:n { \l_@@_tmpa_int }
    \int_compare:nNnF \l_@@_tmpa_int = \c_zero
      { \@@_forth_push:n { \l_@@_tmpa_int } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{DROP, 2DROP}
%   Pop stack, once or twice.
%    \begin{macrocode}
\@@_forth_new_core:nn { DROP }
  { \@@_forth_pop_int:N \l_@@_tmpa_int }
\@@_forth_new_core:nn { 2DROP }
  { \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{DUP, 2DUP}
%   Turn \(x\) to \(x, x\), or \(x_1, x_2\) to \(x_1, x_2, x_1, x_2\).
%    \begin{macrocode}
\@@_forth_new_core:nn { DUP }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:nn { \l_@@_tmpa_int } { \l_@@_tmpa_int }
  }
\@@_forth_new_core:nn { 2DUP }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push:nnnn
      { \l_@@_tmpa_int } { \l_@@_tmpb_int }
      { \l_@@_tmpa_int } { \l_@@_tmpb_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{OVER, 2OVER}
%   Turn \(x_1, x_2\) to \(x_1, x_2, x_1\), or \(x_1, x_2, x_3, x_4\) to
%   \(x_1, x_2, x_3, x_4, x_1, x_2\).
%    \begin{macrocode}
\@@_forth_new_core:nn { OVER }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push:nnn
      { \l_@@_tmpa_int } { \l_@@_tmpb_int } { \l_@@_tmpa_int }
  }
\@@_forth_new_core:nn { 2OVER }
  {
    \@@_forth_pop_int:NNNN
      \l_@@_tmpa_int \l_@@_tmpb_int
      \l_@@_tmpc_int \l_@@_tmpd_int
    \@@_forth_push:nnnnnn
      { \l_@@_tmpa_int } { \l_@@_tmpb_int }
      { \l_@@_tmpc_int } { \l_@@_tmpd_int }
      { \l_@@_tmpa_int } { \l_@@_tmpb_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{ROT}
%   Turn \(x_1, x_2, x_3\) to \(x_2, x_3, x_1\).
%    \begin{macrocode}
\@@_forth_new_core:nn { ROT }
  {
    \@@_forth_pop_int:NNN
      \l_@@_tmpa_int \l_@@_tmpb_int \l_@@_tmpc_int
    \@@_forth_push:nnn
      { \l_@@_tmpb_int } { \l_@@_tmpc_int } { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{SWAP, 2SWAP}
%   Turn \(x_1, x_2\) to \(x_2, x_1\), or \(x_1, x_2, x_3, x_4\) to
%   \(x_3, x_4, x_1, x_2\).
%    \begin{macrocode}
\@@_forth_new_core:nn { SWAP }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push:nn { \l_@@_tmpb_int } { \l_@@_tmpa_int }
  }
\@@_forth_new_core:nn { 2SWAP }
  {
    \@@_forth_pop_int:NNNN
      \l_@@_tmpa_int \l_@@_tmpb_int
      \l_@@_tmpc_int \l_@@_tmpd_int
    \@@_forth_push:nn
      { \l_@@_tmpc_int } { \l_@@_tmpd_int }
      { \l_@@_tmpa_int } { \l_@@_tmpb_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Comparison words}
%
% \begin{macro}[int]{0<}
%   If \(a<0\) push true, otherwise false.
%    \begin{macrocode}
\@@_forth_new_core:nn { 0< }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \int_compare:nNnTF
      { \@@_forth_signed:N \l_@@_tmpa_int } < \c_zero
      { \@@_forth_push_true: }
      { \@@_forth_push_false: }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{0=}
%   If \(a\) is \(0\), push true, otherwise false.
%    \begin{macrocode}
\@@_forth_new_core:nn { 0= }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \int_compare:nNnTF \l_@@_tmpa_int = \c_zero
      { \@@_forth_push_true: }
      { \@@_forth_push_false: }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{<, =, >}
%   Signed comparisons.  Push true or false.
%    \begin{macrocode}
\@@_forth_new_core:nn { < }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_compare:nNnTF
      { \@@_forth_signed:N \l_@@_tmpa_int }
      < { \@@_forth_signed:N \l_@@_tmpb_int }
      { \@@_forth_push_true: }
      { \@@_forth_push_false: }
  }
\@@_forth_new_core:nn { = }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_compare:nNnTF
      { \@@_forth_signed:N \l_@@_tmpa_int }
      = { \@@_forth_signed:N \l_@@_tmpb_int }
      { \@@_forth_push_true: }
      { \@@_forth_push_false: }
  }
\@@_forth_new_core:nn { > }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_compare:nNnTF
      { \@@_forth_signed:N \l_@@_tmpa_int }
      > { \@@_forth_signed:N \l_@@_tmpb_int }
      { \@@_forth_push_true: }
      { \@@_forth_push_false: }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{U<}
%   Compare unsigned numbers.  Push true or false.
%    \begin{macrocode}
\@@_forth_new_core:nn { U< }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_compare:nNnTF \l_@@_tmpa_int < \l_@@_tmpb_int
      { \@@_forth_push_true: }
      { \@@_forth_push_false: }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Arithmetic words}
%
% \begin{macro}[int]{1+, 1-}
%   Increment or decrement the top of the stack.  Catch overflow by
%   making sure that the result is in \([-2^{24}, 2^{24}-1]\) and
%   calling the \texttt{push_signed} function.
%    \begin{macrocode}
\@@_forth_new_core:nn { 1+ }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push_signed:n
      { \l_@@_tmpa_int + 1 - \c_@@_forth_mod_int }
  }
\@@_forth_new_core:nn { 1- }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push_signed:n { \l_@@_tmpa_int - 1 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{2*, 2/}
%   Multiply or divide the top of the stack by~\(2\).  For
%   multiplication, subtract \(2^{24}\) to get the result in the range
%   \([-2^{24}, 2^{24}-2]\), then call the \texttt{push_signed}
%   function.  For division, use floored division (\((-1)/2=-1\)).
%    \begin{macrocode}
\@@_forth_new_core:nn { 2* }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push_signed:n
      { \l_@@_tmpa_int * 2 - \c_@@_forth_mod_int }
  }
\@@_forth_new_core:nn { 2/ }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \int_if_even:nTF { \l_@@_tmpa_int }
      {
        \@@_forth_push_signed:n
          { \@@_forth_signed:N \l_@@_tmpa_int / 2 }
      }
      {
        \@@_forth_push_signed:n
          { ( \@@_forth_signed:N \l_@@_tmpa_int - 1 ) / 2 }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{ABS}
%   Get a signed integer from the top of the stack, and change it to its
%   absolute value.
%    \begin{macrocode}
\@@_forth_new_core:nn { ABS }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:n
      { \int_abs:n { \@@_forth_signed:N \l_@@_tmpa_int } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{MAX, MIN}
%   Get two signed integers from the stack, and push the
%   biggest/smallest back onto the stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { MAX }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push_signed:n
      {
        \int_max:nn
          { \@@_forth_signed:N \l_@@_tmpa_int }
          { \@@_forth_signed:N \l_@@_tmpb_int }
      }
  }
\@@_forth_new_core:nn { MIN }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push_signed:n
      {
        \int_min:nn
          { \@@_forth_signed:N \l_@@_tmpa_int }
          { \@@_forth_signed:N \l_@@_tmpb_int }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{NEGATE}
%   Get a signed integer from the top of the stack, and change it to its
%   opposite.
%    \begin{macrocode}
\@@_forth_new_core:nn { NEGATE }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push_signed:n
      { - \@@_forth_signed:N \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{-, +}
%   Get two integers from the data stack, sum or take the difference,
%   and push the result onto the stack.  The integers can be signed or
%   unsigned, but are given to us as unsigned values in \([0,
%   2^{24}-1]\), hence there is an ambiguity by \(2^{24}\).  The
%   difference of two unsigned values lies in \([-2^{24}+1, 2^{24}-1]\),
%   and can be brought back to \([0, 2^{24}-1]\) by adding \(2^{24}\) to
%   negative numbers, as \cs{@@_forth_push_signed:n} does.  The sum,
%   shifted by \(2^{24}\), lies in \([-2^{24}, 2^{24}-2]\), and is also
%   appropriate input for the \texttt{push_signed} function.
%    \begin{macrocode}
\@@_forth_new_core:nn { - }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push_signed:n
      { \l_@@_tmpa_int - \l_@@_tmpb_int }
  }
\@@_forth_new_core:nn { + }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push_signed:n
      {
        \l_@@_tmpa_int + \l_@@_tmpb_int
        - \c_@@_forth_mod_int
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{*}
%   Multiply two integers, then push the result (modulo \(2^{24}\)) onto
%   the stack.  To avoid \TeX{} overflow, we manipulate the numbers as
%   floating points, computing \(a\times b - 2^{24}\times\bigl\lfloor
%   a\times b / 2^{24}\bigr\rfloor\).
%    \begin{macrocode}
\@@_forth_new_core:nn { * }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push_fp_mod:n
      { \l_@@_tmpa_int * \l_@@_tmpb_int }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: division by zero?
% \begin{macro}[int]{/}
%   Pop two integers from the stack.  Perform symmetric division (using
%   the values as signed numbers), and push the (signed) result onto the
%   stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { / }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push_signed:n
      {
        \int_div_truncate:nn
          { \@@_forth_signed:N \l_@@_tmpa_int }
          { \@@_forth_signed:N \l_@@_tmpb_int }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: division by zero?
% \begin{macro}[int]{MOD}
%   Pop two signed integers from the stack.  Push the remainder of \(a\)
%   divided by \(b\) onto the stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { MOD }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push_signed:n
      {
        \int_mod:nn
          { \@@_forth_signed:N \l_@@_tmpa_int }
          { \@@_forth_signed:N \l_@@_tmpb_int }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: division by zero?
% \begin{macro}[int]{/MOD}
%   Get two signed integers from the stack, then perform the division,
%   and put the remainder, then the quotient, on the stack.  Both
%   quotient and remainder remain in the range \([-2^{23}, 2^{23}]\)
%   (the upper bound happens when computing \((-2^{23})/(-1)\)), and are
%   brought back to an unsigned form before pushing onto the stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { /MOD }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_set:Nn \l_@@_tmpa_int
      { \@@_forth_signed:N \l_@@_tmpa_int }
    \int_set:Nn \l_@@_tmpb_int
      { \@@_forth_signed:N \l_@@_tmpb_int }
    \@@_forth_push_signed:n
      { \int_mod:nn { \l_@@_tmpa_int } { \l_@@_tmpb_int } }
    \@@_forth_push_signed:n
      {
        \int_div_truncate:nn
          { \l_@@_tmpa_int } { \l_@@_tmpb_int }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: division by zero?
% ^^A todo: bug because of double rounding.  Later, fp will provide mod.
% \begin{macro}[int]{*/}
%   Pop three signed integers from the stack and compute \(a\times b/c\)
%   using floating points.  The result is output, after rounding towards
%   zero and reducing its range in case of overflow.
%    \begin{macrocode}
\@@_forth_new_core:nn { */ }
  {
    \@@_forth_pop_int:NNN
      \l_@@_tmpa_int \l_@@_tmpb_int \l_@@_tmpc_int
    \@@_forth_push_fp_mod:n
      {
        \@@_forth_signed:N \l_@@_tmpa_int
        * \@@_forth_signed:N \l_@@_tmpb_int
        / \@@_forth_signed:N \l_@@_tmpc_int
      }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: bug because of double rounding.  Later, fp will provide mod.
% \begin{macro}[aux]{\@@_forth_push_remquo:nNN}
%   Given a (possibly large) integer expression |#1|, an integer |#2|,
%   and a rounding direction |0| or |-|, compute using floating points
%   the integer quotient and remainder of dividing |#1| by |#2|.
%   Rounding toward~\(0\) gives symmetric division.  Rounding
%   towards~\(-\infty\) gives floored division.  The results are pushed
%   onto the stack, first the remainder, then the quotient.  Using the
%   \texttt{fp_mod} pushing function protects against
%   overflow/underflow, and takes care of putting signed results back
%   into unsigned form.  This auxiliary is used by |FM/MOD|, |SM/REM|,
%   |UM/MOD|, |*/MOD|, |M*|, and |UM*|.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_push_remquo:nNN #1#2#3
  {
    \fp_set:Nn \l_@@_tmpa_fp { round #3 ( (#1) / #2 ) }
    \@@_forth_push_fp_mod:n { #1 - #2 * \l_@@_tmpa_fp }
    \@@_forth_push_fp_mod:n { \l_@@_tmpa_fp }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{M*, UM*}
%   Pop two signed or unsigned integers from the stack, then split the
%   product into the quotient by \cs{c_@@_forth_mod_int} and its
%   remainder (using floored division).  This is done by
%   \cs{@@_forth_push_remquo:nNN}, which pushes the remainder and the
%   quotient onto the stack, in the expected order.
%    \begin{macrocode}
\@@_forth_new_core:nn { M* }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_set:Nn \l_@@_tmpa_int
      { \@@_forth_signed:N \l_@@_tmpa_int }
    \int_set:Nn \l_@@_tmpb_int
      { \@@_forth_signed:N \l_@@_tmpb_int }
    \@@_forth_push_remquo:nNN
      { \l_@@_tmpa_int * \l_@@_tmpb_int } \c_@@_forth_mod_int -
  }
\@@_forth_new_core:nn { UM* }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push_remquo:nNN
      { \l_@@_tmpa_int * \l_@@_tmpb_int } \c_@@_forth_mod_int -
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{FM/MOD, SM/REM, UM/MOD}
% \begin{macro}[aux]{\@@_forth_mslash:NN}
%   The auxiliary pops a cell \(c\) and a cell pair \((a,b)\) from the
%   stack.  First convert to signed integers if needed (for the cell
%   pair, this only affects the leading cell \(b\)).  Then push the
%   remainder and quotient of dividing the value \(a + b \cdot 2^{24}\)
%   of the cell pair by \(c\), rounding towards \(-\infty\) for floored
%   division (|FM/MOD| and |UM/MOD|) and towards \(0\) for symmetric
%   division (|SM/REM|).
%    \begin{macrocode}
\@@_forth_new_core:nn { FM/MOD }
  { \@@_forth_mslash:NN \@@_forth_signed:N - }
\@@_forth_new_core:nn { SM/REM }
  { \@@_forth_mslash:NN \@@_forth_signed:N 0 }
\@@_forth_new_core:nn { UM/MOD }
  { \@@_forth_mslash:NN \prg_do_nothing: - }
\cs_new_protected:Npn \@@_forth_mslash:NN #1#2
  {
    \@@_forth_pop_int:NNN
      \l_@@_tmpa_int \l_@@_tmpb_int \l_@@_tmpc_int
    \int_set:Nn \l_@@_tmpb_int { #1 \l_@@_tmpb_int }
    \int_set:Nn \l_@@_tmpc_int { #1 \l_@@_tmpc_int }
    \@@_forth_push_remquo:nNN
      {
        \l_@@_tmpa_int
        + \l_@@_tmpb_int * \c_@@_forth_mod_int
      }
      \l_@@_tmpc_int #2
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{*/MOD}
%   Pop three signed integers from the stack, and use
%   \cs{@@_forth_push_remquo:nNN} to evaluate the remainder and quotient
%   of the symmetric division \((a\times b) / c\).
%    \begin{macrocode}
\@@_forth_new_core:nn { */MOD }
  {
    \@@_forth_pop_int:NNN
      \l_@@_tmpa_int \l_@@_tmpb_int \l_@@_tmpc_int
    \int_set:Nn \l_@@_tmpa_int
      { \@@_forth_signed:N \l_@@_tmpa_int }
    \int_set:Nn \l_@@_tmpb_int
      { \@@_forth_signed:N \l_@@_tmpb_int }
    \int_set:Nn \l_@@_tmpc_int
      { \@@_forth_signed:N \l_@@_tmpc_int }
    \@@_forth_push_remquo:nNN
      { \l_@@_tmpa_int * \l_@@_tmpb_int } \l_@@_tmpc_int 0
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{S>D}
%   The most significant part of a double-cell integer is stored on top,
%   thus converting a single cell to a double-cell integer simply
%   requires pushing \(0\) for positive and \(-1\) (all bits set) for
%   negative integers.
%    \begin{macrocode}
\@@_forth_new_core:nn { S>D }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:n { \l_@@_tmpa_int }
    \int_compare:nNnTF
      { \l_@@_tmpa_int } < { \c_@@_forth_mod_int / \c_two }
      { \@@_forth_push:n { 0 } }
      { \@@_forth_push:n { \c_@@_forth_mod_int - \c_one } }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Bitwise words}
%
% \begin{macro}[int]{AND, OR, XOR}
%   Pop two unsigned integers from the stack, evaluate the appropriate
%   bitwise logical operator using a \pkg{runner} auxiliary, and push
%   the (unsigned) result back onto the stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { AND }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_bit_and:NNN
      \l_@@_tmpc_int \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push:n { \l_@@_tmpc_int }
  }
\@@_forth_new_core:nn { OR }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_bit_or:NNN
      \l_@@_tmpc_int \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push:n { \l_@@_tmpc_int }
  }
\@@_forth_new_core:nn { XOR }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_bit_xor:NNN
      \l_@@_tmpc_int \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push:n { \l_@@_tmpc_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{INVERT}
%   Logical inversion amounts to \(x \to -1-x\).
%    \begin{macrocode}
\@@_forth_new_core:nn { INVERT }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:n
      { \c_@@_forth_mod_int - \l_@@_tmpa_int - \c_one }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{LSHIFT}
%   The function \cs{@@_bit_lshift:NN} can return arbitrary non-negative
%   \TeX{} integers, and we take the residue modulo \(2^{24}\).
%    \begin{macrocode}
\@@_forth_new_core:nn { LSHIFT }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_bit_lshift:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push_mod:n { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{RSHIFT}
%   The function \cs{@@_bit_rshift:NN} expects a signed integer, and
%   repeatedly does floored division by \(2\).
%    \begin{macrocode}
\@@_forth_new_core:nn { RSHIFT }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_set:Nn \l_@@_tmpa_int
      { \@@_forth_signed:N \l_@@_tmpa_int }
    \@@_bit_rshift:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push_signed:n { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Storage words}
%
% ^^A todo: Simplify how |ALIGNED| triggers an error upon empty stack
% \begin{macro}[int]{ALIGN, ALIGNED}
%   Since all addresses are aligned, |ALIGN| does nothing, |ALIGNED|
%   simply pops and pushes back the same value.
%    \begin{macrocode}
\@@_forth_new_core:nn { ALIGN } { }
\@@_forth_new_core:nn { ALIGNED }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:n \l_@@_tmpa_int
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{ALLOT}
%   Shift the data pointer by the value at the top of the stack
%    \begin{macrocode}
\@@_forth_new_core:nn { ALLOT }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \int_add:Nn \l_@@_forth_data_here_int \l_@@_tmpa_int
    \int_compare:nNnTF
      \l_@@_forth_data_here_int < \g_@@_forth_data_min_int
      {
        \msg_error:nn { runner/forth } { out-of-bounds }
        \int_set_eq:NN \l_@@_forth_data_here_int
          \g_@@_forth_data_min_int
      }
      {
        \int_compare:nNnT
          \l_@@_forth_data_here_int > \l_@@_forth_data_text_int
          {
            \msg_error:nn { runner/forth } { out-of-memory }
            \int_set_eq:NN \l_@@_forth_data_here_int
              \l_@@_forth_data_text_int
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{FILL}
%   Fill the addresses from \(a\) to \(a+b-1\) with the value \(c\).
%    \begin{macrocode}
\@@_forth_new_core:nn { FILL }
  {
    \@@_forth_pop_int:NNN
      \l_@@_tmpa_int \l_@@_tmpb_int \l_@@_tmpc_int
    \int_step_inline:nnnn
      { \l_@@_tmpa_int }
      { 1 }
      { \l_@@_tmpa_int + \l_@@_tmpb_int - 1 }
      { \@@_forth_data_gset:nn {#1} { \l_@@_tmpc_int } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{HERE}
%    \begin{macrocode}
\@@_forth_new_core:nn { HERE }
  { \@@_forth_push:n { \l_@@_forth_data_here_int } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{MOVE}
%   If the number \(c\) of cells to copy from \(a\) to \(b\) is not
%   positive, do nothing.  If \(a<b\), copy from the top end of the
%   block of cells.  If \(b\leq a\) start from the bottom end.  This
%   works even if the blocks overlap.
%    \begin{macrocode}
\@@_forth_new_core:nn { MOVE }
  {
    \@@_forth_pop_int:NNN
      \l_@@_tmpa_int \l_@@_tmpb_int \l_@@_tmpc_int
    \int_compare:nNnT \l_@@_tmpc_int > \c_zero
      {
        \int_compare:nNnTF \l_@@_tmpa_int < \l_@@_tmpb_int
          {
            \int_step_inline:nnnn
              { \l_@@_tmpc_int - 1 } { -1 } { 0 }
          }
          {
            \int_step_inline:nnnn
              { 0 } { 1 } { \l_@@_tmpc_int - 1 }
          }
              {
                \@@_forth_data_gset:nn
                  { \l_@@_tmpb_int + #1 }
                  { \@@_forth_data_get:n { \l_@@_tmpa_int + #1 } }
              }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{!}
%   Store value at a given address.
%    \begin{macrocode}
\@@_forth_new_core:nn { ! }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_data_gset:nn
      { \l_@@_tmpb_int } { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{2!}
%   Store values at a given address and at the next cell.
%    \begin{macrocode}
\@@_forth_new_core:nn { 2! }
  {
    \@@_forth_pop_int:NNN
      \l_@@_tmpa_int \l_@@_tmpb_int \l_@@_tmpc_int
    \@@_forth_data_gset:nn
      { \l_@@_tmpc_int } { \l_@@_tmpb_int }
    \@@_forth_data_gset:nn
      { \l_@@_tmpc_int + 1 } { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{+!}
%   Sum \(a\) and the value at \(b\) into the integer
%   \cs{l_@@_tmpa_int}, then store that into the address at \(b\).
%    \begin{macrocode}
\@@_forth_new_core:nn { +! }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_add:Nn \l_@@_tmpa_int
      { \@@_forth_data_get:N \l_@@_tmpb_int }
    \int_compare:nNnF \l_@@_tmpa_int < \c_@@_forth_mod_int
      { \int_sub:Nn \l_@@_tmpa_int \c_@@_forth_mod_int }
    \@@_forth_data_gset:nn
      { \l_@@_tmpb_int } { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]+,+
%   Store value in a newly allocated cell, given by the data-space
%   pointer ``\texttt{here}''.
%    \begin{macrocode}
\@@_forth_new_core:nn { , }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_put_here:n { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{@}
%   Pop an address from the stack, and push the value \(x\) of the
%   corresponding memory cell.
%    \begin{macrocode}
\@@_forth_new_core:nn { @ }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:n
      { \@@_forth_data_get:N \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{2@}
%   Find an address on the stack, and fetch the value \(x_2\) of the
%   corresponding memory cell, and the next, \(x_1\).  The value \(x_2\)
%   (at the given address) ends up at the top of the stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { 2@ }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:nn
      { \@@_forth_data_get:n { \l_@@_tmpa_int + 1 } }
      { \@@_forth_data_get:N \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{C!, C@}
% \begin{macro}[int]+C,+
%   Since cells are one character wide, storing at a character-aligned
%   address, or at an aligned adress, is the same.
%    \begin{macrocode}
\@@_forth_core_alias:nn { C! } { ! }
\@@_forth_core_alias:nn { C, } { , }
\@@_forth_core_alias:nn { C@ } { @ }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{CELL+, CELLS, CHAR+, CHARS}
%   Since the cell size, the character size and the address sizes are
%   identical, |CELL+| and |CHAR+| simply add~\(1\), like |1+|, and
%   |CELLS| and |CHARS| do nothing to the top of the stack (which must
%   be present), just like |ALIGNED|.
%    \begin{macrocode}
\@@_forth_core_alias:nn { CELL+ } { 1+ }
\@@_forth_core_alias:nn { CHAR+ } { 1+ }
\@@_forth_core_alias:nn { CELLS } { ALIGNED }
\@@_forth_core_alias:nn { CHARS } { ALIGNED }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Words for display, input, and strings}
%
% \begin{macro}[int]{.}
%   Get a signed value from the data stack, convert it to the base.
%   Trailing space.
%    \begin{macrocode}
\@@_forth_new_core:nn { . }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_output:x
      {
        \int_to_base:nn
          { \@@_forth_signed:N \l_@@_tmpa_int }
          { \@@_forth_base: } ~
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{U.}
%   Get an unsigned value from the data stack, convert it to the base.
%   Trailing space.
%    \begin{macrocode}
\@@_forth_new_core:nn { U. }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_output:x
      { \int_to_base:nn { \l_@@_tmpa_int } { \@@_forth_base: } ~ }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: should |."|, |S"|, |ABORT"|, or |(| ignore leading delimiters? %)
% \begin{macro}[int]+."+
%   The dot-quote word reads the input until a double quote.  It has no
%   interpretation semantics.  Its compilation semantics is to add code
%   to the current definition that display what it read.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { ." }
  {
    \@@_forth_input_until:n { `" }
    \@@_forth_def_code:x
      { \@@_output:n { \l_@@_forth_input_word_str } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{BL}
%    \begin{macrocode}
\@@_forth_new_core:nn { BL }
  { \@@_forth_push:n { `\  } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{CHAR}
%   Read a word, leave its first character on the stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { CHAR }
  {
    \@@_forth_input_word:
    \tl_set:Nx \l_@@_tmpa_tl
      { \str_head:N \l_@@_forth_input_word_str }
    \@@_forth_push:n { \exp_after:wN ` \l_@@_tmpa_tl }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{[CHAR]}
%   Read a word, add code to the current definition that leaves its
%   first character on the stack.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { [CHAR] }
  {
    \@@_forth_input_word:
    \@@_forth_def_code:x
      { \@@_forth_push:n { ` \str_head:N \l_@@_forth_input_word_str } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{COUNT}
%   Convert the address of a counted string to its length (on top of the
%   stack), and the address of the first character.  This could be
%   defined with |: COUNT DUP 1+ SWAP @ ;| but this is faster.
%    \begin{macrocode}
\@@_forth_new_core:nn { COUNT }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:nn
      { \l_@@_tmpa_int + 1 }
      { \@@_forth_data_get:N \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{CR}
%    \begin{macrocode}
\@@_forth_new_core:nn { CR }
  { \@@_output:x { \iow_newline: } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{DECIMAL}
%    \begin{macrocode}
\@@_forth_new_core:nn { DECIMAL }
  { \@@_forth_data_gset:nn { \l_@@_forth_base_address_int } { 10 } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{EMIT}
%   Output a character with the character code found by popping the data
%   stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { EMIT }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_output_char:n { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: bug?  Should ': X 0 S" 1 ." EVALUATE . ; X' give '0 1' or '1 0'?
% \begin{macro}[int]{EVALUATE}
%    \begin{macrocode}
\@@_forth_new_core:nn { EVALUATE }
  {
    \seq_push:NV \l_@@_forth_sources_seq
      \l_@@_forth_source_begin_int
    \seq_push:Nx \l_@@_forth_sources_seq
      { \@@_forth_data_get:n { \l_@@_forth_in_address_int } }
    \seq_push:NV \l_@@_forth_sources_seq
      \l_@@_forth_source_end_int
    \seq_push:NV \l_@@_forth_sources_seq \l_@@_forth_input_str
    \@@_forth_pop_int:NN
      \l_@@_forth_source_begin_int \l_@@_tmpa_int
    \int_set:Nn \l_@@_forth_source_end_int
      { \l_@@_forth_source_begin_int + \l_@@_tmpa_int }
    \tl_clear:N \l_@@_forth_input_str
    \@@_forth_data_gset:nn \l_@@_forth_in_address_int { 0 }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: is S" allowed to overlap with the region of WORD or #> ?
% \begin{macro}[int]+S"+ Read a double-quoted string and measure its
%   length \texttt{tmpa}.  Try to allocate that much space for a text
%   literal, decreasing the \texttt{data_text} integer.  If this enters
%   the allotted region, complain, and forget the string.  Otherwise,
%   the string will start at the address \texttt{data_text} (new) and
%   have length \texttt{tmpa}, so we add to the current definition code
%   that pushes those onto the stack.  Finally, store the string, by
%   looping over it (spaces are first protected to avoid losing them),
%   keeping track of the address of each character using \texttt{tmpb}.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { S" }
  {
    \@@_forth_input_until:n { `" }
    \int_set:Nn \l_@@_tmpa_int { \str_count:N \l_@@_forth_input_word_str }
    \int_sub:Nn \l_@@_forth_data_text_int { \l_@@_tmpa_int }
    \int_compare:nNnTF
      \l_@@_forth_data_text_int < \l_@@_forth_data_here_int
      {
        \msg_error:nn { runner/forth } { out-of-memory }
        \int_set_eq:NN \l_@@_forth_data_text_int
          \l_@@_forth_data_here_int
      }
      {
        \@@_forth_def_code:x
          {
            \@@_forth_push:nn
              { \int_use:N \l_@@_forth_data_text_int }
              { \int_use:N \l_@@_tmpa_int }
          }
        \int_set_eq:NN \l_@@_tmpb_int \l_@@_forth_data_text_int
        \tl_set_eq:NN \l_@@_tmpa_tl \l_@@_forth_input_word_str
        \tl_replace_all:Nnn \l_@@_tmpa_tl { ~ } { \ }
        \tl_map_inline:Nn \l_@@_tmpa_tl
          {
            \@@_forth_data_gset:nn { \l_@@_tmpb_int } { `#1 }
            \int_incr:N \l_@@_tmpb_int
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{SPACE}
%    \begin{macrocode}
\@@_forth_new_core:nn { SPACE }
  { \@@_output:n { ~ } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{SPACES}
%    \begin{macrocode}
\@@_forth_new_core:nn { SPACES }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_output:x { \prg_replicate:nn { \l_@@_tmpa_int } { ~ } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{TYPE}
%    \begin{macrocode}
\@@_forth_new_core:nn { TYPE }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_step_inline:nnnn
      { \l_@@_tmpa_int }
      { 1 }
      { \l_@@_tmpa_int + \l_@@_tmpb_int - 1 }
      {
        \@@_output_char:n
          { \@@_forth_data_get:n {#1} }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: avoid back-and-forth between TeX strings and Forth counted strings
% \begin{macro}[int]{WORD}
%   Pop a character from the stack.  The word will be stored as a
%   counted string in the region from \texttt{data_here} (included) to
%   \texttt{data_word}, so we immediately push \texttt{data_here}.  Then
%   build \cs{l_@@_tmpa_tl} containing the delimiter, and call the
%   appropriate input functions to discard leading delimiters and grab
%   until the next occurrence of the delimiter.  The word found is
%   stored as \cs{l_@@_tmpb_tl}.  Then, after setting
%   \texttt{data_word}, which will index the word as we store it, to
%   \texttt{data_here}, we go through the string, storing its character
%   codes at positions starting from \(1 + \text{\texttt{data_here}}\).
%   Eventually, put the length, obtained by simple subtraction, in the
%   \texttt{data_here} address.  The final increment takes care of
%   placing \texttt{data_word} just after the end of the word.
%    \begin{macrocode}
\@@_forth_new_core:nn { WORD }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:n { \l_@@_forth_data_here_int }
    \@@_forth_input_discard:n { \l_@@_tmpa_int }
    \@@_forth_input_until:n { \l_@@_tmpa_int }
    \int_set_eq:NN \l_@@_forth_data_word_int
      \l_@@_forth_data_here_int
    \tl_set_eq:NN \l_@@_tmpb_tl \l_@@_forth_input_word_str
    \tl_replace_all:Nnn \l_@@_tmpb_tl { ~ } { \  }
    \tl_map_inline:Nn \l_@@_tmpb_tl
      {
        \int_incr:N \l_@@_forth_data_word_int
        \@@_forth_data_gset:nn
          { \l_@@_forth_data_word_int } { `#1 }
      }
    \@@_forth_data_gset:nn
      { \l_@@_forth_data_here_int }
      { \l_@@_forth_data_word_int - \l_@@_forth_data_here_int }
    \int_incr:N \l_@@_forth_data_word_int
    \int_compare:nNnT
      \l_@@_forth_data_word_int > \l_@@_forth_data_text_int
      { \msg_error:nn { runner/forth } { out-of-memory } }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Number conversion}
%
% ^^A todo: improve error catching.
% \begin{macro}[int]+<#+
%   A little bit of care is needed on the \TeX{} side, since |#| is
%   special there.  Initiate the pictured numeric output by emptying it
%   (simply move the \texttt{here} pointer).
%    \begin{macrocode}
\exp_args:Nx \@@_forth_new_core:nn { < \iow_char:N \# }
  {
    \int_set_eq:NN \l_@@_forth_picnum_here_int
      \g_@@_forth_picnum_max_int
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]+#>+
%   End the pictured numeric output by storing the sequence as a string
%   in the text literal
%    \begin{macrocode}
\exp_args:Nx \@@_forth_new_core:nn { \iow_char:N \# > }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push:n { \l_@@_forth_picnum_here_int }
    \@@_forth_push:n
      {
        \g_@@_forth_picnum_max_int
        - \l_@@_forth_picnum_here_int
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]+#+
% \begin{macro}[int]+#S+
% \begin{macro}[aux]{\@@_forth_picnum_aux:}
%   First we describe how |#| operates.  Pop a double-cell unsigned
%   integer \((c,d)\).  Store the base as \(b\).  Split \(d = b q_d +
%   r_d\).  Set \(c' = c + r_d\), and split it: \(c' = r_d + c = b q_c +
%   r_c\).  Store \(|`0| + r_c\) to the beginning of the pictured
%   numeric buffer.  Set \((c,d)\) equal to \((q_c, q_d)\).  Push that
%   to the stack.  The |#S| word is similar, repeating the conversion
%   until both \(c\) and \(d\) are zero.
%    \begin{macrocode}
\exp_args:Nx \@@_forth_new_core:nn { \iow_char:N \# }
  {
    \@@_forth_pop_int:NN \l_@@_tmpc_int \l_@@_tmpd_int
    \int_set:Nn \l_@@_tmpb_int { \@@_forth_base: }
    \@@_forth_picnum_aux:
    \@@_forth_push:nn { \l_@@_tmpc_int } { \l_@@_tmpd_int }
  }
\exp_args:Nx \@@_forth_new_core:nn { \iow_char:N \# S }
  {
    \@@_forth_pop_int:NN \l_@@_tmpc_int \l_@@_tmpd_int
    \int_set:Nn \l_@@_tmpb_int { \@@_forth_base: }
    \int_while_do:nNnn
      { \l_@@_tmpc_int + \l_@@_tmpd_int } > \c_zero
      { \@@_forth_picnum_aux: }
    \@@_forth_push:nn { \l_@@_tmpc_int } { \l_@@_tmpd_int }
  }
\cs_new_protected_nopar:Npn \@@_forth_picnum_aux:
  {
    \int_add:Nn \l_@@_tmpc_int
      {
        \int_mod:nn { \l_@@_tmpd_int } { \l_@@_tmpb_int }
        * \c_@@_forth_mod_int
      }
    \int_decr:N \l_@@_forth_picnum_here_int
    \@@_array_gset:Nnn \g_@@_forth_array
      { \l_@@_forth_picnum_here_int }
      { `0 + \int_mod:nn { \l_@@_tmpc_int } { \l_@@_tmpb_int } }
    \int_set:Nn \l_@@_tmpc_int
      { \int_div_truncate:nn { \l_@@_tmpc_int } { \l_@@_tmpb_int } }
    \int_set:Nn \l_@@_tmpd_int
      { \int_div_truncate:nn { \l_@@_tmpd_int } { \l_@@_tmpb_int } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{HOLD}
%   Pop \(a\) from the stack, and put it at the start of the pictured
%   numeric buffer.
%    \begin{macrocode}
\@@_forth_new_core:nn { HOLD }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \int_decr:N \l_@@_forth_picnum_here_int
    \@@_array_gset:Nnn \g_@@_forth_array
      { \l_@@_forth_picnum_here_int } { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{SIGN}
%   Pop a signed \(a\) from the stack.  If it is negative, prepend |-|
%   to the pictured numeric output.
%    \begin{macrocode}
\@@_forth_new_core:nn { SIGN }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \int_compare:nNnT
      { \@@_forth_signed:N \l_@@_tmpa_int } < \c_zero
      {
        \int_decr:N \l_@@_forth_picnum_here_int
        \@@_array_gset:Nnn \g_@@_forth_array
          { \l_@@_forth_picnum_here_int } { `- }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{>NUMBER}
% \begin{macro}[aux]{\@@_forth_to_number_aux:n}
%   See also \cs{@@_forth_get_number:nNTF}.  Get a double cell integer
%   \((a,b)\), an address \(c\) and a length \(d\).  Set \(d\) to the
%   last address in the string (plus~\(1\)).  Store the base as the
%   \texttt{tmpb} token list.  Then loop through the string, until the
%   end is reached.  It turns out that one can safely jump outside the
%   loop with a \cs{@@_break:n} \ldots{} \cs{@@_break_point:n}
%   construction (because \cs{int_while_do:nNnn} is expandable, hence
%   side-effect free).  For each character, store the character code
%   into the \texttt{tmpa} token list to avoid fetching it multiple
%   times; if it fits among the \([0,9]\) digits allowed in the base,
%   update the integers \((a,b)\) using the value \texttt{tmpa} minus
%   the character code of~|0|; if it fits among the allowed alphabetic
%   characters, update the integers \((a,b)\) using the appropriate
%   value for that digit.  Updating is done by an auxiliary, which
%   multiplies \(a\) by the base, adding the argument~|#1|, multiplies
%   \(b\) by the base, adding the carry from \(a\), and subtracts the
%   carry from \(a\).
%    \begin{macrocode}
\@@_forth_new_core:nn { >NUMBER }
  {
    \@@_forth_pop_int:NNNN
      \l_@@_tmpa_int \l_@@_tmpb_int
      \l_@@_tmpc_int \l_@@_tmpd_int
    \int_add:Nn \l_@@_tmpd_int { \l_@@_tmpc_int }
    \tl_set:Nx \l_@@_tmpb_tl { \@@_forth_base: }
    \int_while_do:nNnn \l_@@_tmpc_int < \l_@@_tmpd_int
      {
        \tl_set:Nx \l_@@_tmpa_tl
          { \@@_forth_data_get:n { \l_@@_tmpc_int } }
        \int_compare:nTF
          { `0 <= \l_@@_tmpa_tl < `0 + \l_@@_tmpb_tl }
          { \@@_forth_to_number_aux:n { \l_@@_tmpa_tl - `0 } }
          {
            \int_compare:nTF
              { `A <= \l_@@_tmpa_tl < `A + \l_@@_tmpb_tl - 10 }
              { \@@_forth_to_number_aux:n { \l_@@_tmpa_tl - `A + 10 } }
              { \@@_break:n { } }
          }
        \int_incr:N \l_@@_tmpc_int
      }
    \@@_break_point:n { }
    \@@_forth_push:nnnn
      { \l_@@_tmpa_int } { \l_@@_tmpb_int }
      { \l_@@_tmpc_int } { \l_@@_tmpd_int - \l_@@_tmpc_int }
  }
\cs_new_protected:Npn \@@_forth_to_number_aux:n #1
  {
    \int_set:Nn \l_@@_tmpa_int
      {
        \l_@@_tmpb_tl * \l_@@_tmpa_int
        + #1
      }
    \int_set:Nn \l_@@_tmpb_int
      {
        \l_@@_tmpb_tl * \l_@@_tmpb_int
        + \int_div_truncate:nn
          { \l_@@_tmpa_int } { \c_@@_forth_mod_int }
      }
    \int_set:Nn \l_@@_tmpa_int
      { \int_mod:nn { \l_@@_tmpa_int } { \c_@@_forth_mod_int } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Conditional words}
%
% \begin{macro}[int]{IF}
%   Save the definition-so-far in the \texttt{def} stack, and empty that
%   variable.  Then continue collecting: the |THEN| word will take care
%   of combining what is collected now with the definition-so-far saved
%   on the \texttt{def} stack.  For subsequent control-flow words to
%   know what happened, push \(1\) onto the control-flow stack.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { IF }
  {
    \seq_push:NV \l_@@_forth_def_seq \l_@@_forth_def_code_tl
    \tl_clear:N \l_@@_forth_def_code_tl
    \@@_forth_control_open:n { 1 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{ELSE}
%   The word |ELSE| can only be used if the last control flow word was
%   |IF|.  Stash away the definition code of the \texttt{true} branch
%   that was just collected, and empty the \texttt{def_code} variable to
%   be ready for the \texttt{false} branch.  Then push \(2\) on the
%   stack to indicate the presence of a dangling |ELSE|.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { ELSE }
  {
    \@@_forth_control_close:nTF { 1 }
      {
        \seq_push:NV \l_@@_forth_def_seq \l_@@_forth_def_code_tl
        \tl_clear:N \l_@@_forth_def_code_tl
        \@@_forth_control_open:n { 2 }
      }
      { \msg_error:nnn { runner/forth } { misplaced } { ELSE } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{THEN}
% \begin{macro}[aux]{\@@_forth_compile_then:nn}
%   The auxiliary restores the definition code to what it was before the
%   matching |IF|, then appends to it \cs{@@_forth_compiled_if:TF}
%   followed by the codes for the \texttt{true} branch and the
%   \texttt{false} branch.  After an |IF| with no |ELSE| (magic number
%   \(1\)), the \texttt{true} branch is in \texttt{def_code}, and the
%   \texttt{false} branch is empty.  After an \texttt{ELSE} (magic
%   number \(2\)), the \texttt{false} branch is in \texttt{def_code},
%   and the \texttt{true} branch is on the \texttt{def} stack.  Any
%   other circumstance means that |THEN| does not belong there.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { THEN }
  {
    \@@_forth_control_close:nTF { 1 }
      {
        \exp_args:NV \@@_forth_compile_then:nn
          \l_@@_forth_def_code_tl { }
      }
      {
        \@@_forth_control_close:nTF { 2 }
          {
            \seq_pop:NN \l_@@_forth_def_seq \l_@@_tmpa_tl
            \exp_args:NVV \@@_forth_compile_then:nn
              \l_@@_tmpa_tl \l_@@_forth_def_code_tl
          }
          { \msg_error:nnn { runner/forth } { misplaced } { THEN } }
      }
  }
\cs_new_protected:Npn \@@_forth_compile_then:nn #1#2
  {
    \seq_pop:NN \l_@@_forth_def_seq \l_@@_forth_def_code_tl
    \@@_forth_def_code:x
      { \@@_forth_compiled_if:TF {#1} {#2} }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int, TF]{\@@_forth_compiled_if:}
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \@@_forth_compiled_if: { TF }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \int_compare:nNnTF \l_@@_tmpa_int = \c_zero
      { \prg_return_false: } { \prg_return_true: }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Do-loop words}
%
% \begin{variable}{\l_@@_forth_loop_bool}
%    \begin{macrocode}
\bool_new:N \l_@@_forth_loop_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{DO}
%   Save the definition-so-far, and empty the variable, then push to the
%   control-flow stack a flag indicating that a |DO| is unresolved
%   (magic number \(3\)).
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { DO }
  {
    \seq_push:NV \l_@@_forth_def_seq \l_@@_forth_def_code_tl
    \tl_clear:N \l_@@_forth_def_code_tl
    \@@_forth_control_open:n { 3 }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: redoc
% \begin{macro}[int]{LOOP, +LOOP}
% \begin{macro}[aux]{\@@_forth_compile_loop:n}
%   Save the code of the loop body as \texttt{tmpa}, then restore the
%   definition as it was before the matching |DO|.  Finally, append to
%   the definition \cs{@@_forth_compiled_do:nn}, with the loop body as
%   its first argument, and incrementing the loop counter as its second.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { LOOP }
  {
    \@@_forth_compile_loop:n
      { \int_set:Nn \l_@@_tmpc_int { \l_@@_tmpb_int + 1 } }
  }
\@@_forth_new_compilation_core:nn { +LOOP }
  {
    \@@_forth_compile_loop:n
      {
        \@@_forth_pop_int:N \l_@@_tmpd_int
        \int_set:Nn \l_@@_tmpc_int
          { \l_@@_tmpb_int + \l_@@_tmpd_int }
      }
  }
\cs_new_protected:Npn \@@_forth_compile_loop:n #1
  {
    \@@_forth_control_close:nTF { 3 }
      {
        \tl_set_eq:NN \l_@@_tmpa_tl \l_@@_forth_def_code_tl
        \seq_pop:NN \l_@@_forth_def_seq \l_@@_forth_def_code_tl
        \@@_forth_def_code:x
          { \@@_forth_compiled_do:nn { \l_@@_tmpa_tl } {#1} }
      }
      { \msg_error:nnn { runner/forth } { misplaced } { LOOP } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% ^^A todo: optimize
% ^^A todo: now, this fails for i=-1, lim=0.
% ^^A todo: bug, with overflow of negative numbers.
% \begin{macro}[int]{\@@_forth_compiled_do:nn}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_compiled_do:nn #1#2
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_return_push:n { \l_@@_tmpa_int } % ^^A limit
    \@@_forth_return_push:n { \l_@@_tmpb_int } % ^^A index
    \bool_set_true:N \l_@@_forth_loop_bool
    \bool_do_while:Nn \l_@@_forth_loop_bool
      {
        #1
        \@@_forth_return_pop_int:N \l_@@_tmpb_int
        \@@_forth_return_pop_int:N \l_@@_tmpa_int
        #2
        \int_compare:nNnTF \l_@@_tmpb_int < \l_@@_tmpa_int
          { \int_compare:nNnF }
          { \int_compare:nNnT }
              \l_@@_tmpc_int < \l_@@_tmpa_int
              { \bool_set_false:N \l_@@_forth_loop_bool }
        \@@_forth_return_push:n { \l_@@_tmpa_int }
        \@@_forth_return_push:n { \l_@@_tmpc_int }
      }
    \@@_break_point:n
      {
        \@@_forth_return_pop_int:N \l_@@_tmpb_int
        \@@_forth_return_pop_int:N \l_@@_tmpa_int
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{I, J}
% \begin{macro}[aux]{\@@_forth_ij:N}
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { I }
  { \@@_forth_def_code:x { \@@_forth_ij:N 1 } }
\@@_forth_new_compilation_core:nn { J }
  { \@@_forth_def_code:x { \@@_forth_ij:N 3 } }
\cs_new_protected:Npn \@@_forth_ij:N #1
  {
    \@@_forth_push:n
      {
        \@@_array_item:Nn \g_@@_forth_array
          { \l_@@_forth_return_here_int - #1 }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{LEAVE}
%   Break the current loop, which takes care of removing the loop
%   control parameters from the return stack.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { LEAVE }
  { \@@_forth_def_code:x { \@@_break_protected:n { } } }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: doc that UNLOOP is allowed in interpretation mode.
% \begin{macro}[int]{UNLOOP}
%   Drop the loop control parameters from the return stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { UNLOOP }
  {
    \@@_forth_return_pop_int:N \l_@@_tmpa_int
    \@@_forth_return_pop_int:N \l_@@_tmpb_int
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Begin-loop words}
%
% \begin{macro}[int]{BEGIN}
%   Similar to |IF|.  Save the definition-so-far in the \texttt{def}
%   stack, and empty that variable.  Push the magic number \(4\) onto
%   the control flow stack.  The |UNTIL| word (or |WHILE| and |REPEAT|)
%   will take care of combining the two pieces of code.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { BEGIN }
  {
    \seq_push:NV \l_@@_forth_def_seq \l_@@_forth_def_code_tl
    \tl_clear:N \l_@@_forth_def_code_tl
    \@@_forth_control_open:n { 4 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{UNTIL}
% \begin{macro}[aux]{\@@_forth_compiled_until:n}
%   This must follow |BEGIN| (magic number \(4\)).  Save the code of the
%   loop body as \texttt{tmpa}, and restore the previous
%   \texttt{def_code}, then append \cs{@@_forth_compiled_until:n} with
%   the loop body code as its argument.  At run-time, this function runs
%   its argument, then pops the data stack: if that is zero, repeat,
%   otherwise, stop.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { UNTIL }
  {
    \@@_forth_control_close:nTF { 4 }
      {
        \tl_set_eq:NN \l_@@_tmpa_tl \l_@@_forth_def_code_tl
        \seq_pop:NN \l_@@_forth_def_seq \l_@@_forth_def_code_tl
        \@@_forth_def_code:x
          { \@@_forth_compiled_until:n { \l_@@_tmpa_tl } }
      }
      { \msg_error:nnn { runner/forth } { misplaced } { UNTIL } }
  }
\cs_new_protected:Npn \@@_forth_compiled_until:n #1
  {
    \int_do_while:nNnn \l_@@_tmpa_int = \c_zero
      {
        #1
        \@@_forth_pop_int:N \l_@@_tmpa_int
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{WHILE, REPEAT}
% \begin{macro}[aux]{\@@_forth_compiled_repeat:nn}
%   |WHILE| must follow |BEGIN| (magic number \(5\)).  Store the first
%   part of the loop body in the \texttt{def} sequence.  |REPEAT| must
%   follow |WHILE| (magic number \(4\)).  The loop body code is in
%   \texttt{tmpa} (pre-|WHILE|) and \texttt{tmpb} (post-|WHILE|), and we
%   insert \cs{@@_forth_compiled_repeat:nn} into the definition started
%   before |BEGIN|.  At run-time, perform the first part of the loop;
%   pop a value; if false, stop, otherwise, perform the second part of
%   the loop; repeat.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { WHILE }
  {
    \@@_forth_control_close:nTF { 4 }
      {
        \seq_push:NV \l_@@_forth_def_seq \l_@@_forth_def_code_tl
        \tl_clear:N \l_@@_forth_def_code_tl
        \@@_forth_control_open:n { 5 }
      }
      { \msg_error:nnn { runner/forth } { misplaced } { WHILE } }
  }
\@@_forth_new_compilation_core:nn { REPEAT }
  {
    \@@_forth_control_close:nTF { 5 }
      {
        \tl_set_eq:NN \l_@@_tmpb_tl \l_@@_forth_def_code_tl
        \seq_pop:NN \l_@@_forth_def_seq \l_@@_tmpa_tl
        \seq_pop:NN \l_@@_forth_def_seq \l_@@_forth_def_code_tl
        \@@_forth_def_code:x
          {
            \@@_forth_compiled_repeat:nn
              { \l_@@_tmpa_tl } { \l_@@_tmpb_tl }
          }
      }
      { \msg_error:nnn { runner/forth } { misplaced } { REPEAT } }
  }
\cs_new_protected:Npn \@@_forth_compiled_repeat:nn #1#2
  {
    #1
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \int_compare:nNnF \l_@@_tmpa_int = \c_zero
      {
        #2
        \@@_forth_compiled_repeat:nn {#1} {#2}
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Ending words}
%
% ^^A todo: doc that EXIT is allowed in interpretation mode.
% \begin{macro}[int]{EXIT}
%   Leave the current definition.  See \cs{@@_forth_exit:} and
%   \cs{@@_forth_exit_point:}.  The \cs{use_i:nn} is a bit of a hack, to
%   remove the \texttt{exit_point} that is inserted after the code of
%   |EXIT| itself.
%    \begin{macrocode}
\@@_forth_new_core:nn { EXIT } { \use_i:nn \@@_forth_exit: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{QUIT, ABORT}
% \begin{macro}[aux]{\@@_forth_do_quit:}
%   Empty the return stack and enter interpretation state, then flush
%   all code being run, by jumping to the \texttt{quit_point}.  |ABORT|
%   additionally empties the data stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { QUIT } { \@@_forth_do_quit: }
\@@_forth_new_core:nn { ABORT }
  {
    \int_set_eq:NN \l_@@_forth_stack_here_int
      \g_@@_forth_stack_min_int
    \@@_forth_do_quit:
  }
\cs_new_protected_nopar:Npn \@@_forth_do_quit:
  {
    \int_set_eq:NN \l_@@_forth_return_here_int
      \g_@@_forth_return_min_int
    \@@_forth_data_gset:nn
      { \l_@@_forth_state_address_int } { 0 }
    \cs_set_eq:NN \@@_forth_perform:n \@@_forth_interpret:n
    \@@_forth_quit:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]+ABORT"+
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { ABORT" }
  {
    \@@_forth_input_until:n { `" }
    \@@_forth_def_code:x
      { \@@_forth_abort_quote:n { \l_@@_forth_input_word_str } }
  }
\cs_new_protected:Npn \@@_forth_abort_quote:n #1
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \int_compare:nNnF \l_@@_tmpa_int = \c_zero
      {
        \msg_term:n { ABORT~( \int_use:N \l_@@_tmpa_int ): ~ #1 }
        \int_set_eq:NN \l_@@_forth_stack_here_int
          \g_@@_forth_stack_min_int
        \@@_forth_do_quit:
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Environmental variables}
%
% \begin{macro}[int]{BASE}
%   Push the address where the base is stored.
%    \begin{macrocode}
\@@_forth_new_core:nn { BASE }
  { \@@_forth_push:n { \l_@@_forth_base_address_int } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{>IN}
%   Push the address where the input buffer offset is stored.
%    \begin{macrocode}
\@@_forth_new_core:nn { >IN }
  { \@@_forth_push:n { \l_@@_forth_in_address_int } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{SOURCE}
%   Push the address of the current input buffer, and the length of the
%   string stored there.
%    \begin{macrocode}
\@@_forth_new_core:nn { SOURCE }
  {
    \@@_forth_push:n { \l_@@_forth_source_begin_int }
    \@@_forth_push:n
      { \l_@@_forth_source_end_int - \g_@@_forth_source_min_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{STATE}
%   Push the address where the state is stored.
%    \begin{macrocode}
\@@_forth_new_core:nn { STATE }
  { \@@_forth_push:n { \l_@@_forth_state_address_int } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{ENVIRONMENT?}
% \begin{macro}[aux]{\@@_forth_environment_aux:n}
%   Pop an address \(a\) and a length \(b\) from the stack, and extract
%   a comma-list of the values from \(a\) to \(a + b - 1\) inclusive
%   (the query string).  If that string matches any known one, return
%   the result and a true flag, otherwise return a false flag.
%    \begin{macrocode}
\@@_forth_new_core:nn { ENVIRONMENT? }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \prop_get:NxNTF \g_@@_forth_environment_prop
      {
        \int_step_function:nnnN
          { \l_@@_tmpa_int }
          { 1 }
          { \l_@@_tmpa_int + \l_@@_tmpb_int - 1 }
          \@@_forth_environment_aux:n
      }
      \l_@@_tmpa_tl
      {
        \l_@@_tmpa_tl
        \@@_forth_push_true:
      }
      {
        \@@_forth_push_false:
      }
  }
\cs_new:Npn \@@_forth_environment_aux:n #1
  { \@@_forth_data_get:n {#1} , }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{variable}{\g_@@_forth_environment_prop}
% \begin{macro}{\@@_forth_environment_def:nn}
%   Keys are known string, in the form of comma lists of their character
%   codes.  Currently, the following exist:
%   \begin{itemize}
%   \item ADDRESS-UNIT-BITS: 24
%   \item CORE: false
%   \item CORE-EXT: false
%   \item FLOORED: false
%   \item MAX-D: 8388607 and 16777215
%   \item MAX-N: 8388607
%   \item MAX-U: 16777215
%   \item MAX-UD: 16777215 and 16777215.
%   \end{itemize}
%   Values are the code that pushes the appropriate values to the stack.
%    \begin{macrocode}
\prop_new:N \g_@@_forth_environment_prop
\group_begin:
  \cs_set_protected:Npn \@@_forth_environment_def:nn #1#2
    {
      \prop_gput:Nxn \g_@@_forth_environment_prop
        { \tl_map_function:nN {#1} \@@_tmp:w }
        {#2}
    }
  \cs_set:Npn \@@_tmp:w #1 { \int_eval:n { `#1 } , }
  \@@_forth_environment_def:nn { ADDRESS-UNIT-BITS }
    { \@@_forth_push:n { 24 } }
  \@@_forth_environment_def:nn { CORE }
    { \@@_forth_push_false: }
  \@@_forth_environment_def:nn { CORE-EXT }
    { \@@_forth_push_false: }
  \@@_forth_environment_def:nn { FLOORED }
    { \@@_forth_push_false: }
  \@@_forth_environment_def:nn { MAX-D }
    {
      \@@_forth_push:n { 16777215 }
      \@@_forth_push:n { 8388607 }
    }
  \@@_forth_environment_def:nn { MAX-N }
    { \@@_forth_push:n { 8388607 } }
  \@@_forth_environment_def:nn { MAX-U }
    { \@@_forth_push:n { 16777215 } }
  \@@_forth_environment_def:nn { MAX-UD }
    {
      \@@_forth_push:n { 16777215 }
      \@@_forth_push:n { 16777215 }
    }
  \@@_forth_environment_def:nn { /HOLD }
    {
      \@@_forth_push:n
        { \g_@@_forth_picnum_max_int - \g_@@_forth_picnum_min_int }
    }
  \@@_forth_environment_def:nn { /PAD }
    {
      \@@_forth_push:n
        { \g_@@_forth_pad_max_int - \g_@@_forth_pad_min_int }
    }
  \@@_forth_environment_def:nn { RETURN-STACK-CELLS }
    {
      \@@_forth_push:n
        { \g_@@_forth_return_max_int - \g_@@_forth_return_min_int }
    }
  \@@_forth_environment_def:nn { STACK-CELLS }
    {
      \@@_forth_push:n
        { \g_@@_forth_stack_max_int - \g_@@_forth_stack_min_int }
    }
\group_end:
%    \end{macrocode}
% \end{macro}
% \end{variable}
%
% \subsubsection{Misc words}
%
% \begin{macro}[int]{(}%^^A)
%   Comments are implemented by grabbing a piece of input delimited by a
%   right parenthesis, and not doing anything with it.  This is an
%   immediate word.
%    \begin{macrocode}
\@@_forth_new_immediate_core:nn (
  { \@@_forth_input_until:n { `) } }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Additionnal words}
%
% \begin{macro}[int]{STOP}
%   Set the \texttt{forth_stop} boolean to stop the interpreter loop.
%   Perform the action of |ABORT|.
%    \begin{macrocode}
\@@_forth_new_core:nn { STOP }
  {
    \bool_set_true:N \l_@@_forth_stop_bool
    \int_set_eq:NN \l_@@_forth_stack_here_int
      \g_@@_forth_stack_min_int
    \@@_forth_do_quit:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Running the interpreter}
%
% \begin{macro}[int]{\@@_forth_run:}
% \begin{macro}[aux]{\@@_forth_run_aux:TF}
%   The interpreter is an infinite loop retrieving a word at each
%   iteration.  If the \texttt{input_word} is empty (end of line),
%   refill the input buffer.  When there is nothing left, set the
%   \texttt{forth_stop} boolean, to stop the loop.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_run:
  {
    \@@_forth_init:
    \bool_set_false:N \l_@@_forth_stop_bool
    \bool_until_do:Nn \l_@@_forth_stop_bool
      {
        \@@_forth_run_aux:TF
          { \@@_forth_perform:V \l_@@_forth_input_word_str }
          { \bool_set_true:N \l_@@_forth_stop_bool }
        \@@_forth_quit_point:
      }
  }
\cs_new_protected_nopar:Npn \@@_forth_run_aux:TF
  {
    \@@_forth_input_word:
    \tl_if_empty:NTF \l_@@_forth_input_word_str
      {
        \@@_forth_input_refill:TF
          { \@@_forth_run_aux:TF }
          { \use_ii:nn }
      }
      { \use_i:nn }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% ^^A todo: normalize newlines?
% \begin{macro}[int]{\@@_forth_init:}
%   Initialize the data space.  Initialize the code space.  Initialize
%   the name space.  Store a |BASE| of \(10\) and a |STATE| flag of
%   \texttt{false} (0), starting interpretation.  Concatenate the
%   program string and the input string, with a newline in between and
%   at the end.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_init:
  {
    \tl_set:Nn \l_@@_prompt_tl { ok ~ }
    \@@_forth_init_data:
    \tl_use:N \g_@@_forth_init_toks_tl
    \int_set_eq:NN
      \l_@@_forth_toks_int
      \g_@@_forth_core_toks_int
    \prop_set_eq:NN
      \l_@@_forth_words_prop
      \g_@@_forth_core_words_prop
    \int_set_eq:NN \l_@@_forth_base_address_int
      \l_@@_forth_data_here_int
    \@@_forth_put_here:n { 10 }
    \int_set_eq:NN \l_@@_forth_state_address_int
      \l_@@_forth_data_here_int
    \@@_forth_put_here:n { 0 }
    \int_set_eq:NN \l_@@_forth_in_address_int
      \l_@@_forth_data_here_int
    \@@_forth_put_here:n { 0 }
    \cs_set_eq:NN \@@_forth_perform:n \@@_forth_interpret:n
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_interpret:n}
%   Use the interpretation semantics of |#1|.  If this fails, we hope to
%   have a number, which should be parsed as such.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_interpret:n #1
  {
    \prop_get:NnNTF \l_@@_forth_words_prop {#1} \l_@@_tmpa_tl
      { \@@_forth_execute:n { \tl_tail:N \l_@@_tmpa_tl } }
      {
        \@@_forth_get_number:nNTF {#1} \l_@@_tmpa_tl
          { \@@_forth_push:n { \l_@@_tmpa_tl } }
          { \msg_error:nnn { runner/forth } { unknown-word } {#1} }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_compile:n}
% \begin{macro}[aux]{\@@_forth_compile:Nw}
%   This is very similar to \cs{@@_forth_interpret:n}.  Try to find the
%   word in the dictionary.  If it is present, split its value into \(1
%   + 5\) digits: if the first is \(1\), simply add to the current
%   definition; if the first is \(2\) perform the execution semantics,
%   and if it is \(3\), the word is a special word, and we perform the
%   compilation semantics.  Otherwise, we try to interpret the word as a
%   number.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_compile:n #1
  {
    \prop_get:NnNTF \l_@@_forth_words_prop {#1} \l_@@_tmpa_tl
      { \exp_after:wN \@@_forth_compile:Nw \l_@@_tmpa_tl \q_stop }
      {
        \@@_forth_get_number:nNTF {#1} \l_@@_tmpa_tl
          {
            \@@_forth_def_code:x
              { \@@_forth_push:n { \l_@@_tmpa_tl } }
          }
          { \msg_error:nnn { runner/forth } { unknown-word } {#1} }
      }
  }
\cs_new_protected:Npn \@@_forth_compile:Nw #1#2 \q_stop
  {
    \int_case:nnn {#1}
      {
        { 1 } { \@@_forth_def_code:x { \@@_forth_execute:n {#2} } }
        { 2 } { \@@_forth_execute:n {#2} }
      }
      { \@@_forth_execute:n { \int_eval:n { #2 + 1 } } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_perform:n, \@@_forth_perform:V}
%    \begin{macrocode}
\cs_new_eq:NN \@@_forth_perform:n ?
\cs_generate_variant:Nn \@@_forth_perform:n { V }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Messages}
%
% ^^A todo: add details of the pictured numeric output, the terminal
% ^^A input buffer, the source buffer, \etc.
% \begin{macro}[int, EXP]{\@@_forth_footprint:}
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_forth_footprint:
  {
    Summary~of~memory~use.\\\\
    Input~buffer: \
      \int_use:N \l_@@_forth_source_begin_int \ to \
      \int_use:N \l_@@_forth_source_end_int . \\
    Pad: \
      \int_use:N \g_@@_forth_pad_min_int \ to \
      \int_use:N \g_@@_forth_pad_max_int .\\
    Data:
      \int_use:N \g_@@_forth_data_min_int \ to \
      \int_use:N \g_@@_forth_data_max_int , \ split\ as \\
    \iow_indent:n
      {
        \int_eval:n
          { \l_@@_forth_data_here_int - \g_@@_forth_data_min_int }
        \ cells\ of\ variables\ and\ allotted\ data, \\
        \int_compare:nTF
          {
            \l_@@_forth_data_here_int
            <= \l_@@_forth_data_word_int
            <= \l_@@_forth_data_text_int
          }
          {
            \int_eval:n
              {
                \l_@@_forth_data_word_int
                - \l_@@_forth_data_text_int
              }
            \ cells\ for\ WORD\ or\ \#>\ .\\
            \int_eval:n
              {
                \l_@@_forth_data_text_int
                - \l_@@_forth_data_word_int
              }
            \ unassigned\ cells. \\
          }
          {
            \int_eval:n
              {
                \l_@@_forth_data_text_int
                - \l_@@_forth_data_here_int
              }
            \ unassigned\ cells. \\
          }
        \int_eval:n
          { \g_@@_forth_data_max_int - \l_@@_forth_data_text_int }
        \ cells\ for\ literal\ text. \\
      }
    Stack: \
      \int_use:N \g_@@_forth_stack_min_int \ to \
      \int_use:N \g_@@_forth_stack_max_int , \
      \int_eval:n
        { \l_@@_forth_stack_here_int - \g_@@_forth_stack_min_int }
      \ out\ of\
      \int_eval:n
        { \g_@@_forth_stack_max_int - \g_@@_forth_stack_min_int }
      \ occupied.
    \\
    Return stack: \
      \int_use:N \g_@@_forth_return_min_int \ to \
      \int_use:N \g_@@_forth_return_max_int , \
      \int_eval:n
        { \l_@@_forth_return_here_int - \g_@@_forth_return_min_int }
      \ out\ of\
      \int_eval:n
        { \g_@@_forth_return_max_int - \g_@@_forth_return_min_int }
      \ occupied.
    \\
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\msg_new:nnn { runner/forth } { unknown-word }
  { The~word~'#1'~is~not~defined. }
\msg_new:nnn { runner/forth } { empty-stack }
  { The~data~stack~is~empty,~and~there~is~nothing~to~retrieve~there. }
\msg_new:nnn { runner/forth } { empty-return-stack }
  { The~return~stack~is~empty,~and~there~is~nothing~to~retrieve~there. }
\msg_new:nnnn { runner/forth } { out-of-memory }
  { The~Forth~interpreter~ran~out~of~memory. }
  { \@@_forth_footprint: }
\msg_new:nnn { runner/forth } { out-of-bounds }
  { ALLOT~was~called~with~a~negative~argument~that~made~HERE~=~#1. }
\msg_new:nnn { runner/forth } { no-interpretation }
  { The~word~#1~can~only~be~used~in~definitions. }
\msg_new:nnn { runner/forth } { no-def-immediate }
  { Somehow~the~word~#1~cannot~be~found~in~the~dictionary }
\msg_new:nnn { runner/forth } { misplaced }
  { Misplaced~#1. }
\msg_new:nnn { runner/forth } { internal }
  { Internal~error.~Please~report. }
%    \end{macrocode}
%
% \end{runner-implementation}
% \endinput