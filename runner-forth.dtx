% \iffalse
%% File: runner-forth.dtx Copyright (C) 2013 Bruno Le Floch
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% -----------------------------------------------------------------------
% \fi
%
% \begin{runner-documentation}
%
% \newcommand{\kw}[1]{\texttt{#1}}
%
% \section{The \plang{forth} language}
%
% ^^A todo: make ACCEPT unavailable in non-interactive mode.
%
% In interactive mode, invoked as |\runner{forth}[interactive]''''|,
% this \plang{forth} interpreter is a Standard System Subset, as defined
% by the ANS Forth 1994 specification, providing the majority of the
% Core and Core Extensions word sets, as well as the Double-Number and
% Double-Number Extensions word sets, with the following exceptions.
% \begin{itemize}
% \item The core word |KEY| is not implemented.
% \item The core extension words |EXPECT|, |QUERY|, |RESTORE-INPUT|,
%   |SAVE-INPUT|, |SPAN| are not implemented.\footnote{Some of those
%     words, and others are marked by the ANS 1994 standard as
%     obsolescent, namely \texttt{\#TIB}, \texttt{TIB}, \texttt{EXPECT},
%     \texttt{QUERY}, \texttt{SPAN}, \texttt{CONVERT}, \texttt{FORGET}.}
% \item The environment variable |/COUNTED-STRING| is not recognized.
% \end{itemize}
% Additionally, the interpreter provides the Programming-Tools words
% |.S|, |?|, |DUMP|, |[IF]|, |[THEN]|, |[ELSE]|, |BYE|.
%
% ^^A The words |SEE|, |WORDS|, |;CODE|, |AHEAD|, |ASSEMBLER|, |CODE|,
% ^^A |CS-PICK|, |CS-ROLL|, |EDITOR|, |FORGET|, are not implemented.
%
% In non-interactive mode (common case within a \TeX{} document), the
% system reads \plang{forth} code and input from files, or obtains them
% from \TeX{}, hence it has no prompt.  This mode is otherwise
% identical to interactive mode.
%
% Single-cell integers are \(24\) bits wide, as are characters.
% Double-cell integers are \(48\) bits wide.  More details on the
% implementation-defined behaviours and features can be found in
% section~\ref{seq:forth-details}.
%
% \subsection{Introduction to \plang{forth}}
%
% This is not the place for an introduction to Forth, many can be found
% online.  ^^A todo: add a bunch of refs
%
% For example, one can define the factorial function as follows.
% \begin{verbatim}
%   \runner{forth}[output = \result]|
%     : FACTORIAL ( +n1 -- +n2)
%     DUP 2 < IF DROP 1 EXIT THEN ( 0! = 1! = 1)
%     DUP 1- RECURSE * ; ( n1! = n1 * [n1 - 1]!)
%   ||
%   CR 0 FACTORIAL . ( prints 1)
%   CR 3 FACTORIAL . ( prints 6)
%   CR 24 FACTORIAL . ( prints -4194304)|
%   \typeout{\result}
% \end{verbatim}
% This types three lines to the terminal, containing \(1\), \(6\) and
% \(-4194304\).  The last number is incorrect, because the result
% overflows the size of a single-cell unsigned integer.  We can easily
% check that it is the correct result modulo \(2^{24}\).
%
% Most Forth words receive arguments from the data stack, and place
% their results back onto this stack.  The stack contents takes the form
% of \(24\)-bit cells, which can represent one of the following
% data-types, each of which is represented in the documentation below by
% a short-hand (we follow the notations of the ANS 1994 standard)
% \begin{itemize}
% \item[flag] a flag (true: \(-1\), false: \(0\)),
% \item[char] a character (in \([0,1114111]\), the range of Unicode code
%   points),
% \item[n] a signed number (in \([-2^{23},2^{23}-1]\)),
% \item[+n] a non-negative number (in \([0,2^{23}-1]\)),
% \item[u] an unsigned number (in \([0,2^{24}-1]\)),
% \item[xt] an execution token (which points to some \TeX{} code
%   implementing a Forth word),
% \item[addr] an address in memory (typically a small non-negative integer)
% \item[x] arbitrary cell data.
% \end{itemize}
% Pairs of cells are used by some words to manipulate integers larger
% than \(2^{24}\):
% \begin{itemize}
% \item[d] a double-cell signed number (in \([-2^{47},2^{47}-1]\)),
% \item[+d] a double-cell non-negative number (in \([0,2^{47}-1]\)),
% \item[ud] a double-cell unsigned number (in \([0,2^{48}-1]\)),
% \item[xd] arbitrary pair of cells
% \end{itemize}
% Additionally, some internal data-types are used for the implementation
% of control-flow words, namely colon-sys, do-sys, case-sys, of-sys,
% orig, dest, loop-sys, nest-sys.  Additionally, i*x is used to
% represent an arbitrary number of cells.
%
% \subsection{Words}
%
% ^^A todo: check which arguments are signed/unsigned.
% ^^A todo: document all words.
%
% Arithmetic operations take arguments from the stack and push their
% result back onto the stack.
% \begin{itemize}
% \item |ABS|, |NEGATE|, |1+| and |1-| are unary: |(n -- n')|.
% \item |MAX|, |MIN|, |-|, |+|, |*|, |/|, and |MOD| are binary: |(n1 n2 -- n)|
% \item |/MOD| has stack effect |(n1 n2 -- n3 n4)| where |n4| is the
%   quotient and |n3| the remainder.
% \item |*/| is ternary: |(n1 n2 n3 -- n)| where |n| is obtained from
%   |n1 * n2 / n3|.
% \item |M*|, |UM*| have stack effect |(n1 n2 -- d)| where the
%   double-cell integer |d| is |n1 * n2|.
% \item |FM/MOD|, |SM/REM|, |UM/MOD| do |(d n1 -- n2 n3)|, where |n3| is
%   the quotient, and |n2| the remainder, of |d/n1|.
% \item |*/MOD|
% \end{itemize}
%
% Bit operations take arguments from the stack and push their result
% back onto the stack.
% \begin{itemize}
% \item |2*| and |2/| shift the top of stack by one bit to the left/right.
% \item |D2/| and |D2*| shift the topmost double-cell by one bit.
% \item |INVERT| changes all bits of the top of stack.
% \item |AND|, |OR| and |XOR| are binary: |(n1 n2 -- n3)|.
% \item |LSHIFT| and |RSHIFT| have stack effect |(x1 u -- x2)|.
% \end{itemize}
%
% Case words: |CASE|, |OF|, |ENDOF|, |ENDCASE|.
%
% Comparisons take arguments from the stack and push flags (false:
% \(0\), true: \(-1\)) onto the stack.
% \begin{itemize}
% \item |FALSE|, |TRUE| always push \(0\), \(-1\).
% \item |0=| and |0<>| have stack effect |(x -- flag)|.
% \item |0<| and |0>| have stack effect |(n -- flag)|.
% \item |=| and |<>| have stack effect |(x1 x2 -- flag)|.
% \item |U<| and |U>| have stack effect |(u1 u2 -- flag)|.
% \item |<| and |>| have stack effect |(n1 n2 -- flag)|.
% \item |WITHIN| has stack effect |(n1 n2 n3 -- flag)|.
% \item |?DUP| duplicates the top-most cell if it is not zero.
% \item |D0=| and |D0<| have stack effect |(d -- flag)|
% \item |D=|, |D<|, |DMAX|, and |DMIN| have stack effect |(d1 d2 -- flag)|.
% \item |DU<|
% \end{itemize}
%
% Control-flow words: |IF|, |ELSE|, |THEN|, |BEGIN|, |AGAIN|, |UNTIL|,
% |WHILE|, |REPEAT|.
%
% Defining words: |CONSTANT|, |2CONSTANT|, |CREATE|, |VARIABLE|,
% |2VARIABLE|, |>BODY|, |VALUE|, |TO|, |:NONAME|, |:|, |DOES>|, |;|,
% |IMMEDIATE|, |LITERAL|, |2LITERAL|, |MARKER|, |POSTPONE|, |[COMPILE]|,
% |RECURSE|, |COMPILE,|, |STATE|, |[|, |]|.
%
% Do loops: |DO|, |?DO|, |LOOP|, |+LOOP|, |I|, |J|, |LEAVE|, |UNLOOP|.
%
% Environmental queries: |PAD|, |ENVIRONMENT?|.
%
% Execution tokens: |'|, |[']|, |EXECUTE|, |FIND|.
%
% Immediate conditionals: |[IF]|, |[ELSE]|, |[THEN]|.
%
% Input: |>IN|, |SOURCE|, |TIB|, |#TIB|, |CHAR|, |[CHAR]|, |(|, |\|,
% |PARSE|, |WORD|, |COUNT|, |S"|, |EVALUATE|, |ACCEPT|, |SOURCE-ID|,
% |REFILL|.  ^^A)
%
% Memory cells: |ALIGN|, |ALIGNED|, |CELL+|, |CHAR+|, |CELLS|, |CHARS|,
% |HERE|, |UNUSED|, |,|, |C,|, |@|, |C@|, |2@|, |!|, |C!|, |2!|, |+!|,
% |ALLOT|, |ERASE|, |FILL|, |MOVE|.
%
% Number conversion: |BASE|, |DECIMAL|, |HEX|, |<#|, |SIGN|, |HOLD|, |#|,
% |#S|, |#>|, |>NUMBER|.
%
% Output: |.|, |U.|, |.R|, |U.R|, |D.|, |D.R|, |.S|, |."|, |.(|, |BL|,
% |CR|, |EMIT|, |SPACE|, |SPACES|, |TYPE|, |?|, |DUMP|. ^^A)
%
% Quitting: |EXIT|, |QUIT|, |ABORT|, |ABORT"|, |BYE|.
%
% Stacks: |DEPTH|, |DROP|, |2DROP|, |NIP|, |SWAP|, |2SWAP|, |ROT|,
% |DUP|, |2DUP|, |OVER|, |2OVER|, |TUCK|, |PICK|, |ROLL|, |R>|, |2R>|,
% |R@|, |2R@|, |>R|, |2>R|, |S>D|, |D>S|, |2ROT|.
%
% \subsection{Details of the interpreter}
% \label{seq:forth-details}
%
% ^^A todo: clarify what to do with character code points >= 256.
%
% Implementation specificities are as follows.
% \begin{itemize}
% \item All addresses are aligned and are character-aligned.
% \item Behaviour of |EMIT| for non-graphic character: ?
% \item Character editing of |ACCEPT|: ?
% \item Character set: ?
% \item Character-set-extensions matching characteristics: ?
% \item Conditions under which control characters match a space
%   delimiter: whenever a space delimiter (character code \(32\)) is
%   called for, all characters in \([0,32]\) will match.  Even in the
%   case of |WORD|.
% \item Format of the control-flow stack: integers, indicating what was
%   the last control-flow construct used, \(0\) for |:| or |:NONAME|,
%   \(1\) for |DOES>|, \(2\) for |IF|, \(3\) for |ELSE|, \(6\) for |DO|,
%   \(7\) for |?DO|, \(8\) for |BEGIN|, \(9\) for |WHILE|.
% \item Conversion of digits larger than thirty-five: this never arises,
%   as the base used in conversion is automatically truncated to the
%   interval \([2, 36]\).
% \item Display after input terminates in |ACCEPT|: ?
% \item Exception abort sequence (as in |ABORT"|): message to the \TeX{}
%   terminal, with the non-zero value that was on the stack, and the
%   compile-time string.
% \item Input line terminator: ?  User input device: ?
% \item Maximum size of a counted string, in chars: ?
% \item Maximum size of a parsed string: ?
% \item Maximum size of a definition name, in chars: ?
% \item Maximum string length for |ENVIRONMENT?|, in chars: ?
% \item Method of selecting a user input device: ?
% \item Method of selecting a user output device: ?
% \item Methods of dictionary compilation: ?
% \item Number of bits in one address unit: \(24\).
% \item Number representation and arithmetic: internally represented as
%   \(24\)-bit unsigned integers (well, further down as \TeX{}
%   dimensions in a \tn{fontdimen} array).
% \item Integers \([-2^{23}, 2^{23} - 1]\), non-negative integers \([0,
%   2^{23} - 1]\), unsigned integers \([0, 2^{24} - 1]\), double
%   integers \([-2^{47}, 2^{47} - 1]\), non-negative double integers
%   \([0, 2^{47} - 1]\), unsigned double integers \([0, 2^{48} - 1]\).
% \item Read-only data-space regions: ?
% \item Size of buffer at |WORD|: ?
% \item One cell is one address unit.
% \item One character is one address unit.
% \item Size of the keyboard terminal input buffer: fixed upon starting
%   the Forth interpreter, at least \(128\).
% \item Size of the pictured numeric output string buffer: fixed upon
%   starting the Forth interpreter, at least \(127\).
% \item Size of the scratch area whose address is returned by |PAD|:
%   fixed upon starting the Forth interpreter, at least \(128\).
% \item Case-sensitivity: yes. (?)
% \item Prompt (see |QUIT|): ?
% \item Division rounding: symmetric (the quotient is rounded towards
%   zero, the remainder has the sign of the numerator).
% \item Value of |STATE| when true: all bits set.
% \item Values returned after arithmetic overflow: correct result,
%   modulo \(2^{24}\).
% \item In a |: X ... DOES> ... ;| construction, the definition of |X|
%   can be found after the |DOES>|.
% \end{itemize}
%
% Behaviour upon encountering ambiguous conditions.
% \begin{itemize}
% \item A name is neither a valid definition name nor a valid number
%   during text interpretation triggers a \TeX{} error.
% \item There is no maximum on the length of a definition name.
% \item Addressing a region outside data space can yield arbitrary data.
% \item No type checking is performed.
% \item The execution token obtained when applying |'| or |FIND| to a
%   word with undefined interpretation semantics is a valid token, whose
%   code triggers a \TeX{} error.
% \item Dividing by zero in |*/|, |*/MOD|, |/|, |/MOD|, |FM/MOD|, |MOD|,
%   |SM/REM|, |UM/MOD|, |M*/| triggers a \TeX{} error, and the
%   corresponding division yields \(0\) or the largest allowed integer,
%   depending on the operation.
% \item Stack overflow or underflow triggers a \TeX{} error, and the
%   stack pointer is not updated.  This includes the case of
%   insufficient data-stack space or return-stack space, insufficient
%   space for loop-control parameters, and overflow of the pictured
%   numeric output.  This also includes reading from an empty data stack
%   or return stack.
% \item Insufficient space for new words crashes \TeX{}.
% \item Interpreting a word with undefined interpretation semantics
%   triggers a \TeX{} error, and the word is ignored.
% \item Modifying the contents of the input buffer or a string literal
%   is harmless.
% \item Parsed string overflow: ?
% \item Arithmetic that produces out of range results yields the correct
%   result modulo \(2^{24}\) (size of the cell).
% \item Unexpected end of input buffer, resulting in an attempt to use a
%   zero-length string as a name: ?
% \item |>IN| greater than size of input buffer: ?
% \item If |RECURSE| appears after |DOES>|, it inserts the execution
%   token performing the code which follows |DOES>|.  The address of the
%   data field of the |CREATE|d word that is affected by |DOES>| is only
%   pushed once, and not at each recursive call.
% \item Argument input source different than current input source for
%   |RESTORE-INPUT|: ?
% \item Data space containing definitions can never be de-allocated, since
%   it is inaccessible.
% \item Data space read/write with incorrect alignment cannot happen,
%   since all addresses are aligned.
% \item Less than \(u+2\) stack items for |PICK| or |ROLL|.
% \item Loop-control parameters are not available for |+LOOP|, |I|, |J|,
%   |LEAVE|, |LOOP|, |UNLOOP|: ?
% \item Most recent definition does not have a name for |IMMEDIATE|: ?
% \item Name not defined by |VALUE| used by |TO|: ?
% \item Name not found |'|, |POSTPONE|, |[']|, |[COMPILE]|: ?
% \item |POSTPONE| or |[COMPILE]| applied to |TO|: ?
% \item String longer than a counted string returned by |WORD|: ?
% \item |LSHIFT| or |RSHIFT| with \(u \geq 24\): ?
% \item Using |>BODY| or |DOES>| for a word not defined via |CREATE|: ?
% \item Using |#|, |#S|, |HOLD| or |SIGN| improperly outside |<#| and
%   |#>| correctly places data into the pictured numeric buffer, but
%   this is later ignored.
% \end{itemize}
%
% \end{runner-documentation}
%
% \begin{runner-implementation}
%
% \section{\plang{forth} implementation}
%
% ^^A todo: normalize newlines?
% ^^A todo: document that |EVALUATE| can lead to |^^J| in the input buffer.
%
% \subsection{Generic helpers}
%
% Useful variants.
%    \begin{macrocode}
\cs_generate_variant:Nn \prop_gput:Nnn { Nx }
\cs_generate_variant:Nn \prop_get:NnNTF { Nx }
\cs_generate_variant:Nn \prop_get:NnNF { No }
\cs_generate_variant:Nn \prop_put:Nnn { Nxx }
\cs_generate_variant:Nn \tl_item:nn { o }
\cs_generate_variant:Nn \tl_if_head_eq_meaning:nNF { V }
\cs_generate_variant:Nn \tl_if_head_eq_meaning:nNTF { V }
\cs_generate_variant:Nn \str_set_convert:Nnnn { Nxnn }
%    \end{macrocode}
%
% \subsection{Data space and data stack}
%
% ^^A todo: convert the control-flow stack to be a simple tl.
% ^^A todo: what is the return stack used for.
%
% The data necessary to run Forth consists of
% \begin{itemize}
% \item the data stack, manipulated by the program, contains cells,
% \item the control-flow stack, which contains ``-sys'' types, and can
%   be implemented using the data stack,
% \item the return stack, which can be used by the program, but is
%   mostly used by the system, for definitions, do-loops, nesting info,
% \end{itemize}
% as well as
% \begin{itemize}
% \item the name space (mapping words to execution tokens),
% \item the code space (code for the execution tokens),
% \item the data space accessible to programs, which consists in
%   \begin{itemize}
%   \item contiguous regions,
%   \item variables,
%   \item text-literal regions,
%   \item input buffers,
%   \item and other transient regions.
%   \end{itemize}
% \end{itemize}
%
% The name space is implemented as a property list, mapping words to a
% flag in \(\{1,2,3\}\) and an execution token (integer in
% \([0,65535]\)) associated to this word.
%
% The code space is implemented using \tn{toks} registers: execution
% tokens are register numbers.
%
% Everything else is stored as one global array, \cs{g_@@_forth_array},
% of \(24\)-bit unsigned integers.  See \texttt{runner.dtx} for the
% array implementation.
%
% \subsubsection{The array}
%
% The array \cs{g_@@_forth_array} is split into several regions, in the
% following order (from low-numbered to high-numbered items).  For
% conciseness we refer in this list to integer variables by shorthands;
% \texttt{min} and \texttt{max} variables are global and can only change
% between Forth runs; other integers are local and change during runs.
% \begin{itemize}
% \item The pictured numeric output is from \texttt{picnum_min}
%   (included) to \texttt{picnum_max} (excluded): this contains material
%   from \texttt{picnum_here} (included) to \texttt{picnum_max}
%   (excluded).
% \item The terminal input buffer contains text from \texttt{term_min}
%   (included) to \texttt{term_end} (excluded), which can go up to
%   \texttt{term_max}.  The actual input source lies from
%   \texttt{source_begin} (included) to \texttt{source_end} (excluded),
%   which are normally equal to \texttt{term_min} and \texttt{term_end},
%   unless modified by |EVALUATE|.  The integer \texttt{source_parsed}
%   is used temporarily to store the sum of \texttt{source_end} and of
%   the value at~|>IN|.
% \item The pad is from \texttt{pad_min} (included) to \texttt{pad_max}
%   (excluded).
% \item The data space lies from \texttt{data_min} (included) to
%   \texttt{data_max} (excluded), and is split further.
%   \begin{itemize}
%   \item Contiguous regions of the data space, intermixed with
%     variables, lie between \texttt{data_min} (included) and
%     \texttt{data_here} (excluded).
%   \item The transient regions provided by |WORD| or |#>| start at
%     \texttt{data_here} (included) and end at \texttt{data_word}
%     (excluded).
%   \item Text literals are allocated at the end of the data space, and
%     lie between \texttt{data_text} (included) and \texttt{data_max}
%     (excluded).
%   \end{itemize}
% \item The data stack lies from \texttt{stack_min} to
%   \texttt{stack_max}, and the position where a new value would be
%   pushed is at \texttt{stack_here}.
% \item The control-flow stack lies from \texttt{control_min} to
%   \texttt{control_max}, and the position where a new value would be
%   pushed is \texttt{control_here}.
% \item The return stack lies from \texttt{return_min} to
%   \texttt{return_max}, and the position where a new value would be
%   pushed is at \texttt{return_here}.
% \end{itemize}
%
% In each slot of the array, we store a \(24\) bit unsigned integer,
% \ie, a number in the range \([0, 2^{24}-1]\) (note that we could go up
% to \(26\) bits with no adverse effect).  Address units are \(24\) bits
% wide.  Characters are one address unit wide (note that all Unicode
% code points are less than \(2^{23}\)).  Cells are one character wide.
% We do not use \(8\) bit characters (and addresses) for four reasons:
% only \(256\) cells could be addressed; counted strings would be
% bounded to \(255\) characters; extracting an \(8\)-bit part from a
% \(24\) bit value in \TeX{} is not fast; and we would need to chose an
% encoding for Unicode (this is still needed in \pdfTeX{}, but only at
% the very last step of output).
%
% \begin{variable}
%   {
%     \g_@@_forth_picnum_min_int,
%     \l_@@_forth_picnum_here_int,
%     \g_@@_forth_picnum_max_int,
%   }
%   The pictured numeric output, ranging from
%   \cs{l_@@_forth_picnum_here_int} to \cs{g_@@_forth_picnum_max_int}.
%    \begin{macrocode}
\int_new:N \g_@@_forth_picnum_min_int
\int_new:N \l_@@_forth_picnum_here_int
\int_new:N \g_@@_forth_picnum_max_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \g_@@_forth_term_min_int,
%     \l_@@_forth_term_end_int,
%     \g_@@_forth_term_max_int,
%     \l_@@_forth_source_begin_int,
%     \l_@@_forth_source_parsed_int,
%     \l_@@_forth_source_end_int,
%     \l_@@_forth_in_address_int,
%     \l_@@_forth_sources_seq
%   }
%   The terminal input buffer lies from \cs{g_@@_forth_term_min_int}
%   (included) to \cs{g_@@_forth_term_max_int} (excluded), and contains
%   text until \cs{l_@@_forth_term_end_int} (excluded).  The source
%   specification can be changed by |EVALUATE|: parsing words read the
%   buffer from \cs{l_@@_forth_source_begin_int} to
%   \cs{l_@@_forth_source_end_int}.  The integer
%   \cs{l_@@_forth_source_parsed_int} is set to the sum of
%   \cs{l_@@_forth_source_begin_int} and the value at~|>IN| (whose address
%   is \cs{l_@@_forth_in_address_int} before each parsing operation.
%   The stack \cs{l_@@_forth_sources_seq} stores the previous source
%   specification for nested |EVALUATE| calls.
%    \begin{macrocode}
\int_new:N \g_@@_forth_term_min_int
\int_new:N \l_@@_forth_term_end_int
\int_new:N \g_@@_forth_term_max_int
\int_new:N \l_@@_forth_source_begin_int
\int_new:N \l_@@_forth_source_parsed_int
\int_new:N \l_@@_forth_source_end_int
\int_new:N \l_@@_forth_in_address_int
\seq_new:N \l_@@_forth_sources_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_forth_pad_min_int, \g_@@_forth_pad_max_int}
%   The pad returned by |PAD| is fixed and ranges from
%   \cs{g_@@_forth_pad_min_int} (included) to
%   \cs{g_@@_forth_pad_max_int} (excluded).
%    \begin{macrocode}
\int_new:N \g_@@_forth_pad_min_int
\int_new:N \g_@@_forth_pad_max_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \g_@@_forth_data_min_int,
%     \l_@@_forth_data_here_int,
%     \l_@@_forth_data_word_int,
%     \l_@@_forth_data_text_int,
%     \g_@@_forth_data_max_int,
%   }
%   Allotted data, and variables, range from
%   \cs{g_@@_forth_data_min_int} (included) to
%   \cs{l_@@_forth_data_here_int} (excluded).  The latter integer is
%   what |HERE| returns.  Transient regions created by |WORD| or |#>|
%   lie between this address (included) and
%   \cs{l_@@_forth_data_word_int} (excluded).  Finally, text strings are
%   stored from \cs{l_@@_forth_data_text_int} (included) to
%   \cs{g_@@_forth_data_max_int} (excluded).
%    \begin{macrocode}
\int_new:N \g_@@_forth_data_min_int
\int_new:N \l_@@_forth_data_here_int
\int_new:N \l_@@_forth_data_word_int
\int_new:N \l_@@_forth_data_text_int
\int_new:N \g_@@_forth_data_max_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \g_@@_forth_stack_min_int,
%     \l_@@_forth_stack_here_int,
%     \g_@@_forth_stack_max_int
%   }
%   The data stack lies in this range, with the bottom item at
%   \cs{g_@@_forth_stack_min_int} and the top item just below
%   \cs{l_@@_forth_stack_here_int}.
%    \begin{macrocode}
\int_new:N \g_@@_forth_stack_min_int
\int_new:N \l_@@_forth_stack_here_int
\int_new:N \g_@@_forth_stack_max_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \g_@@_forth_control_min_int,
%     \l_@@_forth_control_here_int,
%     \g_@@_forth_control_max_int
%   }
%   The control flow stack lies in this range, with the bottom item at
%   \cs{g_@@_forth_control_min_int} and the top item just below
%   \cs{l_@@_forth_control_here_int}.
%    \begin{macrocode}
\int_new:N \g_@@_forth_control_min_int
\int_new:N \l_@@_forth_control_here_int
\int_new:N \g_@@_forth_control_max_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \g_@@_forth_return_min_int,
%     \l_@@_forth_return_here_int,
%     \g_@@_forth_return_max_int
%   }
%   The return stack lies there, with the bottom item at
%   \cs{g_@@_forth_return_min_int} and the top of the stack just below
%   \cs{l_@@_forth_return_here_int}.
%    \begin{macrocode}
\int_new:N \g_@@_forth_return_min_int
\int_new:N \l_@@_forth_return_here_int
\int_new:N \g_@@_forth_return_max_int
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\@@_forth_init_data:}
%   When starting a Forth run, one must reset the pointers that vary, to
%   the appropriate boundary of their region.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_init_data:
  {
    \int_set_eq:NN \l_@@_forth_picnum_here_int
      \g_@@_forth_picnum_max_int
    \int_set_eq:NN \l_@@_forth_term_end_int
      \g_@@_forth_term_min_int
    \int_set_eq:NN \l_@@_forth_source_begin_int
      \g_@@_forth_term_min_int
    \int_set_eq:NN \l_@@_forth_source_parsed_int
      \g_@@_forth_term_min_int
    \int_set_eq:NN \l_@@_forth_source_end_int
      \g_@@_forth_term_min_int
    \seq_clear:N \l_@@_forth_sources_seq
    \int_set_eq:NN \l_@@_forth_data_here_int
      \g_@@_forth_data_min_int
    \int_set_eq:NN \l_@@_forth_data_word_int
      \g_@@_forth_data_min_int
    \int_set_eq:NN \l_@@_forth_data_text_int
      \g_@@_forth_data_max_int
    \int_set_eq:NN \l_@@_forth_stack_here_int
      \g_@@_forth_stack_min_int
    \int_set_eq:NN \l_@@_forth_control_here_int
      \g_@@_forth_control_min_int
    \int_set_eq:NN \l_@@_forth_return_here_int
      \g_@@_forth_return_min_int
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: make the array size dynamical
% ^^A todo: ensure that picnum buffer is >= 127 cells wide.
% ^^A todo: ensure that input buffer and pad are >= 128 cells wide.
%
% \begin{variable}{\g_@@_forth_array}
%   This array contains most of the data needed by Forth.  We also give
%   here initial values for the array parameters, all at once to avoid
%   mistakes.
%    \begin{macrocode}
\int_gset:Nn \g_@@_forth_picnum_min_int { 1 }
\int_gset:Nn \g_@@_forth_picnum_max_int { 128 }
\int_gset:Nn \g_@@_forth_term_min_int { 128 }
\int_gset:Nn \g_@@_forth_term_max_int { 256 }
\int_gset:Nn \g_@@_forth_pad_min_int { 256 }
\int_gset:Nn \g_@@_forth_pad_max_int { 384 }
\int_gset:Nn \g_@@_forth_data_min_int { 384 }
\int_gset:Nn \g_@@_forth_data_max_int { 65152 }
\int_gset:Nn \g_@@_forth_stack_min_int { 65152 }
\int_gset:Nn \g_@@_forth_stack_max_int { 65280 }
\int_gset:Nn \g_@@_forth_control_min_int { 65280 }
\int_gset:Nn \g_@@_forth_control_max_int { 65408 }
\int_gset:Nn \g_@@_forth_return_min_int { 65408 }
\int_gset:Nn \g_@@_forth_return_max_int { 65536 }
\@@_array_new:Nn \g_@@_forth_array { 65536 }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_forth_fp_seq}
%   The floating point stack stores floating point numbers as token
%   lists (through \cs{fp_to_tl:n}).
%    \begin{macrocode}
\seq_new:N \l_@@_forth_fp_seq
%    \end{macrocode}
% \end{variable}
%
% \subsubsection{Integers modulo \(2^{24}\)}
%
% \begin{variable}{\c_@@_forth_mod_int}
%   Cells can take up to \(2^{24}\) values.  Arithmetic is often
%   performed modulo that number.
%    \begin{macrocode}
\int_const:Nn \c_@@_forth_mod_int { 16777216 }
%    \end{macrocode}
% ^^A todo: introduce \c_@@_forth_half_int ?
% \end{variable}
%
% \begin{macro}[int, EXP]{\@@_forth_sign_mask:N}
%   Yields \(0\) when |#1| is in \([0,2^{23}-1]\) and \(2^{23}\) when
%   |#1| is in \([2^{23}, 2^{24}-1]\).  We make use of \eTeX{}'s
%   rounding behaviour: dividing |#1| by \(2^{24}\) yields \(0\) for
%   numbers less than \(2^{23}\) and \(1\) for numbers in \([2^{23},
%   2^{24}-1]\).
%    \begin{macrocode}
\cs_new:Npn \@@_forth_sign_mask:N #1
  {
    \int_eval:n
      { #1 / \c_@@_forth_mod_int * \c_@@_forth_mod_int / \c_two }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_forth_signed:N}
% \begin{macro}[int]{\@@_forth_set_signed:N}
%   Turn the unsigned |#1| into a signed number, by subtracting
%   \(2^{24}\) if it is not less than \(2^{23}\).  See
%   \cs{@@_forth_sign_mask:N} for details.
%    \begin{macrocode}
\cs_new:Npn \@@_forth_signed:N #1
  {
    \int_eval:n
      { #1 - #1 / \c_@@_forth_mod_int * \c_@@_forth_mod_int }
  }
\cs_new_protected:Npn \@@_forth_set_signed:N #1
  {
    \int_set:Nn #1
      { #1 - #1 / \c_@@_forth_mod_int * \c_@@_forth_mod_int }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\@@_forth_double_negate:NN}
%   Change a double-cell integer \((a,b)\) to its opposite.  The
%   integers |#1| and |#2| are modified in place.  In most cases, the
%   result is \((2^{24}-a, 2^{24}-b-1)\) (we work modulo \(2^{48}\)),
%   but this fails for \(a=0\), where the correct answer is most often
%   \((0, 2^{24}-b)\), with the exception of \(b=0\), where it is simply
%   \((0,0)\).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_double_negate:NN #1#2
  {
    \int_compare:nNnTF #1 = \c_zero
      {
        \int_compare:nNnF #2 = \c_zero
          { \int_set:Nn #2 { \c_@@_forth_mod_int - #2 } }
      }
      {
        \int_set:Nn #1 { \c_@@_forth_mod_int - #1 }
        \int_set:Nn #2 { \c_@@_forth_mod_int - #2 - \c_one }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Bound checking}
%
% \begin{macro}[int]
%   {\@@_forth_check_data_bottom:, \@@_forth_check_data_top:}
%   After the |HERE| pointer is updated, it may lie outside the allowed
%   range from \texttt{data_min} to \texttt{data_text}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_check_data_bottom:
  {
    \int_compare:nNnT
      \l_@@_forth_data_here_int < \g_@@_forth_data_min_int
      { \@@_forth_abort:nx { out-of-bounds } { } }
  }
\cs_new_protected_nopar:Npn \@@_forth_check_data_top:
  {
    \int_compare:nNnT
      \l_@@_forth_data_here_int > \l_@@_forth_data_text_int
      { \@@_forth_abort:nx { out-of-memory } { } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]
%   {\@@_forth_check_stack_bottom:n, \@@_forth_check_stack_top:n}
%   Check that we can pop/push |#1| items from/onto the stack.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_check_stack_bottom:n #1
  {
    \int_compare:nNnT
      \l_@@_forth_stack_here_int
      < { \g_@@_forth_stack_min_int + #1 }
      { \@@_forth_abort:nx { empty-stack } { } }
  }
\cs_new_protected:Npn \@@_forth_check_stack_top:n #1
  {
    \int_compare:nNnT
      { \l_@@_forth_stack_here_int + #1 }
      > \g_@@_forth_stack_max_int
      { \@@_forth_abort:nx { out-of-memory } { } }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Data space}
%
% \begin{macro}[int, EXP]{\@@_forth_data_get:N, \@@_forth_data_get:n}
%   Retrieving unsigned integers from data space.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_forth_data_get:N
  { \@@_array_item:NN \g_@@_forth_array }
\cs_new_nopar:Npn \@@_forth_data_get:n
  { \@@_array_item:Nn \g_@@_forth_array }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_data_gset:nn}
%   Storing unsigned integers into data space.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_data_gset:nn
  { \@@_array_gset:Nnn \g_@@_forth_array }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_put_here:n}
%   Put a value at the position given by the \texttt{data_here} integer,
%   then increment that integer.  Check afterwards that we do not reach
%   the region occupied by text literals.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_put_here:n #1
  {
    \@@_forth_data_gset:nn { \l_@@_forth_data_here_int } {#1}
    \int_incr:N \l_@@_forth_data_here_int
    \@@_forth_check_data_top:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, rEXP]{\@@_forth_interval_to_clist:nn}
% \begin{macro}[aux, rEXP]{\@@_forth_interval_to_clist_aux:n}
%   Build a comma-list from a region of memory.
%    \begin{macrocode}
\cs_new:Npn \@@_forth_interval_to_clist:nn #1#2
  {
    \int_step_function:nnnN {#1} { 1 } { #2 - 1 }
      \@@_forth_interval_to_clist_aux:n
  }
\cs_new:Npn \@@_forth_interval_to_clist_aux:n #1
  { \@@_array_item:Nn \g_@@_forth_array {#1} , }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Data stack}
%
% \begin{macro}[int]{\@@_forth_pop_int_unsafe:N}
%   Pop an unsigned integer from the stack, with no bound-checking.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_pop_int_unsafe:N #1
  {
    \int_decr:N \l_@@_forth_stack_here_int
    \int_set:Nn #1
      {
        \@@_array_item:NN \g_@@_forth_array
          \l_@@_forth_stack_here_int
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_push_unsafe:n}
%   Push an unsigned integer onto the stack, with no bound-checking.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_push_unsafe:n #1
  {
    \@@_array_gset:Nnn \g_@@_forth_array
      \l_@@_forth_stack_here_int {#1}
    \int_incr:N \l_@@_forth_stack_here_int
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]
%   {
%     \@@_forth_pop_int:N,
%     \@@_forth_pop_int:NN,
%     \@@_forth_pop_int:NNN,
%     \@@_forth_pop_int:NNNN
%   }
%   Get multiple integers from stack, after checking that the stack has
%   enough items.  Note that things are popped backwards, so that the
%   last argument gets the top of the stack.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_pop_int:N #1
  {
    \@@_forth_check_stack_bottom:n \c_one
    \@@_forth_pop_int_unsafe:N #1
  }
\cs_new_protected:Npn \@@_forth_pop_int:NN #1#2
  {
    \@@_forth_check_stack_bottom:n \c_two
    \@@_forth_pop_int_unsafe:N #2
    \@@_forth_pop_int_unsafe:N #1
  }
\cs_new_protected:Npn \@@_forth_pop_int:NNN #1#2#3
  {
    \@@_forth_check_stack_bottom:n \c_three
    \@@_forth_pop_int_unsafe:N #3
    \@@_forth_pop_int_unsafe:N #2
    \@@_forth_pop_int_unsafe:N #1
  }
\cs_new_protected:Npn \@@_forth_pop_int:NNNN #1#2#3#4
  {
    \@@_forth_check_stack_bottom:n \c_four
    \@@_forth_pop_int_unsafe:N #4
    \@@_forth_pop_int_unsafe:N #3
    \@@_forth_pop_int_unsafe:N #2
    \@@_forth_pop_int_unsafe:N #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]
%   {
%     \@@_forth_push:n,
%     \@@_forth_push:nn,
%     \@@_forth_push:nnn,
%     \@@_forth_push:nnnn,
%     \@@_forth_push:nnnnn,
%     \@@_forth_push:nnnnnn,
%   }
%   Check that there is enough space, then push one or more unsigned
%   integers onto the stack.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_push:n #1
  {
    \@@_forth_check_stack_top:n \c_one
    \@@_forth_push_unsafe:n {#1}
  }
\cs_new_protected:Npn \@@_forth_push:nn #1#2
  {
    \@@_forth_check_stack_top:n \c_two
    \@@_forth_push_unsafe:n {#1}
    \@@_forth_push_unsafe:n {#2}
  }
\cs_new_protected:Npn \@@_forth_push:nnn #1#2#3
  {
    \@@_forth_check_stack_top:n \c_three
    \@@_forth_push_unsafe:n {#1}
    \@@_forth_push_unsafe:n {#2}
    \@@_forth_push_unsafe:n {#3}
  }
\cs_new_protected:Npn \@@_forth_push:nnnn #1#2#3#4
  {
    \@@_forth_check_stack_top:n \c_four
    \@@_forth_push_unsafe:n {#1}
    \@@_forth_push_unsafe:n {#2}
    \@@_forth_push_unsafe:n {#3}
    \@@_forth_push_unsafe:n {#4}
  }
\cs_new_protected:Npn \@@_forth_push:nnnnn #1#2#3#4#5
  {
    \@@_forth_check_stack_top:n \c_five
    \@@_forth_push_unsafe:n {#1}
    \@@_forth_push_unsafe:n {#2}
    \@@_forth_push_unsafe:n {#3}
    \@@_forth_push_unsafe:n {#4}
    \@@_forth_push_unsafe:n {#5}
  }
\cs_new_protected:Npn \@@_forth_push:nnnnnn #1#2#3#4#5#6
  {
    \@@_forth_check_stack_top:n \c_six
    \@@_forth_push_unsafe:n {#1}
    \@@_forth_push_unsafe:n {#2}
    \@@_forth_push_unsafe:n {#3}
    \@@_forth_push_unsafe:n {#4}
    \@@_forth_push_unsafe:n {#5}
    \@@_forth_push_unsafe:n {#6}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_push_value:n}
%   Push the value at a given address onto the stack.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_push_value:n #1
  { \@@_forth_push:n { \@@_forth_data_get:n {#1} } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_push_false:, \@@_forth_push_true:}
%   The \texttt{false} value is \(0\), the true value is \(-1\), which
%   we store as a positive integer by shifting by
%   \cs{c_@@_forth_mod_int}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_push_false:
  { \@@_forth_push:n { 0 } }
\cs_new_protected_nopar:Npx \@@_forth_push_true:
  {
    \@@_forth_push:n
      { \int_eval:n { \c_@@_forth_mod_int - 1 } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_push_signed:n}
% \begin{macro}[aux]{\@@_forth_push_signed_aux:n}
%   Given a signed integer in the range \([-2^{24}, 2^{24}-1]\) (note
%   the extra large range), push the corresponding unsigned
%   representation onto the stack.  This simply requires adding
%   \(2^{24}\) to negative numbers.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_push_signed:n #1
  {
    \exp_args:Nf \@@_forth_push_signed_aux:n
      { \int_eval:n {#1} }
  }
\cs_new_protected:Npn \@@_forth_push_signed_aux:n #1
  {
    \@@_forth_push:n
      {
        \int_compare:nNnTF {#1} < \c_zero
          { #1 + \c_@@_forth_mod_int } {#1}
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_push_mod:n}
%   Given a non-negative integer, push onto the stack its residue modulo
%   \(2^{24}\).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_push_mod:n #1
  {
    \@@_forth_push:n
      { \int_mod:nn {#1} { \c_@@_forth_mod_int } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_@@_forth_push_fp}
%   This floating point variable is used when pushing a floating point
%   expression converted to an integer onto the stack.
%    \begin{macrocode}
\fp_new:N \l_@@_forth_push_fp
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\@@_forth_push_fp:n, \@@_forth_push_fp_mod:n}
%   Convert a floating point expression to an integer, or an integer
%   after reducing it modulo \(2^{24}\), for use in some computations
%   involving intermediate double-cell results.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_push_fp:n #1
  { \@@_forth_push:n { \fp_to_int:n {#1} } }
\cs_new_protected:Npn \@@_forth_push_fp_mod:n #1
  {
    \fp_set:Nn \l_@@_forth_push_fp { round0(#1) }
    \@@_forth_push_fp:n
      {
        \l_@@_forth_push_fp - \c_@@_forth_mod_int
             * round- ( \l_@@_forth_push_fp / \c_@@_forth_mod_int )
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Return stack}
%
% \begin{macro}[int]{\@@_forth_return_pop_int:N}
%   Get data from the return stack.  The return stack is empty if
%   \texttt{return_here} is \texttt{return_min}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_return_pop_int:N #1
  {
    \int_compare:nNnF
      \l_@@_forth_return_here_int > \g_@@_forth_return_min_int
      { \@@_forth_abort:nx { empty-return-stack } { } }
    \int_decr:N \l_@@_forth_return_here_int
    \int_set:Nn #1
      {
        \@@_array_item:NN \g_@@_forth_array
          \l_@@_forth_return_here_int
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_return_push:n}
%   Push an unsigned integer onto the return stack, at
%   \texttt{return_here}, failing if the return stack is full.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_return_push:n #1
  {
    \int_compare:nNnF
      \l_@@_forth_return_here_int < \g_@@_forth_return_max_int
      { \@@_forth_abort:nx { out-of-memory } { } }
    \@@_array_gset:Nnn \g_@@_forth_array
      \l_@@_forth_return_here_int {#1}
    \int_incr:N \l_@@_forth_return_here_int
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Defining new words}
%
% The \TeX{} code to execute Forth words is stored within \tn{toks}
% registers, labelled by so-called ``execution tokens''.  An execution
% token is a cell restricted to the range \([0, 2^{16}-1]\) or \([0,
% 2^{15}-1]\) (depending on the engine's capabilities), and its
% execution semantics are simply to run the \TeX{} code in that
% \tn{toks} register.
%
% The mapping from words to their definitions is done by giving an
% execution token pointing to the \tn{toks} with the appropriate \TeX{}
% code.  In fact, one needs a little bit more: to each word is
% associated a digit in \(\{1, 2, 3\}\) and an execution token.
% \begin{itemize}
% \item \(1\) indicates normal words, whose interpretation semantics are
%   given by the execution token, and whose compilation semantics is to
%   append the execution token to the current definition;
% \item \(2\) indicates immediate words, whose interpretation and
%   compilation semantics are identical, and given by the execution
%   token;
% \item \(3\) indicates special words such as |ABORT"|, which may have
%   arbitrary interpretation and compilation semantics: the execution
%   token gives the intepretation semantics, and the compilation
%   semantics follows in the next \tn{toks} register.
% \end{itemize}
%
% \subsubsection{Code space}
%
% \begin{variable}{\l_@@_forth_token_int, \g_@@_forth_core_token_int}
%   The next free \tn{toks} register, for use to store the code
%   corresponding to execution tokens.
%    \begin{macrocode}
\int_new:N \l_@@_forth_token_int
\int_new:N \g_@@_forth_core_token_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_forth_init_toks_tl}
%   Token list containing part of the initialization code, currently
%   many assignments to \tn{toks} registers.
%    \begin{macrocode}
\tl_new:N \g_@@_forth_init_toks_tl
%    \end{macrocode}
% \end{variable}
%
% ^^A todo: expand this section
% \begin{macro}[int]{\@@_forth_execute:n}
%   Run the code saved in the \tn{toks} with number~|#1|.  This is
%   protected, which simplifies handling of expansion.  The trailing
%   \texttt{exit_point} (equal to \cs{scan_stop:}) terminates the number
%   returned by \cs{int_eval:n}, and serves as a marker to which |EXIT|
%   can jump.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_execute:n #1
  { \tex_the:D \tex_toks:D \int_eval:n {#1} \@@_forth_exit_point: }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Name space}
%
% \begin{variable}{\l_@@_forth_words_prop, \g_@@_forth_core_words_prop}
%   Keys of the \texttt{words} property list are words known to Forth at
%   a given time during the execution of the code.  Keys of the
%   \texttt{core_words} global property list are words from the core
%   set, with which the \texttt{words} property list is initialized.
%
%   Values are a digit \(d \in \{1, 2, 3\}\) followed by an execution
%   token \(\mathrm{xt}\), which lies in the
%   range \([0, 2^{15}-1]\) for \pdfTeX{} and \XeTeX{}, and in the range
%   \([0, 2^{16}-1]\) for \LuaTeX{}.  The code to be run upon execution
%   is always found in the \tn{toks} register given by this
%   integer.  The compilation semantics is to append \(\mathrm{xt}\) to
%   the current definition if \(d = 1\), to perform \(\mathrm{xt}\) if
%   \(d = 2\), and to perform \(\mathrm{xt} + 1\) if \(d = 3\).
%    \begin{macrocode}
\prop_new:N \l_@@_forth_words_prop
\prop_new:N \g_@@_forth_core_words_prop
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\@@_forth_chk_if_core_free:n}
%   Each core word should only be defined once.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_chk_if_core_free:n #1
  {
    \prop_get:NnNT \g_@@_forth_core_words_prop {#1} \l_@@_tmpa_tl
      { \msg_error:nn { runner/forth } { internal } }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: remove distinction between core/non-core words.
% \begin{macro}[int]
%   {
%     \@@_forth_new_core:nn,
%     \@@_forth_new_immediate_core:nn,
%     \@@_forth_new_compilation_core:nn
%   }
% \begin{macro}[aux]{\@@_forth_new_aux:nnn}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_new_core:nn
  { \@@_forth_new_aux:nnn { 1 } }
\cs_new_protected_nopar:Npn \@@_forth_new_immediate_core:nn
  { \@@_forth_new_aux:nnn { 2 } }
\cs_new_protected:Npn \@@_forth_new_compilation_core:nn #1#2
  {
    \@@_forth_new_aux:nnn { 3 } {#1}
      { \@@_forth_abort:nx { no-interpretation } {#1} }
    \tl_gput_right:Nx \g_@@_forth_init_toks_tl
      {
        \tex_toks:D \int_use:N \g_@@_forth_core_token_int
          { \exp_not:n {#2} }
      }
    \int_gincr:N \g_@@_forth_core_token_int
  }
\cs_new_protected:Npn \@@_forth_new_aux:nnn #1#2#3
  {
    \@@_forth_chk_if_core_free:n {#2}
    \tl_gput_right:Nx \g_@@_forth_init_toks_tl
      {
        \tex_toks:D \int_use:N \g_@@_forth_core_token_int
          { \exp_not:n {#3} }
      }
    \prop_gput:Nnx \g_@@_forth_core_words_prop {#2}
      { #1 \int_use:N \g_@@_forth_core_token_int }
    \int_gincr:N \g_@@_forth_core_token_int
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_core_alias:nn}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_core_alias:nn #1#2
  {
    \@@_forth_chk_if_core_free:n {#1}
    \prop_get:NnN \g_@@_forth_core_words_prop {#2} \l_@@_tmpa_tl
    \prop_gput:NnV \g_@@_forth_core_words_prop {#1} \l_@@_tmpa_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_@@_forth_def_token_int, \l_@@_forth_def_token_seq}
%   The execution token whose definition is being built may need to be
%   stored in case definitions are nested.
%    \begin{macrocode}
\int_new:N \l_@@_forth_def_token_int
\seq_new:N \l_@@_forth_def_token_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_forth_def_code_tl, \l_@@_forth_def_code_seq}
%   The \TeX{} code collected for a given chunk of compiled Forth code
%   is stored as a token list.  When encountering control-flow words,
%   the value is saved in a stack.
%    \begin{macrocode}
\tl_new:N \l_@@_forth_def_code_tl
\seq_new:N \l_@@_forth_def_code_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_forth_def_after_seq}
%    \begin{macrocode}
\seq_new:N \l_@@_forth_def_after_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\@@_forth_set_word_token:nn}
%   The name |#1| is stored (for |IMMEDIATE|).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_set_word_token:nn #1#2
  {
    \str_set:Nn \l_@@_forth_def_name_str {#1}
    \prop_put:Nnx \l_@@_forth_words_prop {#1} { 1 \int_eval:n {#2} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]
%   {
%     \@@_forth_set_word:nn,
%     \@@_forth_set_word:ox
%   }
%   The name |#1| is stored (for |IMMEDIATE|).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_set_word:nn #1#2
  {
    \tex_toks:D \l_@@_forth_token_int {#2}
    \@@_forth_set_word_token:nn {#1} \l_@@_forth_token_int
    \int_incr:N \l_@@_forth_token_int
  }
\cs_generate_variant:Nn \@@_forth_set_word:nn { ox }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Control-flow stack}
%
% \begin{variable}{\l_@@_forth_control_seq}
%    \begin{macrocode}
\seq_new:N \l_@@_forth_control_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\@@_forth_control_open:n}
%   All ``opening'' control words (|BEGIN|, |DO|, and so on) store the
%   definition-so-far into the \texttt{def_code} stack, and empty the
%   variable to accept further definition code.  Then an integer in
%   \([0,9]\) onto the control-flow stack, at \texttt{control_here},
%   failing if the control-flow stack is full.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_control_open:n #1
  {
    \int_compare:nNnF
      \l_@@_forth_control_here_int < \g_@@_forth_control_max_int
      { \@@_forth_abort:nx { out-of-memory } { } }
    \@@_array_gset:Nnn \g_@@_forth_array
      \l_@@_forth_control_here_int {#1}
    \int_incr:N \l_@@_forth_control_here_int
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, TF]{\@@_forth_control_close:n, \@@_forth_control_if:n}
% \begin{macro}[aux]{\@@_forth_control_if_aux:nn}
%   Read the top of the control-flow stack if not empty.  If this
%   matches with |#1|, \texttt{control_close} removes it (by shifting
%   \texttt{control_here}), while \texttt{control_if} does not.  Return
%   \texttt{true} if the top of the control stack matched the argument;
%   otherwise \texttt{false}.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \@@_forth_control_close:n #1 { TF }
  {
    \@@_forth_control_if_aux:nn {#1}
      { \int_decr:N \l_@@_forth_control_here_int }
  }
\prg_new_protected_conditional:Npnn \@@_forth_control_if:n #1 { TF }
  { \@@_forth_control_if_aux:nn {#1} { } }
\cs_new_protected:Npn \@@_forth_control_if_aux:nn #1#2
  {
    \int_compare:nNnTF
      \l_@@_forth_control_here_int > \g_@@_forth_control_min_int
      {
        \int_compare:nNnTF
          {
            \@@_array_item:Nn \g_@@_forth_array
              { \l_@@_forth_control_here_int - 1 }
          }
          = {#1}
          { #2 \prg_return_true: }
          { \prg_return_false: }
      }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Helpers}
%
% \subsubsection{Input}
%
% \begin{variable}
%   {
%     \l_@@_forth_word_begin_int,
%     \l_@@_forth_word_end_int,
%     \l_@@_forth_word_str,
%   }
%   When parsing a word, the \texttt{word_begin} and
%   \texttt{word_end} integers point to the first character and
%   just after the last one in the source buffer.  Some functions
%   manipulate a native-string representation of the word, and store it
%   in the \texttt{word} string.
%    \begin{macrocode}
\int_new:N \l_@@_forth_word_begin_int
\int_new:N \l_@@_forth_word_end_int
\str_new:N \l_@@_forth_word_str
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_forth_input_str}
%   Store the part of the input string provided by \cs{@@_get_line:NTF}
%   that did not fit into the input buffer.
%    \begin{macrocode}
\str_new:N \l_@@_forth_input_str
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int, TF]{\@@_forth_input_refill:}
% \begin{macro}[aux]{\@@_forth_input_refill_get:, \@@_forth_term_refill:}
%   This refills the input buffer, and returns \texttt{true} if
%   successful and \texttt{false} otherwise.  If the
%   \texttt{forth_input} string is non-empty (\ie, the buffer was too
%   short to hold the full line previously), call an auxiliary for the
%   transfer; otherwise we need to fetch a new line.  If the
%   \texttt{forth_sources} stack is not empty (we just exhausted a
%   string given to |EVALUATE|), then restore the previous Forth source:
%   the text that did not fit in the buffer is on top, then the values
%   of \texttt{source_end}, \texttt{source_parsed}, and
%   \texttt{source_begin}.  Otherwise, ask for more input using
%   \cs{@@_get_line:NTF}, before calling the transfer
%   function.  Note that even if \texttt{get_line} fails, we call it
%   back until the \texttt{sources_seq} is exhausted: this concatenates
%   program and input sources.  The transfer function
%   \texttt{term_refill:} (only called with the terminal input buffer as
%   a target) starts by splitting the string if it is too long, then
%   going through the first part one character at a time, filling the
%   input buffer with the character codes, and makes sure to set
%   \texttt{term_end}, \texttt{source_begin}, \texttt{source_parsed},
%   and \texttt{source_end}.  Note that after this function, |>IN| is
%   correctly set, but \texttt{source_parsed} is not.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \@@_forth_input_refill: { TF }
  {
    \tl_if_empty:NTF \l_@@_forth_input_str
      { \@@_forth_input_refill_get: }
      {
        \@@_forth_term_refill:
        \prg_return_true:
      }
  }
\cs_new_protected_nopar:Npn \@@_forth_input_refill_get:
  {
    \seq_pop:NNTF \l_@@_forth_sources_seq \l_@@_forth_input_str
      {
        \seq_pop:NN \l_@@_forth_sources_seq \l_@@_tmpc_tl
        \seq_pop:NN \l_@@_forth_sources_seq \l_@@_tmpb_tl
        \seq_pop:NN \l_@@_forth_sources_seq \l_@@_tmpa_tl
        \int_set:Nn \l_@@_forth_source_begin_int { \l_@@_tmpa_tl }
        \@@_forth_data_gset:nn
          { \l_@@_forth_in_address_int }
          { \l_@@_tmpb_tl }
        \int_set:Nn \l_@@_forth_source_end_int { \l_@@_tmpc_tl }
        \prg_return_true:
      }
      {
        \@@_get_line:NTF \l_@@_forth_input_str
          {
            \@@_forth_term_refill:
            \prg_return_true:
          }
          {
            \seq_if_empty:NTF \l_@@_sources_seq
              { \prg_return_false: }
              { \@@_forth_input_refill_get: }
          }
      }
  }
\cs_new_protected_nopar:Npn \@@_forth_term_refill:
  {
    \int_set:Nn \l_@@_tmpa_int
      { \g_@@_forth_term_max_int - \g_@@_forth_term_min_int }
    \tl_set:Nx \l_@@_tmpb_tl
      {
        \str_range:Nnn \l_@@_forth_input_str
          { 1 } { \l_@@_tmpa_int }
      }
    \tl_set:Nx \l_@@_forth_input_str
      {
        \str_range:Nnn \l_@@_forth_input_str
          { \l_@@_tmpa_int + 1 } { -1 }
      }
    \int_set_eq:NN \l_@@_forth_term_end_int
      \g_@@_forth_term_min_int
    \@@_forth_store_str:NN \l_@@_tmpb_tl \l_@@_forth_term_end_int
    \int_set_eq:NN \l_@@_forth_source_begin_int
      \g_@@_forth_term_min_int
    \@@_forth_data_gset:nn { \l_@@_forth_in_address_int } { 0 }
    \int_set_eq:NN \l_@@_forth_source_end_int
      \l_@@_forth_term_end_int
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int, TF]{\@@_forth_read_char:N}
%   Unless at the end of the buffer, store in the first argument (an
%   integer variable) the character code of the next character in the
%   input and return \texttt{true}.  At the end of the buffer, simply
%   return \texttt{true}.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \@@_forth_read_char:N #1 { TF }
  {
    \int_compare:nNnTF
      \l_@@_forth_source_parsed_int < \l_@@_forth_source_end_int
      {
        \int_set:Nn #1
          {
            \@@_array_item:NN \g_@@_forth_array
              \l_@@_forth_source_parsed_int
          }
        \prg_return_true:
      }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_input_discard:n, \@@_forth_input_until:n}
% \begin{macro}[aux]
%   {\@@_forth_input_discard_aux:TFn, \@@_forth_input_discard_aux:NnTF}
%   Discarding or reading until a character is done by looping over
%   characters in the input buffer until some condition is met.  The
%   arguments of the \texttt{:TFn} auxiliary are code for characters
%   which match the delimiter, code for characters which do not match,
%   and the value of the delimiter.  Namely, \texttt{input_discard}
%   ignores delimiters by incrementing \texttt{source_parsed}, and stops
%   the loop when seeing a delimiter (by setting a boolean);
%   \texttt{input until} stops the loop when meeting a delimiter,
%   otherwise adds the character to the \texttt{word} string: in
%   both cases it goes to the next character in all cases (incrementing
%   \texttt{source_parsed}).  The \texttt{:TFn} auxiliary finds out
%   whether the delimiter is a space: in this case, characters in
%   \([0,32]\) match the delimiter, otherwise, only the delimiter itself
%   matches.  The \texttt{:NnTF} auxiliary receives a comparison
%   (\(<33\) or \(=|{#1}|\)), and the code for delimiters and
%   non-delimiters.  It sets \texttt{source_parsed} using~|>IN|, does
%   the loop, reading characters until either no character can be found
%   (\texttt{false} branch of \texttt{read_char}), or the loop is broken
%   by the code of |#3| or~|#4|.  Then set the value at~|>IN| correctly
%   for the outside world to see.  This function uses
%   \cs{l_@@_tmpa_bool} and \cs{l_@@_tmpc_int} as scratch space.
%   After the end of the function, the input word can be found from
%   \texttt{word_begin} to \texttt{word_end}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_input_discard:n
  {
    \@@_forth_input_discard_aux:TFn
      { \int_incr:N \l_@@_forth_source_parsed_int }
      { \bool_set_false:N \l_@@_tmpa_bool }
  }
\cs_new_protected:Npn \@@_forth_input_until:n #1
  {
    \@@_forth_input_discard_aux:TFn
      {
        \bool_set_false:N \l_@@_tmpa_bool
        \int_set_eq:NN \l_@@_forth_word_end_int
          \l_@@_forth_source_parsed_int
        \int_incr:N \l_@@_forth_source_parsed_int
      }
      { \int_incr:N \l_@@_forth_source_parsed_int }
      {#1}
  }
\cs_new_protected:Npn \@@_forth_input_discard_aux:TFn #1#2#3
  {
    \int_compare:nNnTF {#3} = { 32 }
      { \@@_forth_input_discard_aux:NnTF < { 33 } }
      { \@@_forth_input_discard_aux:NnTF = {#3} }
          {#1} {#2}
  }
\cs_new_protected:Npn \@@_forth_input_discard_aux:NnTF #1#2#3#4
  {
    \int_set:Nn \l_@@_forth_source_parsed_int
      {
        \l_@@_forth_source_begin_int
        + \@@_forth_data_get:n { \l_@@_forth_in_address_int }
      }
    \int_set_eq:NN \l_@@_forth_word_begin_int
      \l_@@_forth_source_parsed_int
    \bool_set_true:N \l_@@_tmpa_bool
    \bool_while_do:Nn \l_@@_tmpa_bool
      {
        \@@_forth_read_char:NTF \l_@@_tmpc_int
          { \int_compare:nNnTF \l_@@_tmpc_int #1 {#2} {#3} {#4} }
          {
            \int_set_eq:NN \l_@@_forth_word_end_int
              \l_@@_forth_source_parsed_int
            \bool_set_false:N \l_@@_tmpa_bool
          }
      }
    \@@_forth_data_gset:nn { \l_@@_forth_in_address_int }
      {
        \l_@@_forth_source_parsed_int
        - \l_@@_forth_source_begin_int
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_input_set_word:}
%   Once the word has been found by \cs{@@_forth_input_until:n}, this
%   function stores the actual characters in
%   \cs{l_@@_forth_word_str}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_input_set_word:
  {
    \str_set_convert:Nxnn \l_@@_forth_word_str
      {
        \@@_forth_interval_to_clist:nn
          \l_@@_forth_word_begin_int
          \l_@@_forth_word_end_int
      }
      { clist } { }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_input_word:}
%   Many functions read a word from the input.  This is a short-hand for
%   the task.  After its operation, the word is stored as the
%   \texttt{word} string, and lies from the
%   \texttt{word_begin} to the \texttt{word_end} (excluded)
%   cells in memory.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_input_word:
  {
    \@@_forth_input_discard:n { 32 }
    \@@_forth_input_until:n { 32 }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Numbers}
%
% \begin{variable}{\l_@@_forth_base_address_int}
%   Address of the cell at which the base of the number system is stored.
%    \begin{macrocode}
\int_new:N \l_@@_forth_base_address_int
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int, EXP]{\@@_forth_base:}
%   As the value of the base can be altered directly by the programmer,
%   we must fetch it before every conversion.  This function restricts
%   the base to the interval \([2, 36]\).
%    \begin{macrocode}
\cs_new:Npn \@@_forth_base:
  {
    \int_min:nn { 36 }
      {
        \int_max:nn { 2 }
          { \@@_forth_data_get:N \l_@@_forth_base_address_int }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_to_number:}
% \begin{macro}[aux]{\@@_forth_to_number_aux:n}
%   This function should be called with the temporary integers \((c,d)\)
%   set to a cell pair, and \(e\) and \(f\) set to addresses (\(f\) can
%   be out of bounds).  Characters are read starting with the
%   cell~\(e\).  If the character~\(a\) is a valid digit in the current
%   base (which we store as~\(b\)), then update \((c,d)\) by multiplying
%   it by~\(b\) then adding the value~\(a-48\) or \(a-55\) of the digit.
%   Some care is needed for the carry.  The loop stops either when the
%   address~\(e\) (which we increment at each step) reaches the
%   end-address~\(f\), or when a non-digit is found.  It turns out that
%   one can safely jump outside the loop with a \cs{@@_break:n} \ldots{}
%   \cs{@@_break_point:n} construction (because \cs{int_while_do:nNnn}
%   is expandable, hence side-effect free).
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_to_number:
  {
    \int_set:Nn \l_@@_tmpb_int { \@@_forth_base: }
    \int_while_do:nNnn \l_@@_tmpe_int < \l_@@_tmpf_int
      {
        \int_set:Nn \l_@@_tmpa_int
          { \@@_forth_data_get:n { \l_@@_tmpe_int } }
        \int_compare:nTF
          { 65 <= \l_@@_tmpa_int < 55 + \l_@@_tmpb_int }
          { \@@_forth_to_number_aux:n { \l_@@_tmpa_int - 55 } }
          {
            \int_compare:nTF
              { 48 <= \l_@@_tmpa_int < 48 + \l_@@_tmpb_int }
              { \@@_forth_to_number_aux:n { \l_@@_tmpa_int - 48 } }
              { \@@_break:n { } }
          }
        \int_incr:N \l_@@_tmpe_int
      }
    \@@_break_point:n { }
  }
\cs_new_protected:Npn \@@_forth_to_number_aux:n #1
  {
    \int_set:Nn \l_@@_tmpc_int
      { \l_@@_tmpb_int * \l_@@_tmpc_int + #1 }
    \int_set:Nn \l_@@_tmpd_int
      {
        \l_@@_tmpb_int * \l_@@_tmpd_int
        + \int_div_truncate:nn
          { \l_@@_tmpc_int } { \c_@@_forth_mod_int }
      }
    \int_set:Nn \l_@@_tmpc_int
      { \int_mod:nn { \l_@@_tmpc_int } { \c_@@_forth_mod_int } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_get_number:N}
% \begin{macro}[aux]{\@@_forth_get_number_aux:NN}
%   When this function is called, the word just read lies between
%   positions \texttt{word_begin} (included), which we store
%   as~\(e\), and \texttt{word_end} (excluded), which we store
%   as~\(f\).  We will use the \texttt{to_number} auxiliary, with
%   initial value \((c,d)=(0,0)\) and addresses~\(e\) and~\(f\)
%   delimiting the word just found.  Before this,
%   \texttt{get_number_sign} looks for a leading sign, and updates~\(e\)
%   accordingly.  The token list \texttt{tmpa} then contains the
%   function~|#1| (which distinguishes between compilation and
%   interpretation), and the sign |+| or~|-|.  After reading digits,
%   check if we are done (\(e=f\)): in that case, the
%   \texttt{get_number_aux} auxiliary gets the sign and function from
%   the \texttt{tmpa} token list, and does the appropriate operation.
%   If \(e\neq f\), dispatch, calling \texttt{get_double} upon seeing a
%   dot, \texttt{get_exponent} upon seeing an exponent mark, and an
%   error otherwise.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_get_number:N #1
  {
    \tl_set:Nn \l_@@_tmpa_tl {#1}
    \int_zero:N \l_@@_tmpc_int
    \int_zero:N \l_@@_tmpd_int
    \int_set_eq:NN \l_@@_tmpe_int \l_@@_forth_word_begin_int
    \int_set_eq:NN \l_@@_tmpf_int \l_@@_forth_word_end_int
    \@@_forth_get_number_sign:
    \@@_forth_to_number:
    \int_compare:nNnTF \l_@@_tmpe_int = \l_@@_tmpf_int
      { \exp_after:wN \@@_forth_get_number_aux:NN \l_@@_tmpa_tl }
      {
        \int_case:nnn { \@@_forth_data_get:N \l_@@_tmpe_int }
          {
            { `. }
              { \exp_args:NV \@@_forth_get_double:n \l_@@_tmpe_int }
            { `E } { \@@_forth_get_exponent:n { 0 } }
            { `e } { \@@_forth_get_exponent:n { 0 } }
          }
          { \@@_forth_abort_unknown_word: }
      }
  }
\cs_new_protected:Npn \@@_forth_get_number_aux:NN #1#2
  { #1 { \@@_forth_push_signed:n { #2 \int_use:N \l_@@_tmpc_int } } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\@@_forth_get_number_sign:}
%   Read zero or one sign at~\(e\), increment~\(e\) if a sign was found,
%   and append |+| or~|-| to the token list \texttt{tmpa}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_get_number_sign:
  {
    \int_compare:nNnTF \l_@@_tmpe_int = \l_@@_tmpf_int
      { \tl_put_right:Nn \l_@@_tmpa_tl { + } }
      {
        \int_case:nnn { \@@_forth_data_get:N \l_@@_tmpe_int }
          {
            { `- } { \tl_put_right:Nn \l_@@_tmpa_tl { - } }
            { `+ } { \tl_put_right:Nn \l_@@_tmpa_tl { + } }
          }
          {
            \tl_put_right:Nn \l_@@_tmpa_tl { + }
            \int_decr:N \l_@@_tmpe_int
          }
        \int_incr:N \l_@@_tmpe_int
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\@@_forth_get_double:n, \@@_forth_get_double_aux:NN}
%   When this function is called, the \texttt{tmpa} token list contains
%   a function and a sign, we have just read some digits, and
%   \(e\)~points to a period.  The argument is the current value
%   of~\(e\).  If there is nothing after the dot, we found a double-cell
%   integer.  Otherwise, read more digits, and call the
%   \texttt{get_float} function to do some checks and possibly look for
%   an exponent.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_get_double:n #1
  {
    \int_incr:N \l_@@_tmpe_int
    \int_compare:nNnTF \l_@@_tmpe_int = \l_@@_tmpf_int
      { \exp_after:wN \@@_forth_get_double_aux:NN \l_@@_tmpa_tl }
      {
        \@@_forth_to_number:
        \exp_args:Nx \@@_forth_get_float:n
          { \int_eval:n { \l_@@_tmpe_int - #1 - 1 } }
      }
  }
\cs_new_protected:Npn \@@_forth_get_double_aux:NN #1#2
  {
    \token_if_eq_charcode:NNF #2 +
      { \@@_forth_double_negate:NN \l_@@_tmpc_int \l_@@_tmpd_int }
    #1
      {
        \@@_forth_push:n { \int_use:N \l_@@_tmpc_int }
        \@@_forth_push:n
          { \int_mod:nn \l_@@_tmpd_int \c_@@_forth_mod_int }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]
%   {
%     \@@_forth_get_float:n,
%     \@@_forth_get_exponent:n,
%     \@@_forth_get_float_aux:NNnnnN,
%   }
%   If after reading the fractional part we reach the end of the word,
%   the float has no exponent.  If the next character is |E| or~|e|,
%   read an exponent.  Otherwise, complain.  The argument of the
%   \texttt{get_float} and \texttt{get_exponent} functions is the number
%   of digits after the period.  The exponent is read in the same basis,
%   using \texttt{to_number}.  Before this, save in the \texttt{tmpa}
%   token list \(c\), \(d\) and the shift in exponent due to the
%   fractional part, then zero the two integers.  If \texttt{to_number}
%   fails to convert all characters, complain.  Otherwise, compute the
%   value of the floating point number, and store it in the floating
%   point stack.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_get_float:n #1
  {
    \int_compare:nNnTF \l_@@_tmpe_int = \l_@@_tmpf_int
      {
        \int_decr:N \l_@@_tmpe_int
        \@@_forth_get_exponent:n {#1}
      }
      {
        \int_case:nnn { \@@_forth_data_get:N \l_@@_tmpe_int }
          {
            { `E } { \@@_forth_get_exponent:n {#1} }
            { `e } { \@@_forth_get_exponent:n {#1} }
          }
          { \@@_forth_abort_unknown_word: }
      }
  }
\cs_new_protected:Npn \@@_forth_get_exponent:n #1
  {
    \int_incr:N \l_@@_tmpe_int
    \tl_put_right:Nx \l_@@_tmpa_tl
      {
        { \int_use:N \l_@@_tmpc_int }
        { \int_use:N \l_@@_tmpd_int }
        { - #1 }
      }
    \int_zero:N \l_@@_tmpc_int
    \int_zero:N \l_@@_tmpd_int
    \@@_forth_get_number_sign:
    \@@_forth_to_number:
    \int_compare:nNnTF \l_@@_tmpe_int = \l_@@_tmpf_int
      { \exp_after:wN \@@_forth_get_float_aux:NNnnn \l_@@_tmpa_tl }
      { \@@_forth_abort_unknown_word: }
  }
\cs_new_protected:Npn \@@_forth_get_float_aux:NNnnnN #1#2#3#4#5#6
  {
    \seq_push:Nx \l_@@_forth_fp_seq
      {
        \fp_eval:n
          {
            #2 ( #3 + \c_@@_forth_mod_int * #4 )
            * \l_@@_tmpb_int ^ (
              - #5
              #6 \l_@@_tmpc_int
              #6 \c_@@_forth_mod_int * \l_@@_tmpd_int
            )
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Misc}
%
% \begin{macro}[int]{\@@_forth_input_word_and_set:x}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_input_word_and_set:x
  {
    \@@_forth_input_word:
    \@@_forth_input_set_word:
    \@@_forth_set_word:ox \l_@@_forth_word_str
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_input_word_xt:N}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_input_word_xt:N #1
  {
    \@@_forth_input_word:
    \@@_forth_input_set_word:
    \prop_get:NoNF \l_@@_forth_words_prop
      \l_@@_forth_word_str #1
      { \@@_forth_abort_unknown_word: }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_last_def_xt:N}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_last_def_xt:N #1
  {
    \prop_get:NoNF \l_@@_forth_words_prop
      \l_@@_forth_def_name_str #1
      {
        \@@_forth_abort:nx { unknown-word }
          { \l_@@_forth_def_name_str }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: also empty the def_code etc.?
% \begin{macro}[int]{\@@_forth_abort:nxx, \@@_forth_abort:nx}
%   Some ambiguous conditions lead the interpreter to balk and go away
%   from all words being executed, emptying all stacks.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_abort:nxx #1#2#3
  {
    \msg_error:nnxx { runner/forth } {#1} {#2} {#3}
    \int_set_eq:NN \l_@@_forth_stack_here_int
      \g_@@_forth_stack_min_int
    \@@_forth_do_quit:
  }
\cs_new_protected:Npn \@@_forth_abort:nx #1#2
  { \@@_forth_abort:nxx {#1} {#2} { } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_abort_unknown_word:}
%   After attempting to parse a word as a number and failing, this error
%   is raised.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_abort_unknown_word:
  {
    \@@_forth_input_set_word:
    \@@_forth_abort:nx { unknown-word }
      { \l_@@_forth_word_str }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}
%   {
%     \l_@@_forth_state_address_int,
%     \l_@@_forth_tib_size_address_int
%   }
%   Address of the |STATE| flag, \(0\) during interpretation,
%   \(2^{24}-1\) during compilation.  Address where the terminal input
%   buffer's size is stored when |#TIB| is called.
%    \begin{macrocode}
\int_new:N \l_@@_forth_state_address_int
\int_new:N \l_@@_forth_tib_size_address_int
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]
%   {
%     \@@_forth_store_str:NN,
%     \@@_forth_store_seq:NN,
%   }
%   Store the string or sequence |#1| in the \texttt{forth_array}
%   starting at position |#2|.  Afterwards, |#2| is at the first cell
%   after the string, and |#1| is modified.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_store_str:NN #1#2
  {
    \tl_replace_all:Nnn #1 { ~ } { {~} }
    \tl_map_inline:Nn #1
      {
        \@@_array_gset:Nnn \g_@@_forth_array {#2} { `##1 }
        \int_incr:N #2
      }
  }
\cs_new_protected:Npn \@@_forth_store_seq:NN #1#2
  {
    \seq_map_inline:Nn #1
      {
        \@@_array_gset:Nnn \g_@@_forth_array {#2} {##1}
        \int_incr:N #2
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_store_interval:NNN}
%   Store the string lying from |#1| to |#2| in the \texttt{forth_array}
%   starting at position |#3|.  Afterwards, |#3| is at the first cell
%   after the string.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_store_interval:NNN #1#2#3
  {
    \int_step_inline:nnnn {#1} { 1 } { #2 - 1 }
      {
        \@@_array_gset:Nnn \g_@@_forth_array {#3}
          { \@@_array_item:Nn \g_@@_forth_array {##1} }
        \int_incr:N #3
      }
  }
%    \end{macrocode}
% ^^A todo: rename \@@_forth_store_interval:NNN to \@@_forth_copy_up:NNN
% \end{macro}
%
% \subsection{Running the interpreter}
%
% \begin{macro}[int]{\@@_forth_run:}
%   After initializing many of the variables, start the text interpreter
%   loop, which stops when there is no input left.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_run:
  {
    \@@_forth_run_init:
    \@@_forth_run_loop:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_run_init:}
%   Initialize the data space.  Initialize the code space.  Initialize
%   the name space.  Store a |BASE| of \(10\) and an |>IN| value of
%   \(0\), a |STATE| flag of \texttt{false} (0), and a |#TIB| of \(0\),
%   starting interpretation.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_run_init:
  {
    \tl_set:Nn \l_@@_prompt_code_tl
      { \tex_message:D { ok ~ } }
    \@@_forth_init_data:
    \tl_use:N \g_@@_forth_init_toks_tl
    \int_set_eq:NN
      \l_@@_forth_token_int
      \g_@@_forth_core_token_int
    \prop_set_eq:NN
      \l_@@_forth_words_prop
      \g_@@_forth_core_words_prop
    \int_set_eq:NN \l_@@_forth_base_address_int
      \l_@@_forth_data_here_int
    \@@_forth_put_here:n { 10 }
    \int_set_eq:NN \l_@@_forth_in_address_int
      \l_@@_forth_data_here_int
    \@@_forth_put_here:n { 0 }
    \int_set_eq:NN \l_@@_forth_state_address_int
      \l_@@_forth_data_here_int
    \@@_forth_put_here:n { 0 }
    \int_set_eq:NN \l_@@_forth_tib_size_address_int
      \l_@@_forth_data_here_int
    \@@_forth_put_here:n { 0 }
    \@@_forth_state_to_interpret:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_run_loop:}
%   The interpreter is a loop retrieving a word at each iteration, and
%   performing it.  If the \texttt{word} is empty (end of line,
%   tested by comparing the begin and end positions of the parsed
%   region), refill the input buffer.  When there is nothing left,
%   remove the \texttt{quit_point} (a dummy marker) and the
%   \texttt{run_loop} function from the input stream to stop the loop.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_run_loop:
  {
    \@@_forth_input_word:
    \int_compare:nNnTF
      \l_@@_forth_word_begin_int
      < \l_@@_forth_word_end_int
      { \@@_forth_perform: }
      { \@@_forth_input_refill:TF { } { \use_none:nn } }
    \@@_forth_quit_point:
    \@@_forth_run_loop:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_quit:, \@@_forth_quit_point:}
%   A \texttt{quit_point} marker is placed at every iteration of the
%   \cs{@@_forth_run_loop:} function, so that |QUIT|, |ABORT| and
%   |ABORT"| can safely cleanup all remaining code and go to the next
%   iteration.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_quit:
  #1 \@@_forth_quit_point: { }
\cs_new_eq:NN \@@_forth_quit_point: \scan_stop:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_perform:}
% \begin{macro}[int]
%   {\@@_forth_state_to_interpret:, \@@_forth_state_to_compile:}
%   The \texttt{perform} function is alternatively set equal to the
%   \texttt{interpret} or the \texttt{compile} functions.  We must keep
%   track of the state by storing \(0\) (false) or \(-1\) (true) at a
%   given address, because the state must be visible to the
%   \plang{forth} programmer.
%    \begin{macrocode}
\cs_new_eq:NN \@@_forth_perform: ?
\cs_new_protected_nopar:Npn \@@_forth_state_to_interpret:
  {
    \@@_forth_data_gset:nn
      { \l_@@_forth_state_address_int } { 0 }
    \cs_set_eq:NN \@@_forth_perform: \@@_forth_interpret:
  }
\cs_new_protected_nopar:Npn \@@_forth_state_to_compile:
  {
    \@@_forth_data_gset:nn
      { \l_@@_forth_state_address_int }
      { \c_@@_forth_mod_int - \c_one }
    \cs_set_eq:NN \@@_forth_perform: \@@_forth_compile:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_forth_interpret:, \@@_forth_compile:}
% \begin{macro}[int]{\@@_forth_perform:Nn}
% \begin{macro}[int, EXP]{\@@_forth_perform_case:Nn}
%   When those functions are called, the \texttt{word_begin} and
%   \texttt{word_end} integers are set to the end-points of the
%   word just found.  Build a string out of the character codes, and
%   search for it in the words property list.  If the word is known,
%   then the \texttt{tmpa} token list is set to a digit \(1\) (normal
%   word), \(2\) (immediate word), or \(3\) (special word), followed by
%   an execution token.  Normal words are either performed immediately
%   or this action is stored in the current definition's code
%   (controlled by the function~|#1|).  Immediate words are performed
%   right away.  For special words, the execution tokens for the
%   execution semantics and the compilation semantics follow each other,
%   and we perform the appropriate one thanks to the possible
%   shift~|#2|.  Finally, if the word was not found, try to parse it as
%   a number.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_interpret:
  { \@@_forth_perform:Nn \use:n { } }
\cs_new_protected:Npn \@@_forth_compile:
  { \@@_forth_perform:Nn \@@_forth_def_code:x { + 1 } }
\cs_new_protected:Npn \@@_forth_perform:Nn #1#2
  {
    \@@_forth_input_set_word:
    \prop_get:NoNTF
      \l_@@_forth_words_prop
      \l_@@_forth_word_str
      \l_@@_tmpa_tl
      { \@@_forth_perform_case:Nn #1 {#2} }
      { \@@_forth_get_number:N #1 }
  }
\cs_new:Npn \@@_forth_perform_case:Nn #1#2
  {
    \int_case:nnn { \tl_head:N \l_@@_tmpa_tl }
      {
        { 1 } { #1 { \@@_forth_execute:n { \tl_tail:N \l_@@_tmpa_tl } } }
        { 2 } { \@@_forth_execute:n { \tl_tail:N \l_@@_tmpa_tl } }
      }
      { \@@_forth_execute:n { \tl_tail:N \l_@@_tmpa_tl #2 } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Words}
%
% \subsubsection{Arithmetic}
%
% This section defines the words |ABS|, |NEGATE|, |MAX|, |MIN|, |1+|,
% |1-|, |-|, |+|, |*|, |/|, |MOD|, |/MOD|, |*/|, |M*|, |UM*|, |FM/MOD|,
% |SM/REM|, |UM/MOD|, |*/MOD|, |DABS|, |DNEGATE|, |D+|, |D-|, |M+|, |M*/|.
%
% \begin{macro}[int]{ABS}
%   Get a signed integer from the top of the stack, and change it to its
%   absolute value.
%    \begin{macrocode}
\@@_forth_new_core:nn { ABS }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:n
      { \int_abs:n { \@@_forth_signed:N \l_@@_tmpa_int } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{NEGATE}
%   Get a signed integer from the top of the stack, and change it to its
%   opposite.
%    \begin{macrocode}
\@@_forth_new_core:nn { NEGATE }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push_signed:n
      { - \@@_forth_signed:N \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{MAX, MIN}
%   Get two signed integers from the stack, and push the
%   biggest/smallest back onto the stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { MAX }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push_signed:n
      {
        \int_max:nn
          { \@@_forth_signed:N \l_@@_tmpa_int }
          { \@@_forth_signed:N \l_@@_tmpb_int }
      }
  }
\@@_forth_new_core:nn { MIN }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push_signed:n
      {
        \int_min:nn
          { \@@_forth_signed:N \l_@@_tmpa_int }
          { \@@_forth_signed:N \l_@@_tmpb_int }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{1+, 1-}
%   Increment or decrement the top of the stack.  Catch overflow by
%   making sure that the result is in \([-2^{24}, 2^{24}-1]\) and
%   calling the \texttt{push_signed} function.
%    \begin{macrocode}
\@@_forth_new_core:nn { 1+ }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push_signed:n
      { \l_@@_tmpa_int + 1 - \c_@@_forth_mod_int }
  }
\@@_forth_new_core:nn { 1- }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push_signed:n { \l_@@_tmpa_int - 1 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{-, +}
%   Get two integers from the data stack, sum or take the difference,
%   and push the result onto the stack.  The integers can be signed or
%   unsigned, but are given to us as unsigned values in \([0,
%   2^{24}-1]\), hence there is an ambiguity by \(2^{24}\).  The
%   difference of two unsigned values lies in \([-2^{24}+1, 2^{24}-1]\),
%   and can be brought back to \([0, 2^{24}-1]\) by adding \(2^{24}\) to
%   negative numbers, as \cs{@@_forth_push_signed:n} does.  The sum,
%   shifted by \(2^{24}\), lies in \([-2^{24}, 2^{24}-2]\), and is also
%   appropriate input for the \texttt{push_signed} function.
%    \begin{macrocode}
\@@_forth_new_core:nn { - }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push_signed:n
      { \l_@@_tmpa_int - \l_@@_tmpb_int }
  }
\@@_forth_new_core:nn { + }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push_signed:n
      {
        \l_@@_tmpa_int + \l_@@_tmpb_int
        - \c_@@_forth_mod_int
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{*}
%   Multiply two integers, then push the result (modulo \(2^{24}\)) onto
%   the stack.  To avoid \TeX{} overflow, we manipulate the numbers as
%   floating points, computing \(a\times b - 2^{24}\times\bigl\lfloor
%   a\times b / 2^{24}\bigr\rfloor\).
%    \begin{macrocode}
\@@_forth_new_core:nn { * }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push_fp_mod:n
      { \l_@@_tmpa_int * \l_@@_tmpb_int }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: division by zero?
% \begin{macro}[int]{/}
%   Pop two integers from the stack.  Perform symmetric division (using
%   the values as signed numbers), and push the (signed) result onto the
%   stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { / }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push_signed:n
      {
        \int_div_truncate:nn
          { \@@_forth_signed:N \l_@@_tmpa_int }
          { \@@_forth_signed:N \l_@@_tmpb_int }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{MOD}
%   Pop two signed integers from the stack.  Push the remainder of \(a\)
%   divided by \(b\) onto the stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { MOD }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push_signed:n
      {
        \int_mod:nn
          { \@@_forth_signed:N \l_@@_tmpa_int }
          { \@@_forth_signed:N \l_@@_tmpb_int }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{/MOD}
%   Get two signed integers from the stack, then perform the division,
%   and put the remainder, then the quotient, on the stack.  Both
%   quotient and remainder remain in the range \([-2^{23}, 2^{23}]\)
%   (the upper bound happens when computing \((-2^{23})/(-1)\)), and are
%   brought back to an unsigned form before pushing onto the stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { /MOD }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_set:Nn \l_@@_tmpa_int
      { \@@_forth_signed:N \l_@@_tmpa_int }
    \int_set:Nn \l_@@_tmpb_int
      { \@@_forth_signed:N \l_@@_tmpb_int }
    \@@_forth_push_signed:n
      { \int_mod:nn { \l_@@_tmpa_int } { \l_@@_tmpb_int } }
    \@@_forth_push_signed:n
      {
        \int_div_truncate:nn
          { \l_@@_tmpa_int } { \l_@@_tmpb_int }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{*/}
%   Pop three signed integers from the stack and compute \(a\times b/c\)
%   using floating points.  The result is output, after rounding towards
%   zero and reducing its range in case of overflow.
%    \begin{macrocode}
\@@_forth_new_core:nn { */ }
  {
    \@@_forth_pop_int:NNN
      \l_@@_tmpa_int \l_@@_tmpb_int \l_@@_tmpc_int
    \@@_forth_push_fp_mod:n
      {
        \@@_forth_signed:N \l_@@_tmpa_int
        * \@@_forth_signed:N \l_@@_tmpb_int
        / \@@_forth_signed:N \l_@@_tmpc_int
      }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: bug because of double rounding (also applies to */).
% ^^A Later, fp will provide mod.
% \begin{macro}[aux]{\@@_forth_push_remquo:nNN}
%   Given a (possibly large) integer expression |#1|, an integer |#2|,
%   and a rounding direction |0| or |-|, compute using floating points
%   the integer quotient and remainder of dividing |#1| by |#2|.
%   Rounding toward~\(0\) gives symmetric division.  Rounding
%   towards~\(-\infty\) gives floored division.  The results are pushed
%   onto the stack, first the remainder, then the quotient.  Using the
%   \texttt{fp_mod} pushing function protects against
%   overflow/underflow, and takes care of putting signed results back
%   into unsigned form.  This auxiliary is used by |FM/MOD|, |SM/REM|,
%   |UM/MOD|, |*/MOD|, |M*|, and |UM*|.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_push_remquo:nNN #1#2#3
  {
    \fp_set:Nn \l_@@_tmpa_fp { round #3 ( (#1) / #2 ) }
    \@@_forth_push_fp_mod:n { #1 - #2 * \l_@@_tmpa_fp }
    \@@_forth_push_fp_mod:n { \l_@@_tmpa_fp }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{M*, UM*}
%   Pop two signed or unsigned integers from the stack, then split the
%   product into the quotient by \cs{c_@@_forth_mod_int} and its
%   remainder (using floored division).  This is done by
%   \cs{@@_forth_push_remquo:nNN}, which pushes the remainder and the
%   quotient onto the stack, in the expected order.
%    \begin{macrocode}
\@@_forth_new_core:nn { M* }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_set:Nn \l_@@_tmpa_int
      { \@@_forth_signed:N \l_@@_tmpa_int }
    \int_set:Nn \l_@@_tmpb_int
      { \@@_forth_signed:N \l_@@_tmpb_int }
    \@@_forth_push_remquo:nNN
      { \l_@@_tmpa_int * \l_@@_tmpb_int } \c_@@_forth_mod_int -
  }
\@@_forth_new_core:nn { UM* }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push_remquo:nNN
      { \l_@@_tmpa_int * \l_@@_tmpb_int } \c_@@_forth_mod_int -
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{FM/MOD, SM/REM, UM/MOD}
% \begin{macro}[aux]{\@@_forth_mslash:NN}
%   The auxiliary pops a cell \(c\) and a cell pair \((a,b)\) from the
%   stack.  First convert to signed integers if needed (for the cell
%   pair, this only affects the leading cell \(b\)).  Then push the
%   remainder and quotient of dividing the value \(a + b \cdot 2^{24}\)
%   of the cell pair by \(c\), rounding towards \(-\infty\) for floored
%   division (|FM/MOD| and |UM/MOD|) and towards \(0\) for symmetric
%   division (|SM/REM|).
%    \begin{macrocode}
\@@_forth_new_core:nn { FM/MOD }
  { \@@_forth_mslash:NN \@@_forth_signed:N - }
\@@_forth_new_core:nn { SM/REM }
  { \@@_forth_mslash:NN \@@_forth_signed:N 0 }
\@@_forth_new_core:nn { UM/MOD }
  { \@@_forth_mslash:NN \prg_do_nothing: - }
\cs_new_protected:Npn \@@_forth_mslash:NN #1#2
  {
    \@@_forth_pop_int:NNN
      \l_@@_tmpa_int \l_@@_tmpb_int \l_@@_tmpc_int
    \int_set:Nn \l_@@_tmpb_int { #1 \l_@@_tmpb_int }
    \int_set:Nn \l_@@_tmpc_int { #1 \l_@@_tmpc_int }
    \@@_forth_push_remquo:nNN
      {
        \l_@@_tmpa_int
        + \l_@@_tmpb_int * \c_@@_forth_mod_int
      }
      \l_@@_tmpc_int #2
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{*/MOD}
%   Pop three signed integers from the stack, and use
%   \cs{@@_forth_push_remquo:nNN} to evaluate the remainder and quotient
%   of the symmetric division \((a\times b) / c\).
%    \begin{macrocode}
\@@_forth_new_core:nn { */MOD }
  {
    \@@_forth_pop_int:NNN
      \l_@@_tmpa_int \l_@@_tmpb_int \l_@@_tmpc_int
    \int_set:Nn \l_@@_tmpa_int
      { \@@_forth_signed:N \l_@@_tmpa_int }
    \int_set:Nn \l_@@_tmpb_int
      { \@@_forth_signed:N \l_@@_tmpb_int }
    \int_set:Nn \l_@@_tmpc_int
      { \@@_forth_signed:N \l_@@_tmpc_int }
    \@@_forth_push_remquo:nNN
      { \l_@@_tmpa_int * \l_@@_tmpb_int } \l_@@_tmpc_int 0
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{DABS}
%   If the cell pair \((a,b)\) has \(b < 2^{23}\), it represents a
%   positive number and we push \((a,b)\).  Otherwise, we first change
%   the sign of \((a,b)\) with the \texttt{double_negate} function,
%   before pushing.
%   \begin{macrocode}
\@@_forth_new_core:nn { DABS }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_compare:nNnF
      \l_@@_tmpb_int < { \c_@@_forth_mod_int / \c_two }
      { \@@_forth_double_negate:NN \l_@@_tmpa_int \l_@@_tmpb_int }
    \@@_forth_push:nn { \l_@@_tmpa_int } { \l_@@_tmpb_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{DNEGATE}
%   See the \texttt{double_negate} function.
%   \begin{macrocode}
\@@_forth_new_core:nn { DNEGATE }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_double_negate:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push:nn \l_@@_tmpa_int \l_@@_tmpb_int
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{D+}
%   Pop \((a,b)\) and \((c,d)\).  Compute \(a' = a + c - 2^{14}\) and
%   \(b' = b + d - 2^{14} + \text{carry}\), where the carry is \(1\) if
%   \(a'\geq 0\).  Push \(a'\in[-2^{24},2^{24}-1]\) and
%   \(b'\in[-2^{24},2^{24}-1]\), both reduced modulo \(2^{24}\).
%    \begin{macrocode}
\@@_forth_new_core:nn { D+ }
  {
    \@@_forth_pop_int:NNNN
      \l_@@_tmpa_int \l_@@_tmpb_int
      \l_@@_tmpc_int \l_@@_tmpd_int
    \int_add:Nn \l_@@_tmpa_int
      { \l_@@_tmpc_int - \c_@@_forth_mod_int }
    \int_add:Nn \l_@@_tmpb_int
      {
        \l_@@_tmpd_int - \c_@@_forth_mod_int
        \int_compare:nNnF \l_@@_tmpa_int < \c_zero { + \c_one }
      }
    \@@_forth_push_signed:n { \l_@@_tmpa_int }
    \@@_forth_push_signed:n { \l_@@_tmpb_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{D-}
%   Pop \((a,b)\) and \((c,d)\).  Compute \(a' = a - c\) and \(b' = b -
%   d + \text{carry}\), where the carry is \(-1\) if \(a' < 0\).  Push
%   \(a'\in[-2^{24},2^{24}-1]\) and \(b'\in[-2^{24},2^{24}-1]\), both
%   reduced modulo \(2^{24}\).
%    \begin{macrocode}
\@@_forth_new_core:nn { D- }
  {
    \@@_forth_pop_int:NNNN
      \l_@@_tmpa_int \l_@@_tmpb_int
      \l_@@_tmpc_int \l_@@_tmpd_int
    \int_sub:Nn \l_@@_tmpa_int \l_@@_tmpc_int
    \int_sub:Nn \l_@@_tmpb_int
      {
        \l_@@_tmpd_int
        \int_compare:nNnT \l_@@_tmpa_int < \c_zero { + \c_one }
      }
    \@@_forth_push_signed:n { \l_@@_tmpa_int }
    \@@_forth_push_signed:n { \l_@@_tmpb_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{M+}
%   Pop \((a,b)\) and the signed \(c\).  Push \(a+c\) modulo \(2^{24}\)
%   by feeding \(a' = a + c - 2^{24} \in [-2^{24}, 2^{24}-1]\) to
%   \texttt{push_signed}.  Since \(c\) is signed, we must subtract \(1\)
%   from \(b\) when \(c\in [2^{23},2^{24}-1]\).  The carry of \(a + c\)
%   is \(b\to b+1\) if \(a'\geq 0\), but we use \(1-2^{24}\) as a carry
%   instead, ensuring that the argument of \texttt{push_signed} is in
%   \([-2^{24},2^{24}-1]\) in all cases.
%    \begin{macrocode}
\@@_forth_new_core:nn { M+ }
  {
    \@@_forth_pop_int:NNN
      \l_@@_tmpa_int \l_@@_tmpb_int \l_@@_tmpc_int
    \int_add:Nn \l_@@_tmpa_int
      { \l_@@_tmpc_int - \c_@@_forth_mod_int }
    \@@_forth_push_signed:n { \l_@@_tmpa_int }
    \@@_forth_push_signed:n
      {
        \l_@@_tmpb_int
        - \l_@@_tmpc_int / \c_@@_forth_mod_int
        \int_compare:nNnF \l_@@_tmpa_int < \c_zero
          { + \c_one - \c_@@_forth_mod_int }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{M*/}
%   Pop a signed double-cell integer \(a + 2^{24} b\), and two signed
%   single-cell integers \(c\) and \(d\).  We first change \((a,b)\) and
%   \(c\) to their absolute value, changing the sign of \(d\)
%   accordingly.  At this point, \(a\in[0,2^{24}-1]\) and
%   \(b,c\in[0,2^{23}-1]\).  We then perform the Euclidean divisions \(b
%   c = q d + r\) (with \(r\in[0,|d|-1]\)) and \(2^{24} r + a c = s d +
%   t\) (where \(s\geq 0\) and \(t\in[0,|d|-1]\), or \(s\leq 0\) and
%   \(t\in[-|d|+1,0]\)).  From those Euclidean divisions, we get that
%   \((2^{24}b+a)c = 2^{24} q d + s d + t\), hence the desired result is
%   \(s + 2^{24} q\).  The first step in computing this result is to
%   store the integer \(q = \lfloor b c / d \rfloor\) as
%   \cs{l_@@_tmpa_fp}.  Then set \cs{l_@@_tmpb_fp} to be the (integer)
%   \(s\) obtained by rounding \((2^{24} (b c - q d) + a c) / d\)
%   towards zero.  The integer \(s\) may be larger than \(2^{24}\), or
%   negative, so we take care of the carry (rounding towards \(-\infty\)
%   ensures that what remains is in \([0,2^{24}-1]\)).
%   ^^A todo: redoc.
%    \begin{macrocode}
\@@_forth_new_core:nn { M*/ }
  {
    \@@_forth_pop_int:NNNN
      \l_@@_tmpa_int \l_@@_tmpb_int
      \l_@@_tmpc_int \l_@@_tmpd_int
    \@@_forth_set_signed:N \l_@@_tmpd_int
    \int_compare:nNnF \l_@@_tmpb_int < { \c_@@_forth_mod_int / \c_two }
      {
        \@@_forth_double_negate:NN
          \l_@@_tmpa_int \l_@@_tmpb_int
        \int_set:Nn \l_@@_tmpd_int { - \l_@@_tmpd_int }
      }
    \int_compare:nNnF \l_@@_tmpc_int < { \c_@@_forth_mod_int / \c_two }
      {
        \int_set:Nn \l_@@_tmpc_int
          { \c_@@_forth_mod_int - \l_@@_tmpc_int }
        \int_set:Nn \l_@@_tmpd_int { - \l_@@_tmpd_int }
      }
    \fp_set:Nn \l_@@_tmpa_fp
      {
        \int_compare:nNnTF \l_@@_tmpd_int < \c_zero
          { round+ } { round- }
          ( \l_@@_tmpb_int * \l_@@_tmpc_int / \l_@@_tmpd_int )
      }
    \fp_set:Nn \l_@@_tmpb_fp
      {
        round0 ( ( \l_@@_tmpa_int * \l_@@_tmpc_int
          + \c_@@_forth_mod_int * ( \l_@@_tmpb_int * \l_@@_tmpc_int
          - \l_@@_tmpa_fp * \l_@@_tmpd_int ) ) / \l_@@_tmpd_int )
      }
    \@@_forth_push_fp_mod:n { \l_@@_tmpb_fp }
    \@@_forth_push_fp_mod:n
      {
        \l_@@_tmpa_fp
        + round- ( \l_@@_tmpb_fp / \c_@@_forth_mod_int )
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Bit operations}
%
% This section defines the words |2*|, |2/|, |AND|, |OR|,
% |XOR|, |INVERT|, |LSHIFT|, |RSHIFT|, |D2/|, |D2*|.
%
% \begin{macro}[int]{2*, 2/}
%   Multiply or divide the top of the stack by~\(2\).  For
%   multiplication, subtract \(2^{24}\) to get the result in the range
%   \([-2^{24}, 2^{24}-2]\), then call the \texttt{push_signed}
%   function.  For division, \((a+1)/2-1\) is rounded to \(\lfloor
%   a/2\rfloor\), and the sign bit is propagated.
%    \begin{macrocode}
\@@_forth_new_core:nn { 2* }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push_signed:n
      { \l_@@_tmpa_int * 2 - \c_@@_forth_mod_int }
  }
\@@_forth_new_core:nn { 2/ }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:n
      {
        ( \l_@@_tmpa_int + \c_one ) / \c_two - \c_one
        + \@@_forth_sign_mask:N \l_@@_tmpa_int
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{AND, OR, XOR}
%   Pop two unsigned integers from the stack, evaluate the appropriate
%   bitwise logical operator using a \pkg{runner} auxiliary, and push
%   the (unsigned) result back onto the stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { AND }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_bit_and:NNN
      \l_@@_tmpc_int \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push:n { \l_@@_tmpc_int }
  }
\@@_forth_new_core:nn { OR }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_bit_or:NNN
      \l_@@_tmpc_int \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push:n { \l_@@_tmpc_int }
  }
\@@_forth_new_core:nn { XOR }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_bit_xor:NNN
      \l_@@_tmpc_int \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push:n { \l_@@_tmpc_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{INVERT}
%   Logical inversion amounts to \(x \to -1-x\).
%    \begin{macrocode}
\@@_forth_new_core:nn { INVERT }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:n
      { \c_@@_forth_mod_int - \l_@@_tmpa_int - \c_one }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{LSHIFT}
%   The function \cs{@@_bit_lshift:NN} can return arbitrary non-negative
%   \TeX{} integers, and we take the residue modulo \(2^{24}\).
%    \begin{macrocode}
\@@_forth_new_core:nn { LSHIFT }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_bit_lshift:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push_mod:n { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{RSHIFT}
%   The function \cs{@@_bit_rshift:NN} repeatedly does floored division
%   by \(2\).
%    \begin{macrocode}
\@@_forth_new_core:nn { RSHIFT }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_bit_rshift:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push:n { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{D2/, D2*}
%   For |D2*|, we mostly double each integer and push the result back
%   onto the stack.  If \(2a\geq 2^{24}\), propagate the highest bit as
%   the lowest bit of \(b\).  The highest bit of~\(2b\) is ignored by
%   subtracting \(2^{24}\) to get a number in \([-2^{24}, 2^{24}-1]\),
%   then calling \texttt{push_signed}.  The right shift (|D2/|) is based
%   on \eTeX{}'s rounding behaviour \((a+1)/2-1\to \lfloor a/2\rfloor\).
%   If \(b\) is odd, its low bit should become the high bit of \(a\),
%   and we do this by adding \(2^{24}\) prior to the division.  The sign
%   bit (highest bit) of~\(b\) is propagated just like for~|2/|.
%    \begin{macrocode}
\@@_forth_new_core:nn { D2/ }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_if_even:nF \l_@@_tmpb_int
      { \int_add:Nn \l_@@_tmpa_int \c_@@_forth_mod_int }
    \@@_forth_push:nn
      { ( \l_@@_tmpa_int + \c_one ) / \c_two - \c_one }
      {
        ( \l_@@_tmpb_int + \c_one ) / \c_two - \c_one
        + \@@_forth_sign_mask:N \l_@@_tmpb_int
      }
  }
\@@_forth_new_core:nn { D2* }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_set:Nn \l_@@_tmpa_int { \l_@@_tmpa_int * \c_two }
    \int_set:Nn \l_@@_tmpb_int { \l_@@_tmpb_int * \c_two }
    \int_compare:nNnTF \l_@@_tmpa_int < \c_@@_forth_mod_int
      { \@@_forth_push:n \l_@@_tmpa_int }
      {
        \@@_forth_push:n { \l_@@_tmpa_int - \c_@@_forth_mod_int }
        \int_incr:N \l_@@_tmpb_int
      }
    \@@_forth_push_signed:n
      { \l_@@_tmpb_int - \c_@@_forth_mod_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Case statements}
%
% This section defines the words |CASE|, |OF|, |ENDOF|, |ENDCASE|.
%
% \begin{macro}[int]{CASE}
%   Copy the current definition code to a safe place, and place \(4\)
%   (magic number for |CASE|) onto the control-flow stack.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { CASE }
  {
    \@@_forth_control_open:n { 4 }
    \seq_push:NV \l_@@_forth_def_code_seq \l_@@_forth_def_code_tl
    \tl_clear:N \l_@@_forth_def_code_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{OF}
%   Make sure the previous control-flow word was |CASE|, and leave that
%   item onto the control flow stack.  Place \(5\) onto the control-flow
%   stack.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { OF }
  {
    \@@_forth_control_if:nTF { 4 }
      {
        \@@_forth_control_open:n { 5 }
        \seq_push:NV \l_@@_forth_def_code_seq \l_@@_forth_def_code_tl
        \tl_clear:N \l_@@_forth_def_code_tl
      }
      { \@@_forth_abort:nx { misplaced } { OF } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{ENDOF}
% \begin{macro}[aux]{\@@_forth_compiled_of:n}
%   Make sure the previous control-flow word was |OF|.  Go back to the
%   previously built definition code, and append to it the
%   \texttt{compiled_of} function, with as its argument the code
%   collected between |OF| and |ENDOF|.  At run-time, compare the two
%   topmost items on the stack: if they are equal, break to the end of
%   the |CASE...ENDCASE| construct and perform the code for that
%   |OF...ENDOF| clause; otherwise push back the case element, for
%   comparisons with further |OF...ENDOF| clauses.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { ENDOF }
  {
    \@@_forth_control_close:nTF { 5 }
      {
        \tl_set_eq:NN \l_@@_tmpa_tl \l_@@_forth_def_code_tl
        \seq_pop:NN \l_@@_forth_def_code_seq \l_@@_forth_def_code_tl
        \@@_forth_def_code:x
          { \@@_forth_compiled_of:n { \l_@@_tmpa_tl } }
      }
      { \@@_forth_abort:nx { misplaced } { ENDOF } }
  }
\cs_new_protected:Npn \@@_forth_compiled_of:n #1
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_compare:nNnTF \l_@@_tmpa_int = \l_@@_tmpb_int
      { \@@_break:n {#1} }
      { \@@_forth_push:n \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% ^^A todo: test nested CASE...ENDCASE.
% \begin{macro}[int]{ENDCASE}
% \begin{macro}[aux]{\@@_forth_compiled_case:n}
%   An |ENDCASE| word should match with |CASE| (magic number \(4\) on
%   the control flow stack).  Restore the definition collected before
%   |CASE|, and append \texttt{compiled_case} with the code collected
%   within |CASE...ENDCASE| as its argument.  This function, performed
%   at run-time, simply sets up the necessary end-marker to allow
%   |OF...ENDOF| clauses to jump out of the |CASE...ENDCASE| block.  If
%   none of the clauses match, the case value is dropped before exiting.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { ENDCASE }
  {
    \@@_forth_control_close:nTF { 4 }
      {
        \tl_set_eq:NN \l_@@_tmpa_tl \l_@@_forth_def_code_tl
        \seq_pop:NN \l_@@_forth_def_code_seq \l_@@_forth_def_code_tl
        \@@_forth_def_code:x
          { \@@_forth_compiled_case:n { \l_@@_tmpa_tl } }
      }
      { \@@_forth_abort:nx { misplaced } { ENDCASE } }
  }
\cs_new_protected:Npn \@@_forth_compiled_case:n #1
  {
    #1
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_break_point:n { }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Comparisons}
%
% This section defines the words |FALSE|, |TRUE|, |0=|, |0<>|, |0<|,
% |0>|, |=|, |<>|, |U<|, |U>|, |<|, |>|, |WITHIN|, |?DUP|, |D0=|, |D0<|,
% |D=|, |D<|, |DU<|, |DMAX|, |DMIN|.
%
% \begin{macro}[int]{FALSE, TRUE}
%   Pushing a \texttt{true} or \texttt{false} flag to the stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { FALSE } { \@@_forth_push_false: }
\@@_forth_new_core:nn { TRUE } { \@@_forth_push_true: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{0=, 0<>}
% \begin{macro}[aux]{\@@_forth_eq_zero:TF}
%   Compare the top of stack with~\(0\).
%    \begin{macrocode}
\@@_forth_new_core:nn { 0= }
  { \@@_forth_eq_zero:TF \@@_forth_push_true: \@@_forth_push_false: }
\@@_forth_new_core:nn { 0<> }
  { \@@_forth_eq_zero:TF \@@_forth_push_false: \@@_forth_push_true: }
\cs_new_protected_nopar:Npn \@@_forth_eq_zero:TF
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \int_compare:nNnTF \l_@@_tmpa_int = \c_zero
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{0<, 0>}
% \begin{macro}[aux]{\@@_forth_cmp_zero:N}
%   Compare the (signed) top of stack with~\(0\).
%    \begin{macrocode}
\@@_forth_new_core:nn { 0< }
  { \@@_forth_cmp_zero:N < }
\@@_forth_new_core:nn { 0> }
  { \@@_forth_cmp_zero:N > }
\cs_new_protected:Npn \@@_forth_cmp_zero:N #1
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \int_compare:nNnTF
      { \@@_forth_signed:N \l_@@_tmpa_int } #1 \c_zero
      { \@@_forth_push_true: } { \@@_forth_push_false: }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{=, <>}
% \begin{macro}[aux]{\@@_forth_eq:TF}
%   Compare the two tops of stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { = }
  { \@@_forth_eq:TF \@@_forth_push_true: \@@_forth_push_false: }
\@@_forth_new_core:nn { <> }
  { \@@_forth_eq:TF \@@_forth_push_false: \@@_forth_push_true: }
\cs_new_protected:Npn \@@_forth_eq:TF
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_compare:nNnTF \l_@@_tmpa_int = \l_@@_tmpb_int
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{U<, U>, <, >}
% \begin{macro}[aux]{\@@_forth_cmp:Nn}
%   Signed or unsigned comparisons.
%    \begin{macrocode}
\@@_forth_new_core:nn { U< } { \@@_forth_cmp:Nn < { } }
\@@_forth_new_core:nn { U> } { \@@_forth_cmp:Nn > { } }
\@@_forth_new_core:nn { < }
  { \@@_forth_cmp:Nn < \@@_forth_signed:N }
\@@_forth_new_core:nn { > }
  { \@@_forth_cmp:Nn > \@@_forth_signed:N }
\cs_new_protected:Npn \@@_forth_cmp:Nn #1#2
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_compare:nNnTF
      { #2 \l_@@_tmpa_int } #1 { #2 \l_@@_tmpb_int }
      { \@@_forth_push_true: }
      { \@@_forth_push_false: }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{WITHIN}
%   Push \texttt{true} if \(b\leq a < c\) or \(c < b \leq a\) or \(a < c
%   < b\); otherwise push \texttt{false}.
%    \begin{macrocode}
\@@_forth_new_core:nn { WITHIN }
  {
    \@@_forth_pop_int:NNN
      \l_@@_tmpa_int \l_@@_tmpb_int \l_@@_tmpc_int
    \bool_if:nTF
      {
        \int_compare_p:n
          { \l_@@_tmpb_int <= \l_@@_tmpa_int < \l_@@_tmpc_int }
        ||
        \int_compare_p:n
          { \l_@@_tmpc_int < \l_@@_tmpb_int <= \l_@@_tmpa_int }
        ||
        \int_compare_p:n
          { \l_@@_tmpa_int < \l_@@_tmpc_int < \l_@@_tmpb_int }
      }
      { \@@_forth_push_true: }
      { \@@_forth_push_false: }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: optimize
% \begin{macro}[int]{?DUP}
%   Duplicate top of stack if non-zero.
%    \begin{macrocode}
\@@_forth_new_core:nn { ?DUP }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:n { \l_@@_tmpa_int }
    \int_compare:nNnF \l_@@_tmpa_int = \c_zero
      { \@@_forth_push:n { \l_@@_tmpa_int } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{D0=, D0<}
%   A cell pair \((a,b)\) is zero if both \(a\) and \(b\) vanish.  Since
%   they are non-negative, this is equivalent to asking for \(a+b=0\).
%   The cell pair is negative if \(b\geq 2^{23}\).
%    \begin{macrocode}
\@@_forth_new_core:nn { D0= }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_compare:nNnTF
      { \l_@@_tmpa_int + \l_@@_tmpb_int } = \c_zero
      { \@@_forth_push_true: }
      { \@@_forth_push_false: }
  }
\@@_forth_new_core:nn { D0< }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_compare:nNnTF
      \l_@@_tmpb_int < { \c_@@_forth_mod_int / \c_two }
      { \@@_forth_push_false: }
      { \@@_forth_push_true: }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{D=}
%   Cell pairs are equal if both of their components match.
%    \begin{macrocode}
\@@_forth_new_core:nn { D= }
  {
    \@@_forth_pop_int:NNNN
      \l_@@_tmpa_int \l_@@_tmpb_int
      \l_@@_tmpc_int \l_@@_tmpd_int
    \int_compare:nNnTF \l_@@_tmpa_int = \l_@@_tmpc_int
      {
        \int_compare:nNnTF \l_@@_tmpb_int = \l_@@_tmpd_int
          { \@@_forth_push_true: }
          { \@@_forth_push_false: }
      }
      { \@@_forth_push_false: }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{D<, DU<, DMAX, DMIN}
% \begin{macro}[aux]{\@@_forth_double_cmp:Nnn}
%   Compare two signed or unsigned double-cell numbers \((a,b)\) and
%   \((c,d)\).  The value of such a double-cell is \(a + b\cdot 2^{24}\)
%   if \(b\in[0,2^{23}-1]\) and \(a + (b - 2^{24})\cdot 2^{24}\)
%   otherwise.  The order is equivalent to lexicographical order, using
%   signed comparison for the top cells \(b\) and \(d\), and then
%   unsigned comparison for \(a\) and \(c\).  Here, \(e\) holds the
%   difference of signed (or unsigned) numbers \(s(b) - s(d)\), in order
%   to do several comparisons in a row.
%    \begin{macrocode}
\@@_forth_new_core:nn { D< }
  {
    \@@_forth_double_cmp:Nnn \@@_forth_signed:N
      \@@_forth_push_true:
      \@@_forth_push_false:
  }
\@@_forth_new_core:nn { DU< }
  {
    \@@_forth_double_cmp:Nnn \prg_do_nothing:
      \@@_forth_push_true:
      \@@_forth_push_false:
  }
\@@_forth_new_core:nn { DMAX }
  {
    \@@_forth_double_cmp:Nnn \@@_forth_signed:N
      { \@@_forth_push:nn \l_@@_tmpc_int \l_@@_tmpd_int }
      { \@@_forth_push:nn \l_@@_tmpa_int \l_@@_tmpb_int }
  }
\@@_forth_new_core:nn { DMIN }
  {
    \@@_forth_double_cmp:Nnn \@@_forth_signed:N
      { \@@_forth_push:nn \l_@@_tmpa_int \l_@@_tmpb_int }
      { \@@_forth_push:nn \l_@@_tmpc_int \l_@@_tmpd_int }
  }
\cs_new_protected:Npn \@@_forth_double_cmp:Nnn #1#2#3
  {
    \@@_forth_pop_int:NNNN
      \l_@@_tmpa_int \l_@@_tmpb_int
      \l_@@_tmpc_int \l_@@_tmpd_int
    \int_set:Nn \l_@@_tmpe_int
      { #1 \l_@@_tmpb_int - #1 \l_@@_tmpd_int }
    \int_compare:nNnTF { \l_@@_tmpe_int } < \c_zero
      {#2}
      {
        \int_compare:nNnTF { \l_@@_tmpe_int } = \c_zero
          {
            \int_compare:nNnTF \l_@@_tmpa_int < \l_@@_tmpc_int
              {#2} {#3}
          }
          {#3}
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Control-flow words}
%
% This section defines the words |IF|, |ELSE|, |THEN|, |BEGIN|, |AGAIN|,
% |UNTIL|, |WHILE|, |REPEAT|.
%
% \begin{variable}{\l_@@_forth_flow_int}
%   This integer labels destinations (and origins) for control flow.  It
%   is never reset, hence limiting the total number of distinct control
%   flow locations (in all words defined) to \(2^{31}-1\), which is more
%   than enough.
%    \begin{macrocode}
\int_new:N \l_@@_forth_flow_int
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]
%   {\@@_forth_flow_forward:n, \@@_forth_flow_back:nn, \@@_forth_flow_dest:w}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_flow_forward:n #1
  {
    \cs_set:Npn \@@_tmp:w ##1 \@@_forth_flow_dest:w #1 . { }
    \@@_tmp:w
  }
\cs_new_protected:Npn \@@_forth_flow_back:nn #1#2
  {
    \cs_set:Npn \@@_tmp:w ##1 \@@_forth_flow_dest:w #1 . { }
    \@@_forth_exit:n
      {
        \exp_after:wN \@@_tmp:w
          \tex_the:D \tex_toks:D #2 \@@_forth_exit_point:
      }
  }
\cs_new_protected:Npn \@@_forth_flow_dest:w #1 . { }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\@@_forth_if_tos:F}
%   Run the argument (typically a jump) if the top-of-stack is zero, and
%   pop the top of stack in the process.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_if_tos:F
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \int_compare:nNnT \l_@@_tmpa_int = \c_zero
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{IF}
%   Add onto the control-flow stack an origin, labeled by a new value of
%   the \texttt{flow} integer.  Add to the current definition some code
%   that will jump to the destination if the top of stack is zero.  This
%   jump is safe because the definition can only be performed if all
%   items above the~\(0\) in the control-flow stack have been popped,
%   including the number \texttt{flow}.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { IF }
  {
    \int_incr:N \l_@@_forth_flow_int
    \seq_push:NV \l_@@_forth_control_seq \l_@@_forth_flow_int
    \@@_forth_def_code:x
      {
        \@@_forth_if_tos:F
          {
            \@@_forth_flow_forward:n
              { \int_use:N \l_@@_forth_flow_int }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{ELSE}
%   The word |ELSE| can only be used if the top of the control-flow
%   stack is an origin (positive integer).  Add to the current
%   definition an unconditional jump to a new (future) destination, and
%   push it onto the control-flow stack.  Then add a destination
%   matching the origin \texttt{tmpa} that was previously on the stack.
%   The order is important.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { ELSE }
  {
    \seq_pop:NNF \l_@@_forth_control_seq \l_@@_tmpa_tl
      { \@@_forth_abort:nx { misplaced } { ELSE } }
    \int_compare:nNnF \l_@@_tmpa_tl > \c_zero
      { \@@_forth_abort:nx { misplaced } { ELSE } }
    \int_incr:N \l_@@_forth_flow_int
    \seq_push:NV \l_@@_forth_control_seq \l_@@_forth_flow_int
    \@@_forth_def_code:x
      {
        \@@_forth_flow_forward:n
          { \int_use:N \l_@@_forth_flow_int }
        \@@_forth_flow_dest:w \l_@@_tmpa_tl .
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{THEN}
%   The word |THEN| can only be used if the top of the control-flow
%   stack is an origin (positive integer).  Add to the current
%   definition a destination matching the origin \texttt{tmpa}.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { THEN }
  {
    \seq_pop:NNF \l_@@_forth_control_seq \l_@@_tmpa_tl
      { \@@_forth_abort:nx { misplaced } { THEN } }
    \int_compare:nNnF \l_@@_tmpa_tl > \c_zero
      { \@@_forth_abort:nx { misplaced } { THEN } }
    \@@_forth_def_code:x
      { \@@_forth_flow_dest:w \l_@@_tmpa_tl . }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{BEGIN}
%   Add in the current definition a destination, labeled by a new value
%   of the \texttt{flow} integer.  Also push it onto the control-flow
%   stack, with a negative sign to indicate a backward flow.  The
%   consumer of this destination (|REPEAT| or |UNTIL|) then adds to the
%   definition a backwards jump to that destination.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { BEGIN }
  {
    \int_incr:N \l_@@_forth_flow_int
    \seq_push:Nx \l_@@_forth_control_seq
      { \int_eval:n { - \l_@@_forth_flow_int } }
    \@@_forth_def_code:x
      { \@@_forth_flow_dest:w \int_use:N \l_@@_forth_flow_int . }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{AGAIN, UNTIL}
% \begin{macro}[aux]{\@@_forth_compile_again:nN}
%   The words |AGAIN| and |UNTIL| can only be used if the top of the
%   control-flow stack is a destination (negative integer).  Then add
%   code to the current definition that jumps to this destination.  The
%   execution token that is being defined is needed at run-time in order
%   to go back to \TeX{} code that is ``in the past''.  For |UNTIL|, the
%   jump happens if the top of stack is zero (\texttt{false}).
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { AGAIN }
  { \@@_forth_compile_again:nN { AGAIN } \use:n }
\@@_forth_new_compilation_core:nn { UNTIL }
  { \@@_forth_compile_again:nN { UNTIL } \@@_forth_if_tos:F }
\cs_new_protected:Npn \@@_forth_compile_again:nN #1#2
  {
    \seq_pop:NNF \l_@@_forth_control_seq \l_@@_tmpa_tl
      { \@@_forth_abort:nx { misplaced } {#1} }
    \int_compare:nNnF \l_@@_tmpa_tl < \c_zero
      { \@@_forth_abort:nx { misplaced } {#1} }
    \@@_forth_def_code:x
      {
        #2
          {
            \@@_forth_flow_back:nn
              { \int_eval:n { - \l_@@_tmpa_tl } }
              { \int_use:N \l_@@_forth_def_token_int }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{WHILE}
%   Find a destination on the stack.  Create a new origin, and put it
%   below the destination in the control-flow stack.  Then add to the
%   current definition a conditional jump forwards to the destination of
%   the new origin.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { WHILE }
  {
    \seq_pop:NNF \l_@@_forth_control_seq \l_@@_tmpa_tl
      { \@@_forth_abort:nx { misplaced } { WHILE } }
    \int_compare:nNnF \l_@@_tmpa_tl < \c_zero
      { \@@_forth_abort:nx { misplaced } { WHILE } }
    \int_incr:N \l_@@_forth_flow_int
    \seq_push:NV \l_@@_forth_control_seq \l_@@_forth_flow_int
    \seq_push:NV \l_@@_forth_control_seq \l_@@_tmpa_tl
    \@@_forth_def_code:x
      {
        \@@_forth_if_tos:F
          {
            \@@_forth_flow_forward:n
              { \int_use:N \l_@@_forth_flow_int }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: better tools to manipulate the control-flow stack
% \begin{macro}[int]{REPEAT}
%   Find a destination and an origin on the stack.  Add to the current
%   definition an unconditional (backwards) jump to the destination (the
%   \texttt{flow_back} function needs to be aware of the execution token
%   being run), followed by the destination to which the origin
%   (typically |WHILE|, which exits the loop) will jump.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { REPEAT }
  {
    \seq_pop:NNF \l_@@_forth_control_seq \l_@@_tmpa_tl
      { \@@_forth_abort:nx { misplaced } { REPEAT } }
    \int_compare:nNnF \l_@@_tmpa_tl < \c_zero
      { \@@_forth_abort:nx { misplaced } { REPEAT } }
    \seq_pop:NNF \l_@@_forth_control_seq \l_@@_tmpb_tl
      { \@@_forth_abort:nx { misplaced } { REPEAT } }
    \int_compare:nNnF \l_@@_tmpb_tl > \c_zero
      { \@@_forth_abort:nx { misplaced } { REPEAT } }
    \@@_forth_def_code:x
      {
        \@@_forth_flow_back:nn
          { \int_eval:n { - \l_@@_tmpa_tl } }
          { \int_use:N \l_@@_forth_def_token_int }
        \@@_forth_flow_dest:w \l_@@_tmpb_tl .
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Defining words}
%
% This section defines the words |CONSTANT|, |2CONSTANT|, |CREATE|,
% |VARIABLE|, |2VARIABLE|, |>BODY|, |VALUE|, |TO|, |:NONAME|, |:|,
% |DOES>|, |;|, |IMMEDIATE|, |LITERAL|, |2LITERAL|, |MARKER|,
% |POSTPONE|, |[COMPILE]|, |RECURSE|, |COMPILE,|, |STATE|, |[|, |]|.
%
% \begin{macro}[int]{\@@_forth_def_code:x}
%   Add material to the definition.  Since all code is protected, and we
%   sometimes need to perform expansion, we only provide the expanding
%   variant.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_def_code:x #1
  { \tl_put_right:Nx \l_@@_forth_def_code_tl {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_@@_forth_last_created_int}
%   The address of the data field for the last |CREATE|d word.
%    \begin{macrocode}
\int_new:N \l_@@_forth_last_created_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_forth_def_name_str}
%   The last word that was defined: this is set just after the word's
%   meaning is changed, after the definition is fully read.
%    \begin{macrocode}
\tl_new:N \l_@@_forth_def_name_str
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{CONSTANT, 2CONSTANT}
%   The next word in the input buffer is defined to push the topmost
%   cell or cell pair.
%    \begin{macrocode}
\@@_forth_new_core:nn { CONSTANT }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_input_word_and_set:x
      { \@@_forth_push:n { \int_use:N \l_@@_tmpa_int } }
  }
\@@_forth_new_core:nn { 2CONSTANT }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_input_word_and_set:x
      {
        \@@_forth_push:nn
          { \int_use:N \l_@@_tmpa_int }
          { \int_use:N \l_@@_tmpb_int }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{CREATE, VARIABLE, 2VARIABLE}
% \begin{macro}[aux]{\@@_forth_create:}
%   The auxiliary reads the next word in the input buffer and defines it
%   to push the current value of |HERE|.  No space is allotted.  The
%   |VARIABLE| word additionally reserves one cell by putting |0| there
%   (actually putting a fixed value is unnecessary, but that is the
%   available auxiliary), and the |2VARIABLE| word reserves two cells.
%    \begin{macrocode}
\@@_forth_new_core:nn { CREATE }
  { \@@_forth_create: }
\@@_forth_new_core:nn { VARIABLE }
  {
    \@@_forth_create:
    \@@_forth_put_here:n { 0 }
  }
\@@_forth_new_core:nn { 2VARIABLE }
  {
    \@@_forth_create:
    \@@_forth_put_here:n { 0 }
    \@@_forth_put_here:n { 0 }
  }
\cs_new_protected_nopar:Npn \@@_forth_create:
  {
    \int_set_eq:NN \l_@@_forth_last_created_int
      \l_@@_forth_data_here_int
    \@@_forth_input_word_and_set:x
      {
        \@@_forth_push:n
          { \int_use:N \l_@@_forth_data_here_int }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{>BODY}
%   Pop execution token from the stack.  Hope that it has the form built
%   by |CREATE|: then the second item of its code (as a token list) is
%   an address, which we put onto the stack.  This is quite fragile.
%    \begin{macrocode}
\@@_forth_new_core:nn { >BODY }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \tl_set:Nx \l_@@_tmpa_tl
      { \tex_the:D \tex_toks:D \l_@@_tmpa_int }
    \tl_if_head_eq_meaning:VNF \l_@@_tmpa_tl \@@_forth_push:n
      { \@@_forth_abort:nx { not-created } { \int_use:N \l_@@_tmpa_int } }
    \@@_forth_push:n { \tl_item:Nn \l_@@_tmpa_tl \c_two }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{VALUE}
%   A value is implemented in a way similar to a variable, but with the
%   \texttt{push} function replaced by \texttt{push_value} to retrieve
%   the value at the given address.  Instead of storing~\(0\) like in
%   the case of |VARIABLE|, store the top of the stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { VALUE }
  {
    \@@_forth_input_word_and_set:x
      {
        \@@_forth_push_value:n
          { \int_use:N \l_@@_forth_data_here_int }
      }
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_put_here:n \l_@@_tmpa_int
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: reuse \cs{@@_forth_to:n} where applicable.
% ^^A todo: reuse \cs{@@_forth_push_value:n} where applicable.
% \begin{macro}[int]{TO}
% \begin{macro}[aux]{\@@_forth_to:n}
%   This word is state-smart.  Immediately read a word from the input,
%   then try to find it in the list of all words.  If it is found, make
%   sure that it is a variable by looking at the first token in the code
%   \texttt{tmpb} for its execution token \cs{tl_tail:N}
%   \cs{l_@@_tmpa_tl}.  This first token \texttt{push_value} is followed
%   by the address at which the value is stored, which we store in the
%   integer~\(a\).  Assuming that all of this worked, check the state.
%   In interpretation state, perform the auxiliary \texttt{forth_to}
%   command directly; otherwise place it in the definition code.  This
%   auxiliary pops the stack and stores that value into the given data
%   cell.
%    \begin{macrocode}
\@@_forth_new_immediate_core:nn { TO }
  {
    \@@_forth_input_word_xt:N \l_@@_tmpa_tl
    \tl_set:Nx \l_@@_tmpb_tl
      { \tex_the:D \tex_toks:D \tl_tail:N \l_@@_tmpa_tl }
    \tl_if_head_eq_meaning:VNTF
      \l_@@_tmpb_tl \@@_forth_push_value:n
      {
        \int_set:Nn \l_@@_tmpa_int
          { \tl_item:Nn \l_@@_tmpb_tl { 2 } }
        \token_if_eq_meaning:NNTF
          \@@_forth_perform:
          \@@_forth_interpret:
          { \exp_args:NV \@@_forth_to:n \l_@@_tmpa_int }
          {
            \@@_forth_def_code:x
              { \@@_forth_to:n { \int_use:N \l_@@_tmpa_int } }
          }
      }
      { \@@_forth_abort:nx { to-non-value } { } }
  }
\cs_new_protected:Npn \@@_forth_to:n #1
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_data_gset:nn {#1} { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{:NONAME, :}
% \begin{macro}[aux]{\@@_forth_colon:n}
%   Push onto the \texttt{def_after} stack some code to be performed
%   when the definition will take place (at the next |DOES>| or |;|),
%   possibly after reading a word in the input.  The |:NONAME| word
%   simply pushes the execution token, while the |:| word defines the
%   word just read to have execution semantics given by that execution
%   token.  Note that the \texttt{def_token} integer could be expanded
%   now (just after \texttt{forth_colon}), but it is unnecessary, as
%   this integer takes the correct value when |DOES>| or |;| is
%   encountered.  Save and empty the \texttt{def_code}, to get ready to
%   collect code.  Save the former \texttt{def_token}, and set it to a
%   new \texttt{token_int}.  Add the magic number~\(0\) to the control
%   stack to indicate that a definition is in progress.  Finally, start
%   compiling.
%    \begin{macrocode}
\@@_forth_new_core:nn { :NONAME }
  {
    \seq_push:Nn \l_@@_forth_def_after_seq
      { \@@_forth_push:n { \l_@@_forth_def_token_int } }
    \@@_forth_colon:
  }
\@@_forth_new_core:nn { : }
  {
    \@@_forth_input_word:
    \@@_forth_input_set_word:
    \seq_push:Nx \l_@@_forth_def_after_seq
      {
        \@@_forth_set_word_token:nn
          { \l_@@_forth_word_str }
          { \l_@@_forth_def_token_int }
      }
    \@@_forth_colon:
  }
\cs_new_protected_nopar:Npn \@@_forth_colon:
  {
    \seq_push:NV \l_@@_forth_def_code_seq \l_@@_forth_def_code_tl
    \tl_clear:N \l_@@_forth_def_code_tl
    \seq_push:NV \l_@@_forth_def_token_seq \l_@@_forth_def_token_int
    \int_set_eq:NN \l_@@_forth_def_token_int \l_@@_forth_token_int
    \int_incr:N \l_@@_forth_token_int
    \seq_push:Nn \l_@@_forth_control_seq { 0 }
    \@@_forth_state_to_compile:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{;}
%   Make sure that a definition is in progress (the \texttt{control}
%   stack starts with the magic number \(0\)), and indicate by
%   popping the \texttt{control} stack that the definition is done.
%   Then perform the \texttt{def_after} code, which either pushes the
%   execution token or sets the word that followed~|:| equal to it.  The
%   \texttt{def_code} itself is then stored as that \texttt{def_token}
%   execution token.  Restore the \texttt{def_code} that was being built
%   prior to~|:|, the \texttt{def_token}, and pop the \texttt{control}
%   stack.  Finally, resume interpretation.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { ; }
  {
    \seq_pop:NN \l_@@_forth_control_seq \l_@@_tmpa_tl
    \str_if_eq_x:nnF \l_@@_tmpa_tl { 0 }
      { \@@_forth_abort:nx { misplaced } { ; } }
    \seq_pop:NN \l_@@_forth_def_after_seq \l_@@_tmpa_tl
    \tl_use:N \l_@@_tmpa_tl
    \use:x
      {
        \tex_toks:D \l_@@_forth_def_token_int
          { \l_@@_forth_def_code_tl }
      }
    \seq_pop:NN \l_@@_forth_def_code_seq \l_@@_forth_def_code_tl
    \seq_pop:NN \l_@@_forth_def_token_seq \l_@@_tmpa_tl
    \int_set:Nn \l_@@_forth_def_token_int \l_@@_tmpa_tl
    \@@_forth_state_to_interpret:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{DOES>}
%   This word is implemented as a hybrid of |;| and~|:|.  Make sure that
%   the \texttt{control} stack starts with~\(0\) (definition in
%   progress): as we will remain within a definition, nothing is removed
%   from the \texttt{control} stack.  Perform the \texttt{def_after}
%   code, which can either push the \texttt{def_token} execution token
%   onto the stack (after |:NONAME|), tie it to a name (for |:|), or do
%   nothing (after another |DOES>|).  The next |DOES>| or |;| should do
%   nothing special to its execution token besides defining it, so we
%   push an empty item to the \texttt{def_after} stack.  Then store the
%   code that preceded |DOES>| as the \texttt{def_token} execution
%   token, together with a call to \texttt{compiled_does}, to which we
%   feed the value of a new execution token.  Then get ready to collect
%   the \texttt{def_code} (begins empty) for that new execution token,
%   whose number is stored as \texttt{def_token}.  Remain in compilation
%   mode.  Note that the definition of the word defined by |:| is
%   available after |DOES>| (since the code that introduces it was in
%   the \texttt{def_after} sequence), and that using |RECURSE| after
%   |DOES>| recurses on the word affected by |DOES>|.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { DOES> }
  {
    \seq_get:NN \l_@@_forth_control_seq \l_@@_tmpa_tl
    \str_if_eq_x:nnF \l_@@_tmpa_tl { 0 }
      { \@@_forth_abort:nx { misplaced } { DOES> } }
    \seq_pop:NN \l_@@_forth_def_after_seq \l_@@_tmpa_tl
    \tl_use:N \l_@@_tmpa_tl
    \seq_push:Nn \l_@@_forth_def_after_seq { }
    \use:x
      {
        \tex_toks:D \l_@@_forth_def_token_int
          {
            \l_@@_forth_def_code_tl
            \@@_forth_compiled_does:n
              { \int_use:N \l_@@_forth_token_int }
          }
      }
    \tl_clear:N \l_@@_forth_def_code_tl
    \int_set_eq:NN \l_@@_forth_def_token_int \l_@@_forth_token_int
    \int_incr:N \l_@@_forth_token_int
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\@@_forth_compiled_does:n}
%   At run-time, |DOES>| redefines the last word defined,
%   \texttt{def_name}, to do the following: push the address of the
%   data-field of the last word |CREATE|d, then perform the execution
%   token |#1|.  Note that the result is garbage if the last word
%   defined was not defined using |CREATE| (or |VARIABLE| or
%   |2VARIABLE|).  An additional subtlety is that we must preserve the
%   |IMMEDIATE| status of the word.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_compiled_does:n #1
  {
    \use:x
      {
        \tex_toks:D \l_@@_forth_token_int
          {
            \@@_forth_push:n
              { \int_use:N \l_@@_forth_last_created_int }
            \@@_forth_execute:n {#1}
          }
      }
    \prop_get:NVN \l_@@_forth_words_prop
      \l_@@_forth_def_name_str \l_@@_tmpa_tl
    \prop_put:Nxx \l_@@_forth_words_prop
      { \l_@@_forth_def_name_str }
      {
        \tl_head:N \l_@@_tmpa_tl
        \int_use:N \l_@@_forth_token_int
      }
    \int_incr:N \l_@@_forth_token_int
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: "CREATE foo ' foo EXECUTE" pushes a-addr on the stack.  Should it?
% ^^A todo: what if we tick a |CREATE|d word then apply |DOES>|?
%
% \begin{macro}[int]{IMMEDIATE}
%   Change to \(2\) (immediate) the flag (\(\in\{1,2,3\}\)) of the last
%   defined word.
%    \begin{macrocode}
\@@_forth_new_core:nn { IMMEDIATE }
  {
    \@@_forth_last_def_xt:N \l_@@_tmpa_tl
    \prop_put:Nxx
      \l_@@_forth_words_prop
      { \l_@@_forth_def_name_str }
      { 2 \tl_tail:N \l_@@_tmpa_tl }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{LITERAL, 2LITERAL}
%   The current top of stack cell or double-cell is stored in the
%   current definition: it will be pushed back onto the stack at
%   run-time.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { LITERAL }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_def_code:x
      { \@@_forth_push:n { \int_use:N \l_@@_tmpa_int } }
  }
\@@_forth_new_compilation_core:nn { 2LITERAL }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_def_code:x
      {
        \@@_forth_push:nn
          { \int_use:N \l_@@_tmpa_int }
          { \int_use:N \l_@@_tmpb_int }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: document use of LaTeX3 prop implementation quirk.
% \begin{macro}[int]{MARKER}
%    \begin{macrocode}
\@@_forth_new_core:nn { MARKER }
  {
    \@@_forth_input_word_and_set:x
      {
        \int_set:Nn \l_@@_forth_token_int
          { \int_use:N \l_@@_forth_token_int }
        \tl_set:Nn \exp_not:N \l_@@_forth_words_prop
          { \exp_not:V \l_@@_forth_words_prop }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{POSTPONE, [COMPILE]}
% \begin{macro}[aux, EXP]{\@@_forth_postpone:Nw}
%   Read a word from the input buffer.  Append its compilation semantics
%   to the current definition.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { POSTPONE }
  { \@@_forth_postpone:N \@@_forth_def_code:x }
\@@_forth_new_compilation_core:nn { [COMPILE] }
  { \@@_forth_postpone:N \use:n }
\cs_new_protected:Npn \@@_forth_postpone:N #1
  {
    \@@_forth_input_word_xt:N \l_@@_tmpa_tl
    \@@_forth_def_code:x { \@@_forth_perform_case:Nn #1 { + 1 } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{RECURSE}
%   Insert in the definition code that runs the execution token
%   \texttt{def_token} being defined.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { RECURSE }
  {
    \@@_forth_def_code:x
      {
        \@@_forth_execute:n
          { \int_use:N \l_@@_forth_def_token_int }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]+COMPILE,+
%   The execution token~\(a\) found on the stack is added to the current
%   definition.
%    \begin{macrocode}
\@@_forth_new_core:nn { COMPILE, }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_def_code:x
      { \@@_forth_execute:n { \int_use:N \l_@@_tmpa_int } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{STATE}
%   Push the address where the state is stored.
%    \begin{macrocode}
\@@_forth_new_core:nn { STATE }
  { \@@_forth_push:n { \l_@@_forth_state_address_int } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{[, ]}
%   Change state.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { [ }
  { \@@_forth_state_to_interpret: }
\@@_forth_new_immediate_core:nn { ] }
  { \@@_forth_state_to_compile: }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Do loops}
%
% This section defines |DO|, |?DO|, |LOOP|, |+LOOP|, |I|, |J|, |LEAVE|,
% |UNLOOP|.
%
% \begin{macro}[int]{DO, ?DO}
%   Save the definition-so-far, and empty the variable, then push to the
%   control-flow stack a flag indicating that a |DO| or a |?DO| is
%   unresolved (magic numbers \(6\) or \(7\)).
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { DO }
  {
    \@@_forth_control_open:n { 6 }
    \seq_push:NV \l_@@_forth_def_code_seq \l_@@_forth_def_code_tl
    \tl_clear:N \l_@@_forth_def_code_tl
  }
\@@_forth_new_compilation_core:nn { ?DO }
  {
    \@@_forth_control_open:n { 7 }
    \seq_push:NV \l_@@_forth_def_code_seq \l_@@_forth_def_code_tl
    \tl_clear:N \l_@@_forth_def_code_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{LOOP, +LOOP}
% \begin{macro}[aux]{\@@_forth_compile_loop:n}
%   Save the code of the loop body as \texttt{tmpa}, then restore the
%   definition as it was before the matching |DO| or |?DO|.  Finally,
%   append to the definition \texttt{compiled_do} or
%   \texttt{compiled_qdo}, with as its arguments the loop body, and the
%   code to step the loop counter.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { LOOP }
  {
    \@@_forth_compile_loop:n
      { \int_set_eq:NN \l_@@_tmpd_int \c_one }
  }
\@@_forth_new_compilation_core:nn { +LOOP }
  {
    \@@_forth_compile_loop:n
      {
        \@@_forth_pop_int:N \l_@@_tmpd_int
        \@@_forth_set_signed:N \l_@@_tmpd_int
      }
  }
\cs_new_protected:Npn \@@_forth_compile_loop:n #1
  {
    \@@_forth_control_close:nTF { 6 }
      {
        \tl_set_eq:NN \l_@@_tmpa_tl \l_@@_forth_def_code_tl
        \seq_pop:NN \l_@@_forth_def_code_seq \l_@@_forth_def_code_tl
        \@@_forth_def_code:x
          { \@@_forth_compiled_do:nnn { } { \l_@@_tmpa_tl } {#1} }
      }
      {
        \@@_forth_control_close:nTF { 7 }
          {
            \tl_set_eq:NN \l_@@_tmpa_tl \l_@@_forth_def_code_tl
            \seq_pop:NN \l_@@_forth_def_code_seq \l_@@_forth_def_code_tl
            \@@_forth_def_code:x
              { \@@_forth_compiled_qdo:nn { \l_@@_tmpa_tl } {#1} }
          }
          { \@@_forth_abort:nx { misplaced } { LOOP } }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% ^^A todo: optimize
% ^^A todo: now, this fails for i=-1, lim=0.
% ^^A todo: bug, with overflow of negative numbers.
% \begin{macro}[int]{\@@_forth_compiled_qdo:nn, \@@_forth_compiled_do:nnn}
% \begin{macro}[aux]{\@@_forth_compiled_do_aux:NN}
% ^^A todo: doc why this is correct.  The +mod is needed to make the result >=0
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_forth_compiled_qdo:nn
  {
    \@@_forth_compiled_do:nnn
      {
        \int_compare:nNnT
          \l_@@_tmpa_int = \l_@@_tmpb_int { \@@_break:n { } }
      }
  }
\cs_new_protected:Npn \@@_forth_compiled_do:nnn #1#2#3
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    #1
    \@@_forth_return_push:n { \l_@@_tmpa_int } % ^^A limit
    \@@_forth_return_push:n { \l_@@_tmpb_int } % ^^A index
    \bool_do_while:Nn \c_true_bool
      {
        #2
        \@@_forth_return_pop_int:N \l_@@_tmpb_int
        \@@_forth_return_pop_int:N \l_@@_tmpa_int
        #3
        \int_compare:nNnTF \l_@@_tmpd_int < \c_zero
          { \@@_forth_compiled_do_aux:NN \int_compare:nNnT - }
          { \@@_forth_compiled_do_aux:NN \int_compare:nNnF + }
        \@@_forth_return_push:n { \l_@@_tmpa_int }
        \@@_forth_return_push:n
          {
            \int_mod:nn
              { \c_@@_forth_mod_int + \l_@@_tmpb_int + \l_@@_tmpd_int }
              { \c_@@_forth_mod_int }
          }
      }
    \@@_forth_return_pop_int:N \l_@@_tmpb_int
    \@@_forth_return_pop_int:N \l_@@_tmpa_int
    \@@_break_point:n { }
  }
\cs_new_protected:Npn \@@_forth_compiled_do_aux:NN #1#2
  {
    \int_set:Nn \l_@@_tmpc_int
      { \l_@@_tmpa_int - \l_@@_tmpb_int }
    #1 \l_@@_tmpc_int > \c_zero
      { \int_add:Nn \l_@@_tmpc_int { #2 \c_@@_forth_mod_int } }
    #1 \l_@@_tmpc_int > \l_@@_tmpd_int { \@@_break:n { } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{I, J}
% \begin{macro}[aux]{\@@_forth_ij:N}
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { I }
  { \@@_forth_def_code:x { \@@_forth_ij:N 1 } }
\@@_forth_new_compilation_core:nn { J }
  { \@@_forth_def_code:x { \@@_forth_ij:N 3 } }
\cs_new_protected:Npn \@@_forth_ij:N #1
  {
    \@@_forth_push_value:n
      { \l_@@_forth_return_here_int - #1 }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{LEAVE}
%   Break the current loop, and remove the loop
%   control parameters from the return stack.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { LEAVE }
  {
    \@@_forth_def_code:x
      {
        \@@_break_protected:n
          {
            \@@_forth_return_pop_int:N \l_@@_tmpb_int
            \@@_forth_return_pop_int:N \l_@@_tmpa_int
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: doc that UNLOOP is allowed in interpretation mode.
% \begin{macro}[int]{UNLOOP}
%   Drop the loop control parameters from the return stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { UNLOOP }
  {
    \@@_forth_return_pop_int:N \l_@@_tmpa_int
    \@@_forth_return_pop_int:N \l_@@_tmpb_int
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Environmental queries}
%
% This section defines the words |PAD|, |ENVIRONMENT?|, and its
% associated data.
%
% \begin{macro}[int]{PAD}
%   Pushes on top of the stack the address of the pad area.
%    \begin{macrocode}
\@@_forth_new_core:nn { PAD }
  { \@@_forth_push:n { \g_@@_forth_pad_min_int } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{ENVIRONMENT?}
% \begin{macro}[aux]{\@@_forth_environment_aux:n}
%   Pop an address \(a\) and a length \(b\) from the stack, and extract
%   a comma-list of the values from \(a\) to \(a + b - 1\) inclusive
%   (the query string).  If that string matches any known one, return
%   the result and a true flag, otherwise return a false flag.
%    \begin{macrocode}
\@@_forth_new_core:nn { ENVIRONMENT? }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \prop_get:NxNTF \g_@@_forth_environment_prop
      {
        \int_step_function:nnnN
          { \l_@@_tmpa_int }
          { 1 }
          { \l_@@_tmpa_int + \l_@@_tmpb_int - 1 }
          \@@_forth_environment_aux:n
      }
      \l_@@_tmpa_tl
      {
        \l_@@_tmpa_tl
        \@@_forth_push_true:
      }
      {
        \@@_forth_push_false:
      }
  }
\cs_new:Npn \@@_forth_environment_aux:n #1
  { \@@_forth_data_get:n {#1} , }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{variable}{\g_@@_forth_environment_prop}
% \begin{macro}{\@@_forth_environment_def:nn}
%   Keys are known string, in the form of comma lists of their character
%   codes.  Currently, the following exist:
%   \begin{itemize}
%   \item ADDRESS-UNIT-BITS: 24
%   \item CORE: false
%   \item CORE-EXT: false
%   \item FLOORED: false
%   \item MAX-D: 8388607 and 16777215
%   \item MAX-N: 8388607
%   \item MAX-U: 16777215
%   \item MAX-UD: 16777215 and 16777215.
%   \end{itemize}
%   Values are the code that pushes the appropriate values to the stack.
%    \begin{macrocode}
\prop_new:N \g_@@_forth_environment_prop
\group_begin:
  \cs_set_protected:Npn \@@_forth_environment_def:nn #1#2
    {
      \prop_gput:Nxn \g_@@_forth_environment_prop
        { \tl_map_function:nN {#1} \@@_tmp:w }
        {#2}
    }
  \cs_set:Npn \@@_tmp:w #1 { \int_eval:n { `#1 } , }
  \@@_forth_environment_def:nn { ADDRESS-UNIT-BITS }
    { \@@_forth_push:n { 24 } }
  \@@_forth_environment_def:nn { CORE }
    { \@@_forth_push_false: }
  \@@_forth_environment_def:nn { CORE-EXT }
    { \@@_forth_push_false: }
  \@@_forth_environment_def:nn { FLOORED }
    { \@@_forth_push_false: }
  \@@_forth_environment_def:nn { MAX-D }
    {
      \@@_forth_push:n { 16777215 }
      \@@_forth_push:n { 8388607 }
    }
  \@@_forth_environment_def:nn { MAX-N }
    { \@@_forth_push:n { 8388607 } }
  \@@_forth_environment_def:nn { MAX-U }
    { \@@_forth_push:n { 16777215 } }
  \@@_forth_environment_def:nn { MAX-UD }
    {
      \@@_forth_push:n { 16777215 }
      \@@_forth_push:n { 16777215 }
    }
  \@@_forth_environment_def:nn { /HOLD }
    {
      \@@_forth_push:n
        { \g_@@_forth_picnum_max_int - \g_@@_forth_picnum_min_int }
    }
  \@@_forth_environment_def:nn { /PAD }
    {
      \@@_forth_push:n
        { \g_@@_forth_pad_max_int - \g_@@_forth_pad_min_int }
    }
  \@@_forth_environment_def:nn { RETURN-STACK-CELLS }
    {
      \@@_forth_push:n
        { \g_@@_forth_return_max_int - \g_@@_forth_return_min_int }
    }
  \@@_forth_environment_def:nn { STACK-CELLS }
    {
      \@@_forth_push:n
        { \g_@@_forth_stack_max_int - \g_@@_forth_stack_min_int }
    }
\group_end:
%    \end{macrocode}
% \end{macro}
% \end{variable}
%
% \subsubsection{Execution tokens}
%
% This section defines the words |'|, |[']|, |EXECUTE|, |FIND|.
%
% \begin{macro}[int]{'}
%   Push onto the data stack the execution token associated to a word
%   (read from the input).
%    \begin{macrocode}
\@@_forth_new_core:nn { ' }
  {
    \@@_forth_input_word_xt:N \l_@@_tmpa_tl
    \@@_forth_push:n { \tl_tail:N \l_@@_tmpa_tl }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{[']}
%   Read a word, find it in the dictionary (prop), and find its
%   execution token (the tail).  Then add to the current definition some
%   code to place this execution token on the stack.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { ['] }
  {
    \@@_forth_input_word_xt:N \l_@@_tmpa_tl
    \@@_forth_def_code:x
      { \@@_forth_push:n { \tl_tail:N \l_@@_tmpa_tl } }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: take (tmpa mod 2^16 or 2^15).
% \begin{macro}[int]{EXECUTE}
%   Pop from the data stack an execution token.  Perform it.
%    \begin{macrocode}
\@@_forth_new_core:nn { EXECUTE }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_execute:n { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{FIND}
%   Pop the address \(a\) of a counted string from the stack, and let
%   \(v\) be the value at \(a\) (length of the string).  The string
%   ranges from \(a+1\) to \(b = a+v\).  Go through these data cells,
%   appending the corresponding character to the \texttt{find_word}
%   string.
%    \begin{macrocode}
\@@_forth_new_core:nn { FIND }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \int_set:Nn \l_@@_forth_word_begin_int
      { \l_@@_tmpa_int + \c_one }
    \int_set:Nn \l_@@_forth_word_end_int
      {
        \l_@@_forth_word_begin_int
        + \@@_forth_data_get:n { \l_@@_tmpa_int }
      }
    \@@_forth_input_set_word:
    \prop_get:NVNF
      \l_@@_forth_words_prop
      \l_@@_forth_word_str
      \l_@@_tmpa_tl
      { \tl_set:Nn \l_@@_tmpa_tl { 3 } }
    \int_compare:nNnTF { \tl_head:N \l_@@_tmpa_tl } = { 3 }
      { \@@_forth_push:nn { \l_@@_tmpa_int } { 0 } }
      {
        \@@_forth_push:n { \tl_tail:N \l_@@_tmpa_tl }
        \int_compare:nNnTF { \tl_head:N \l_@@_tmpa_tl } = { 2 }
          { \@@_forth_push:n { 1 } }
          { \@@_forth_push_signed:n { -1 } }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Immediate conditionals}
%
% This section defines the words |[IF]|, |[THEN]|, |[ELSE]|.
%
% \begin{variable}{\l_@@_forth_if_int}
%   Nesting level of conditionals.
%    \begin{macrocode}
\int_new:N \l_@@_forth_if_int
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{[IF], [ELSE], [THEN]}
% \begin{macro}[aux]{\@@_forth_bracket_if:n}
%   |[IF]| jumps to the matching [ELSE] or [THEN] if the top of flag is
%   \texttt{false} (\(0\)).  |[ELSE]| jumps unconditionally to the
%   matching [THEN].  |[THEN]| does nothing.  This is done by repeatedly
%   getting words, until the \texttt{forth_if} integer, which keeps
%   track of nesting, becomes negative.  Each word is compared with the
%   words |[IF]| (increment nesting), |[ELSE]| (do nothing, or for
%   |[IF]| check that the nesting is non-zero), |[THEN]| (decrement
%   nesting).  An empty word marks the end of the line.
%    \begin{macrocode}
\@@_forth_new_immediate_core:nn { [IF] }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \int_compare:nNnT \l_@@_tmpa_int = \c_zero
      {
        \@@_forth_bracket_if:n
          {
            { [ELSE] }
              {
                \int_compare:nNnF \l_@@_forth_if_int > \c_zero
                  { \int_decr:N \l_@@_forth_if_int }
              }
          }
      }
  }
\@@_forth_new_immediate_core:nn { [ELSE] }
  { \@@_forth_bracket_if:n { } }
\@@_forth_new_immediate_core:nn { [THEN] } { }
\cs_new_protected:Npn \@@_forth_bracket_if:n #1
  {
    \int_zero:N \l_@@_forth_if_int
    \int_until_do:nNnn \l_@@_forth_if_int < \c_zero
      {
        \@@_forth_input_word:
        \@@_forth_input_set_word:
        \str_case:onn { \l_@@_forth_word_str }
          {
            { }
              {
                \@@_forth_refill:TF { }
                  { \int_set_eq:NN \l_@@_forth_if_int \c_minus_one }
              }
            {  [IF]  } { \int_incr:N \l_@@_forth_if_int }
            { [THEN] } { \int_decr:N \l_@@_forth_if_int }
            #1
          }
          { }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Input}
%
% This section defines |>IN|, |SOURCE|, |TIB|, |#TIB|, |CHAR|, |[CHAR]|,
% |(|, |\|, |PARSE|, |WORD|, |COUNT|, |S"|, |EVALUATE|, |ACCEPT|,
% |SOURCE-ID|, |REFILL|.  ^^A)
%
% \begin{macro}[int]{>IN}
%   Push the address where the input buffer offset is stored.
%    \begin{macrocode}
\@@_forth_new_core:nn { >IN }
  { \@@_forth_push:n { \l_@@_forth_in_address_int } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{SOURCE}
%   Push the address of the current input buffer, and the length of the
%   string stored there.
%    \begin{macrocode}
\@@_forth_new_core:nn { SOURCE }
  {
    \@@_forth_push:n { \l_@@_forth_source_begin_int }
    \@@_forth_push:n
      { \l_@@_forth_source_end_int - \l_@@_forth_source_begin_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{TIB}
%   Push the address of the terminal input buffer.
%    \begin{macrocode}
\@@_forth_new_core:nn { TIB }
  { \@@_forth_push:n { \g_@@_forth_term_min_int } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]+#TIB+
%   Store the size of the terminal input buffer into a designated cell
%   \texttt{tib_size_address}, then push this address onto the stack.
%    \begin{macrocode}
\exp_args:Nx \@@_forth_new_core:nn { \iow_char:N \# TIB }
  {
    \@@_forth_data_gset:nn
      { \l_@@_forth_tib_size_address_int }
      { \l_@@_forth_term_end_int - \g_@@_forth_term_min_int }
    \@@_forth_push:n { \l_@@_forth_tib_size_address_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{CHAR}
%   Read a word, leave its first character on the stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { CHAR }
  {
    \@@_forth_input_word:
    \@@_forth_push_value:n { \l_@@_forth_word_begin_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{[CHAR]}
%   Read a word, add code to the current definition that leaves its
%   first character on the stack.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { [CHAR] }
  {
    \@@_forth_input_word:
    \@@_forth_def_code:x
      {
        \@@_forth_push:n
          { \@@_forth_data_get:N \l_@@_forth_word_begin_int }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]+(+%^^A)
%   Comments are implemented by grabbing a piece of input delimited by a
%   right parenthesis, and not doing anything with it.  This is an
%   immediate word.
%    \begin{macrocode}
\@@_forth_new_immediate_core:nn (
  { \@@_forth_input_until:n { `) } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]+\\+
%   Parse until the end of the parse area, by setting |>IN| to its
%   maximal value.
%    \begin{macrocode}
\exp_args:Nx \@@_forth_new_immediate_core:nn { \iow_char:N \\ }
  {
    \@@_forth_data_gset:nn \l_@@_forth_in_address_int
      { \l_@@_forth_source_end_int - \l_@@_forth_source_begin_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{PARSE}
%   Get a character~\(a\) from the stack and read a word delimited
%   by~\(a\).  Then push the starting character and the length of the
%   word found.
%    \begin{macrocode}
\@@_forth_new_core:nn { PARSE }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_input_until:n { \l_@@_tmpa_int }
    \@@_forth_push:nn
      { \l_@@_forth_word_begin_int }
      { \l_@@_forth_word_end_int - \l_@@_forth_word_begin_int }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: avoid back-and-forth between TeX strings and Forth counted strings
% \begin{macro}[int]{WORD}
%   |WORD| stores its result starting at the \texttt{data_here} pointer,
%   so after popping the delimiter character~\(a\) from the stack, we
%   push \texttt{data_here} right away.  Set \texttt{data_word} to
%   \(\text{\texttt{data_here}}+1\), the address at which the first
%   character will be stored.  Find the \(a\)-delimited word, after
%   ignoring leading delimiters, and store the resulting string starting
%   at \texttt{data_word}.  The \texttt{store_interval} function updates this
%   pointer to just after the end of the word stored.  Store the
%   character count before the string.  Balk if we went out of bound.
%    \begin{macrocode}
\@@_forth_new_core:nn { WORD }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:n { \l_@@_forth_data_here_int }
    \int_set:Nn \l_@@_forth_data_word_int
      { \l_@@_forth_data_here_int + 1 }
    \@@_forth_input_discard:n { \l_@@_tmpa_int }
    \@@_forth_input_until:n { \l_@@_tmpa_int }
    \@@_forth_store_interval:NNN
      \l_@@_forth_word_begin_int
      \l_@@_forth_word_end_int
      \l_@@_forth_data_word_int
    \@@_forth_data_gset:nn
      { \l_@@_forth_data_here_int }
      { \l_@@_forth_data_word_int - \l_@@_forth_data_here_int - 1 }
    \int_compare:nNnT
      \l_@@_forth_data_word_int > \l_@@_forth_data_text_int
      { \@@_forth_abort:nx { out-of-memory } { } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{COUNT}
%   Convert the address of a counted string to its length (on top of the
%   stack), and the address of the first character.  This could be
%   defined with |: COUNT DUP CHAR+ SWAP @ ;| but this is faster.
%    \begin{macrocode}
\@@_forth_new_core:nn { COUNT }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:nn
      { \l_@@_tmpa_int + 1 }
      { \@@_forth_data_get:N \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: is S" allowed to overlap with the region of WORD or #> ?
% \begin{macro}[int]+S"+
% \begin{macro}[int]+C"+
% \begin{macro}[aux]{\@@_forth_squote:nnn}
%   Read a double-quoted string and measure its length \texttt{tmpa}.
%   Try to allocate that much space (plus \(1\) for |C"| to include the
%   string size) for a text literal, decreasing the \texttt{data_text}
%   integer.  If this enters the allotted region, complain.  Otherwise,
%   the (counted) string will start at the new address
%   \texttt{data_text} and have length \texttt{tmpa}, so we add to the
%   current definition code that pushes the appropriate data onto the
%   stack.  Finally, store the string, keeping track of the address of
%   each character using \texttt{tmpb}.  In the case of |C"|, store the
%   length before the string.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { S" }
  {
    \@@_forth_squote:nnn { }
      { \@@_forth_push:n { \int_use:N \l_@@_tmpa_int } } { }
  }
\@@_forth_new_compilation_core:nn { C" }
  {
    \@@_forth_squote:nnn { + 1 } { }
      {
        \@@_forth_data_gset:nn \l_@@_tmpb_int \l_@@_tmpa_int
        \int_incr:N \l_@@_tmpb_int
      }
  }
\cs_new_protected:Npn \@@_forth_squote:nnn #1#2#3
  {
    \@@_forth_input_until:n { `" }
    \int_set:Nn \l_@@_tmpa_int
      {
        \l_@@_forth_word_end_int
        - \l_@@_forth_word_begin_int
      }
    \int_sub:Nn \l_@@_forth_data_text_int { \l_@@_tmpa_int #1 }
    \int_compare:nNnT
      \l_@@_forth_data_text_int < \l_@@_forth_data_here_int
      {
        \int_set_eq:NN \l_@@_forth_data_text_int
          \l_@@_forth_data_here_int
        \@@_forth_abort:nx { out-of-memory } { }
      }
    \@@_forth_def_code:x
      {
        \@@_forth_push:n { \int_use:N \l_@@_forth_data_text_int }
        #2
      }
    \int_set_eq:NN \l_@@_tmpb_int \l_@@_forth_data_text_int
    #3
    \@@_forth_store_interval:NNN
      \l_@@_forth_word_begin_int
      \l_@@_forth_word_end_int
      \l_@@_tmpb_int
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% ^^A todo: what should QUIT or BYE do within an EVALUATEd string?
% ^^A todo: bug?  Should ': X 0 S" 1 ." EVALUATE . ; X' give '0 1' or '1 0'?
% \begin{macro}[int]{EVALUATE}
% \begin{macro}[aux]
%   {\@@_forth_evaluate:, \@@_forth_evaluate_aux:, \@@_forth_evaluate_after:}
%    \begin{macrocode}
\@@_forth_new_core:nn { EVALUATE } { \@@_forth_evaluate: }
\cs_new_protected_nopar:Npn \@@_forth_evaluate:
  {
    \seq_push:NV \l_@@_forth_sources_seq
      \l_@@_forth_source_begin_int
    \seq_push:Nx \l_@@_forth_sources_seq
      { \@@_forth_data_get:n { \l_@@_forth_in_address_int } }
    \seq_push:NV \l_@@_forth_sources_seq
      \l_@@_forth_source_end_int
    \seq_push:NV \l_@@_forth_sources_seq \l_@@_forth_input_str
    \@@_forth_pop_int:NN
      \l_@@_forth_source_begin_int \l_@@_tmpa_int
    \int_set:Nn \l_@@_forth_source_end_int
      { \l_@@_forth_source_begin_int + \l_@@_tmpa_int }
    \tl_clear:N \l_@@_forth_input_str
    \@@_forth_data_gset:nn \l_@@_forth_in_address_int { 0 }
    \@@_forth_evaluate_aux:
  }
\cs_new_protected_nopar:Npn \@@_forth_evaluate_aux:
  {
    \@@_forth_input_word:
    \int_compare:nNnTF
      \l_@@_forth_word_begin_int
      < \l_@@_forth_word_end_int
      {
        \@@_forth_perform:
        \@@_forth_quit_point:
        \@@_forth_evaluate_aux:
      }
      { \@@_forth_evaluate_after: }
  }
\cs_new_protected_nopar:Npn \@@_forth_evaluate_after:
  {
    \seq_pop:NN \l_@@_forth_sources_seq \l_@@_forth_input_str
    \seq_pop:NN \l_@@_forth_sources_seq \l_@@_tmpc_tl
    \seq_pop:NN \l_@@_forth_sources_seq \l_@@_tmpb_tl
    \seq_pop:NN \l_@@_forth_sources_seq \l_@@_tmpa_tl
    \int_set:Nn \l_@@_forth_source_begin_int { \l_@@_tmpa_tl }
    \@@_forth_data_gset:nn
      { \l_@@_forth_in_address_int }
      { \l_@@_tmpb_tl }
    \int_set:Nn \l_@@_forth_source_end_int { \l_@@_tmpc_tl }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% ^^A todo: what to do with the extra text \l_@@_tmpb_tl ?
% ^^A todo: should this happen in non-interactive mode ?
% \begin{macro}[int]{ACCEPT}
%   Pop an address \(a\) and a length \(c\) from the stack.  Get a line
%   from the user, with no prompt.  Split the line into a part
%   \texttt{tmpa} with \(c\) characters, and the remaining part
%   \texttt{tmpb}.  Then store the string, using \(b\) (starts at \(a\))
%   as the loop variable.
%    \begin{macrocode}
\@@_forth_new_core:nn { ACCEPT }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpc_int
    \@@_no_next_prompt:
    \@@_get_user_line:NTF \l_@@_tmpb_tl { } { }
    \tl_set:Nx \l_@@_tmpa_tl
      { \str_range:Nnn \l_@@_tmpb_tl { 1 } { \l_@@_tmpc_int } }
    \tl_set:Nx \l_@@_tmpb_tl
      { \str_range:Nnn \l_@@_tmpb_tl { \l_@@_tmpc_int + 1 } { -1 } }
    \int_set_eq:NN \l_@@_tmpb_int \l_@@_tmpa_int
    \@@_forth_store_str:NN \l_@@_tmpa_tl \l_@@_tmpb_int
    \@@_forth_push:n { \l_@@_tmpb_int - \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{SOURCE-ID}
%   If reading from the input given to \TeX{} (through a file, a stream,
%   and so on), push \texttt{false}: this is seen by checking that no
%   sources weree saved (that would imply a call to |EVALUATE|).
%    \begin{macrocode}
\@@_forth_new_core:nn { SOURCE-ID }
  {
    \seq_if_empty:NTF \l_@@_forth_sources_seq
      { \@@_forth_push_false: }
      { \@@_forth_push_true: }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: make runner omit the separation of program/input for Forth.
% \begin{macro}[int]{REFILL}
% \begin{macro}[int]{\@@_forth_refill:TF}
%   If we are not reading from an |EVALUATE|d string, request a line
%   from \pkg{runner}, and store it to the terminal.  Otherwise, it may
%   mean that we reached the end of the program source, but there is
%   still the input source, or we could have reached the very end.  In
%   cases where the terminal was refilled, push \texttt{true}, otherwise
%   \texttt{false}.
%    \begin{macrocode}
\@@_forth_new_core:nn { REFILL }
  { \@@_forth_refill:TF \@@_forth_push_true: \@@_forth_push_false: }
\cs_new_protected_nopar:Npn \@@_forth_refill:TF
  {
    \seq_if_empty:NTF \l_@@_forth_sources_seq
      {
        \@@_get_line:NTF \l_@@_forth_input_str
          {
            \@@_forth_term_refill:
            \use_i:nn
          }
          {
            \seq_if_empty:NTF \l_@@_sources_seq
              { \use_ii:nn }
              {
                \@@_forth_term_refill:
                \use_i:nn
              }
          }
      }
      { \use_ii:nn }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Memory cells}
%
% This section defines the words |ALIGN|, |ALIGNED|, |CELL+|, |CHAR+|,
% |CELLS|, |CHARS|, |HERE|, |UNUSED|, |,|, |C,|, |@|, |C@|, |2@|, |!|,
% |C!|, |2!|, |+!|, |ALLOT|, |ERASE|, |FILL|, |MOVE|.
%
% ^^A todo: Simplify how |ALIGNED| triggers an error upon empty stack
% \begin{macro}[int]{ALIGN, ALIGNED}
%   Since all addresses are aligned, |ALIGN| does nothing, |ALIGNED|
%   simply pops and pushes back the same value.
%    \begin{macrocode}
\@@_forth_new_core:nn { ALIGN } { }
\@@_forth_new_core:nn { ALIGNED }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:n \l_@@_tmpa_int
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{CELL+, CELLS, CHAR+, CHARS}
%   Since the cell size, the character size and the address sizes are
%   identical, |CELL+| and |CHAR+| simply add~\(1\), like |1+|, and
%   |CELLS| and |CHARS| do nothing to the top of the stack (which must
%   be present), just like |ALIGNED|.
%    \begin{macrocode}
\@@_forth_core_alias:nn { CELL+ } { 1+ }
\@@_forth_core_alias:nn { CHAR+ } { 1+ }
\@@_forth_core_alias:nn { CELLS } { ALIGNED }
\@@_forth_core_alias:nn { CHARS } { ALIGNED }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{HERE, UNUSED}
%   The next address to be allocated, and the remaining memory.
%    \begin{macrocode}
\@@_forth_new_core:nn { HERE }
  { \@@_forth_push:n { \l_@@_forth_data_here_int } }
\@@_forth_new_core:nn { UNUSED }
  {
    \@@_forth_push:n
      { \l_@@_forth_data_text_int - \l_@@_forth_data_here_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]+,+
% \begin{macro}[int]+C,+
%   Store value in a newly allocated cell, given by the data-space
%   pointer ``\texttt{here}''.  Since all addresses are aligned, |C,| is
%   equivalent.
%    \begin{macrocode}
\@@_forth_new_core:nn { , }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_put_here:n { \l_@@_tmpa_int }
  }
\@@_forth_core_alias:nn { C, } { , }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{@, C@}
%   Pop an address from the stack, and push the value \(x\) of the
%   corresponding memory cell.  |C@| is identical since all addresses
%   are aligned.
%    \begin{macrocode}
\@@_forth_new_core:nn { @ }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:n
      { \@@_forth_data_get:N \l_@@_tmpa_int }
  }
\@@_forth_core_alias:nn { C@ } { @ }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{2@}
%   Find an address on the stack, and fetch the value \(x_2\) of the
%   corresponding memory cell, and the next, \(x_1\).  The value \(x_2\)
%   (at the given address) ends up at the top of the stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { 2@ }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:nn
      { \@@_forth_data_get:n { \l_@@_tmpa_int + 1 } }
      { \@@_forth_data_get:N \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{!, C!}
%   Store value at a given address.  Since all addresses are aligned,
%   |C!| is equivalent to~|!|.
%    \begin{macrocode}
\@@_forth_new_core:nn { ! }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_data_gset:nn
      { \l_@@_tmpb_int } { \l_@@_tmpa_int }
  }
\@@_forth_core_alias:nn { C! } { ! }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{2!}
%   Store values at a given address and at the next cell.
%    \begin{macrocode}
\@@_forth_new_core:nn { 2! }
  {
    \@@_forth_pop_int:NNN
      \l_@@_tmpa_int \l_@@_tmpb_int \l_@@_tmpc_int
    \@@_forth_data_gset:nn
      { \l_@@_tmpc_int } { \l_@@_tmpb_int }
    \@@_forth_data_gset:nn
      { \l_@@_tmpc_int + 1 } { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{+!}
%   Sum \(a\) and the value at \(b\) into the integer \(a\), then store
%   that into the address at \(b\).
%    \begin{macrocode}
\@@_forth_new_core:nn { +! }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_add:Nn \l_@@_tmpa_int
      { \@@_forth_data_get:N \l_@@_tmpb_int }
    \int_compare:nNnF \l_@@_tmpa_int < \c_@@_forth_mod_int
      { \int_sub:Nn \l_@@_tmpa_int \c_@@_forth_mod_int }
    \@@_forth_data_gset:nn
      { \l_@@_tmpb_int } { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{ALLOT}
%   Shift the data pointer by the (signed) value at the top of the
%   stack, then make sure that the pointer is within memory bounds.
%    \begin{macrocode}
\@@_forth_new_core:nn { ALLOT }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \int_add:Nn \l_@@_forth_data_here_int
      { \@@_forth_signed:N \l_@@_tmpa_int }
    \int_compare:nNnT
      \l_@@_forth_data_here_int < \g_@@_forth_data_min_int
      {
        \int_set_eq:NN \l_@@_forth_data_here_int
          \g_@@_forth_data_min_int
        \@@_forth_abort:nx { out-of-bounds } { }
      }
    \int_compare:nNnT
      \l_@@_forth_data_here_int > \l_@@_forth_data_text_int
      {
        \int_set_eq:NN \l_@@_forth_data_here_int
          \l_@@_forth_data_text_int
        \@@_forth_abort:nx { out-of-memory } { }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{ERASE, FILL}
% \begin{macro}[aux]{\@@_forth_fill:NNN}
%   Fill the addresses from \(a\) to \(a+b-1\) with the value \(c\).
%    \begin{macrocode}
\@@_forth_new_core:nn { ERASE }
  {
    \@@_forth_pop_int:NN
      \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_fill:NNN \l_@@_tmpa_int \l_@@_tmpb_int \c_zero
  }
\@@_forth_new_core:nn { FILL }
  {
    \@@_forth_pop_int:NNN
      \l_@@_tmpa_int \l_@@_tmpb_int \l_@@_tmpc_int
    \@@_forth_fill:NNN
      \l_@@_tmpa_int \l_@@_tmpb_int \l_@@_tmpc_int
  }
\cs_new_protected:Npn \@@_forth_fill:NNN #1#2#3
  {
    \int_step_inline:nnnn {#1} { 1 } { #1 + #2 - 1 }
      { \@@_forth_data_gset:nn {##1} {#3} }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{MOVE}
%   If the number \(c\) of cells to copy from \(a\) to \(b\) is not
%   positive, do nothing.  If \(a<b\), copy from the top end of the
%   block of cells.  If \(b\leq a\) start from the bottom end.  This
%   works even if the blocks overlap.
%    \begin{macrocode}
\@@_forth_new_core:nn { MOVE }
  {
    \@@_forth_pop_int:NNN
      \l_@@_tmpa_int \l_@@_tmpb_int \l_@@_tmpc_int
    \int_compare:nNnT \l_@@_tmpc_int > \c_zero
      {
        \int_compare:nNnTF \l_@@_tmpa_int < \l_@@_tmpb_int
          {
            \int_step_inline:nnnn
              { \l_@@_tmpc_int - 1 } { -1 } { 0 }
          }
          {
            \int_step_inline:nnnn
              { 0 } { 1 } { \l_@@_tmpc_int - 1 }
          }
              {
                \@@_forth_data_gset:nn
                  { \l_@@_tmpb_int + #1 }
                  { \@@_forth_data_get:n { \l_@@_tmpa_int + #1 } }
              }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Number conversion}
%
% This section defines |BASE|, |DECIMAL|, |HEX|, |<#|, |SIGN|, |HOLD|, |#|,
% |#S|, |#>|, |>NUMBER|.
%
% \begin{macro}[int]{BASE}
%   Push the address where the base is stored.
%    \begin{macrocode}
\@@_forth_new_core:nn { BASE }
  { \@@_forth_push:n { \l_@@_forth_base_address_int } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{DECIMAL, HEX}
%   Change base to \(10\) or \(16\).
%    \begin{macrocode}
\@@_forth_new_core:nn { DECIMAL }
  { \@@_forth_data_gset:nn { \l_@@_forth_base_address_int } { 10 } }
\@@_forth_new_core:nn { HEX }
  { \@@_forth_data_gset:nn { \l_@@_forth_base_address_int } { 16 } }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: improve error catching.
% \begin{macro}[int]+<#+
%   A little bit of care is needed on the \TeX{} side, since |#| is
%   special there.  Initiate the pictured numeric output by emptying it
%   (simply move the \texttt{here} pointer).
%    \begin{macrocode}
\exp_args:Nx \@@_forth_new_core:nn { < \iow_char:N \# }
  {
    \int_set_eq:NN \l_@@_forth_picnum_here_int
      \g_@@_forth_picnum_max_int
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{SIGN}
%   Pop a signed \(a\) from the stack.  If it is negative, prepend |-|
%   to the pictured numeric output.
%    \begin{macrocode}
\@@_forth_new_core:nn { SIGN }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \int_compare:nNnT
      { \@@_forth_signed:N \l_@@_tmpa_int } < \c_zero
      {
        \int_decr:N \l_@@_forth_picnum_here_int
        \@@_array_gset:Nnn \g_@@_forth_array
          { \l_@@_forth_picnum_here_int } { `- }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{HOLD}
%   Pop \(a\) from the stack, and put it at the start of the pictured
%   numeric buffer.
%    \begin{macrocode}
\@@_forth_new_core:nn { HOLD }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \int_decr:N \l_@@_forth_picnum_here_int
    \@@_array_gset:Nnn \g_@@_forth_array
      { \l_@@_forth_picnum_here_int } { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]+#+
% \begin{macro}[int]+#S+
% \begin{macro}[aux]{\@@_forth_picnum_aux:}
%   First we describe how |#| operates.  Pop a double-cell unsigned
%   integer \((c,d)\).  Store the base as \(b\).  Split \(d = b q_d +
%   r_d\).  Set \(c' = c + r_d\), and split it: \(c' = r_d + c = b q_c +
%   r_c\).  Store \(|`0| + r_c\) to the beginning of the pictured
%   numeric buffer.  Set \((c,d)\) equal to \((q_c, q_d)\).  Push that
%   to the stack.  The |#S| word is similar, repeating the conversion
%   until both \(c\) and \(d\) are zero.
%    \begin{macrocode}
\exp_args:Nx \@@_forth_new_core:nn { \iow_char:N \# }
  {
    \@@_forth_pop_int:NN \l_@@_tmpc_int \l_@@_tmpd_int
    \int_set:Nn \l_@@_tmpb_int { \@@_forth_base: }
    \@@_forth_picnum_aux:
    \@@_forth_push:nn { \l_@@_tmpc_int } { \l_@@_tmpd_int }
  }
\exp_args:Nx \@@_forth_new_core:nn { \iow_char:N \# S }
  {
    \@@_forth_pop_int:NN \l_@@_tmpc_int \l_@@_tmpd_int
    \int_set:Nn \l_@@_tmpb_int { \@@_forth_base: }
    \int_do_while:nNnn
      { \l_@@_tmpc_int + \l_@@_tmpd_int } > \c_zero
      { \@@_forth_picnum_aux: }
    \@@_forth_push:nn { \l_@@_tmpc_int } { \l_@@_tmpd_int }
  }
\cs_new_protected_nopar:Npn \@@_forth_picnum_aux:
  {
    \int_add:Nn \l_@@_tmpc_int
      {
        \int_mod:nn { \l_@@_tmpd_int } { \l_@@_tmpb_int }
        * \c_@@_forth_mod_int
      }
    \int_decr:N \l_@@_forth_picnum_here_int
    \int_set:Nn \l_@@_tmpe_int
      { `0 + \int_mod:nn { \l_@@_tmpc_int } { \l_@@_tmpb_int } }
    \int_compare:nNnF \l_@@_tmpe_int < { `: }
      { \int_add:Nn \l_@@_tmpe_int { 7 } }
    \@@_array_gset:Nnn \g_@@_forth_array
      { \l_@@_forth_picnum_here_int } { \l_@@_tmpe_int }
    \int_set:Nn \l_@@_tmpc_int
      { \int_div_truncate:nn { \l_@@_tmpc_int } { \l_@@_tmpb_int } }
    \int_set:Nn \l_@@_tmpd_int
      { \int_div_truncate:nn { \l_@@_tmpd_int } { \l_@@_tmpb_int } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]+#>+
%   End the pictured numeric output by storing the sequence as a string
%   in the text literal
%    \begin{macrocode}
\exp_args:Nx \@@_forth_new_core:nn { \iow_char:N \# > }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push:nn
      { \l_@@_forth_picnum_here_int }
      {
        \g_@@_forth_picnum_max_int
        - \l_@@_forth_picnum_here_int
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{>NUMBER, CONVERT}
%   Get a double cell integer \((c,d)\), an address \(e\) and a length
%   \(f\).  Set \(f\) to point just after the end of the string.  Then
%   the \texttt{to_number} function reads digits as defined by the
%   standard, multiplying \((c,d)\) by the base and adding the digit
%   found at each step.  The integers \(a\) and \(b\) are used
%   internally by this function, \(c\) and \(d\) are affected, and \(e\)
%   is incremented at each step.  At the end of the day,
%   push the resulting double-cell number, and the address of the first
%   character that was not converted.  For |>NUMBER|, also push the
%   length of the non-converted string.
%    \begin{macrocode}
\@@_forth_new_core:nn { >NUMBER }
  {
    \@@_forth_pop_int:NNNN
      \l_@@_tmpc_int \l_@@_tmpd_int
      \l_@@_tmpe_int \l_@@_tmpf_int
    \int_add:Nn \l_@@_tmpf_int { \l_@@_tmpe_int }
    \@@_forth_to_number:
    \@@_forth_push:nnnn
      { \l_@@_tmpc_int } { \l_@@_tmpd_int }
      { \l_@@_tmpe_int } { \l_@@_tmpf_int - \l_@@_tmpe_int }
  }
\@@_forth_new_core:nn { CONVERT }
  {
    \@@_forth_pop_int:NNN
      \l_@@_tmpc_int \l_@@_tmpd_int \l_@@_tmpe_int
    \int_incr:N \l_@@_tmpe_int
    \int_set_eq:NN \l_@@_tmpf_int \c_@@_forth_mod_int
    \@@_forth_to_number:
    \@@_forth_push:nnn
      { \l_@@_tmpc_int } { \l_@@_tmpd_int } { \l_@@_tmpe_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Output}
%
% This section defines the words |.|, |U.|, |.R|, |U.R|, |."|, |.(|,
% |BL|, |CR|, |EMIT|, |SPACE|, |SPACES|, |TYPE|, |D.|, |D.R|, |.S|, |?|,
% |DUMP|.%^^A)
%
% \begin{macro}[int]{., U.}
% \begin{macro}[aux]{\@@_forth_outnum:n}
%   Get a signed or unsigned value from the data stack, convert it to
%   the base.  Trailing space.
%    \begin{macrocode}
\@@_forth_new_core:nn { . }
  { \@@_forth_outnum:n { \@@_forth_signed:N } }
\@@_forth_new_core:nn { U. }
  { \@@_forth_outnum:n { } }
\cs_new_protected:Npn \@@_forth_outnum:n #1
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_output:x
      { \int_to_base:nn { #1 \l_@@_tmpa_int } { \@@_forth_base: } ~ }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{.R, U.R}
% \begin{macro}[aux]{\@@_forth_outnum_aligned:n}
%   Get a signed or unsigned value from the data stack, convert it to
%   the base, fill on the left with spaces, making sure not to give
%   \cs{prg_replicate:nn} a negative first argument.
%    \begin{macrocode}
\@@_forth_new_core:nn { .R }
  { \@@_forth_outnum_aligned:n { \@@_forth_signed:N } }
\@@_forth_new_core:nn { U.R }
  { \@@_forth_outnum_aligned:n { } }
\cs_new_protected:Npn \@@_forth_outnum_aligned:n #1
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \tl_set:Nx \l_@@_tmpa_tl
      { \int_to_base:nn { #1 \l_@@_tmpa_int } { \@@_forth_base: } }
    \@@_output:x
      {
        \prg_replicate:nn
          {
            \int_max:nn { \c_zero  }
              { \l_@@_tmpb_int - \str_count:N \l_@@_tmpa_tl }
          }
          { ~ }
        \l_@@_tmpa_tl
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]+."+
% \begin{macro}[int]+.(+ %^^A)
%   The dot-quote word reads the input until a double quote.  It has no
%   interpretation semantics.  Its compilation semantics is to add code
%   to the current definition that displays what it read.  The dot-parent
%   is an immediate word that outputs the string read until a right
%   parenthesis.
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { ." }
  {
    \@@_forth_input_until:n { `" }
    \@@_forth_def_code:x
      {
        \@@_output_clist:x
          {
            \@@_forth_interval_to_clist:nn
              \l_@@_forth_word_begin_int
              \l_@@_forth_word_end_int
          }
      }
  }
\@@_forth_new_immediate_core:nn { .( }
  {
    \@@_forth_input_until:n { `) }
    \@@_output_clist:x
      {
        \@@_forth_interval_to_clist:nn
          \l_@@_forth_word_begin_int
          \l_@@_forth_word_end_int
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{BL}
%   Push the character code of space~(32).
%    \begin{macrocode}
\@@_forth_new_core:nn { BL }
  { \@@_forth_push:n { `\  } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{CR}
%   Output a new-line character.
%    \begin{macrocode}
\@@_forth_new_core:nn { CR }
  { \@@_output_char:n { 10 } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{EMIT}
%   Output a character with the character code found by popping the data
%   stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { EMIT }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_output_char:n { \l_@@_tmpa_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{SPACE}
%   Output a space (character code~\(32\)).
%    \begin{macrocode}
\@@_forth_new_core:nn { SPACE }
  { \@@_output_char:n { 32 } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{SPACES}
%   Output \(a\) spaces (character code~\(32\)), where \(a\) is found on
%   the stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { SPACES }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_output_clist:x
      { \prg_replicate:nn { \l_@@_tmpa_int } { 32 , } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{TYPE}
%   Output the string starting at \(a\) and with \(b\) characters.
%    \begin{macrocode}
\@@_forth_new_core:nn { TYPE }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_step_inline:nnnn
      { \l_@@_tmpa_int }
      { 1 }
      { \l_@@_tmpa_int + \l_@@_tmpb_int - 1 }
      {
        \@@_output_char:n
          { \@@_forth_data_get:n {#1} }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{D., D.R}
% \begin{macro}[aux]{\@@_forth_outdouble:nn}
%   Display a double-cell number.
%    \begin{macrocode}
\@@_forth_new_core:nn { D. }
  { \@@_forth_outdouble:nn { } { , 32 } }
\@@_forth_new_core:nn { D.R }
  {
    \@@_forth_pop_int:N \l_@@_tmpf_int
    \@@_forth_outdouble:nn
      {
        \prg_replicate:nn
          {
            \int_max:nn
              { \c_zero }
              {
                \l_@@_tmpf_int
                - \g_@@_forth_picnum_max_int
                + \l_@@_forth_picnum_here_int
              }
          }
          { 32 , }
      }
      { }
  }
\cs_new_protected:Npn \@@_forth_outdouble:nn #1#2
  {
    \@@_forth_pop_int:NN \l_@@_tmpc_int \l_@@_tmpd_int
    \int_set_eq:NN \l_@@_forth_picnum_here_int
      \g_@@_forth_picnum_max_int
    \int_set:Nn \l_@@_tmpb_int { \@@_forth_base: }
    \int_compare:nNnTF
      { \@@_forth_signed:N \l_@@_tmpd_int } < \c_zero
      {
        \@@_forth_double_negate:NN \l_@@_tmpc_int \l_@@_tmpd_int
        \int_do_while:nNnn
          { \l_@@_tmpc_int + \l_@@_tmpd_int } > \c_zero
          { \@@_forth_picnum_aux: }
        \int_decr:N \l_@@_forth_picnum_here_int
        \@@_array_gset:Nnn \g_@@_forth_array
          { \l_@@_forth_picnum_here_int } { `- }
      }
      {
        \int_do_while:nNnn
          { \l_@@_tmpc_int + \l_@@_tmpd_int } > \c_zero
          { \@@_forth_picnum_aux: }
      }
    \@@_output_clist:x
      {
        #1
        \@@_forth_interval_to_clist:nn
          \l_@@_forth_picnum_here_int
          \g_@@_forth_picnum_max_int
        #2
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{.S}
%   Show the contents of the stack, in the current |BASE|.
%    \begin{macrocode}
\@@_forth_new_core:nn { .S }
  {
    \int_step_inline:nnnn
      { \g_@@_forth_stack_min_int }
      { 1 }
      { \l_@@_forth_stack_here_int - 1 }
      {
        \@@_output:x
          {
            \int_to_base:nn
              { \@@_array_item:Nn \g_@@_forth_array {#1} }
              { \@@_forth_base: } ~
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{?}
%   Show the contents of an address cell.
%    \begin{macrocode}
\@@_forth_new_core:nn { ? }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_output:x
      {
        \int_to_base:nn { \@@_forth_data_get:N \l_@@_tmpa_int }
          { \@@_forth_base: } ~
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{DUMP}
%   Go from address~\(a\) to~\(a+b-1\), printing each cell's contents.
%    \begin{macrocode}
\@@_forth_new_core:nn { DUMP }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \int_step_inline:nnnn
      { \l_@@_tmpa_int }
      { 1 }
      { \l_@@_tmpa_int + \l_@@_tmpb_int - 1 }
      {
        \@@_output:x
          {
            \int_to_base:nn { \@@_forth_data_get:n {#1} }
              { \@@_forth_base: } ~
          }
      }
  }
%    \end{macrocode}
% ^^A todo: add auxiliary for outputting in the BASE.
% \end{macro}
%
% \subsubsection{Quitting}
%
% This section defines the words |EXIT|, |QUIT|, |ABORT|, |ABORT"|,
% |BYE|.
%
% ^^A todo: for ABORT, print a reasonable prompt, not nothing.
%
% \begin{macro}[int]{\@@_forth_exit:, \@@_forth_exit:n, \@@_forth_exit_point:}
%   When executing code given an execution token (see
%   \cs{@@_forth_execute:n}), an \texttt{exit_point} marker is placed
%   after the code, so that |EXIT| can safely leave definitions.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_forth_exit:
  #1 \@@_forth_exit_point: { }
\cs_new_protected:Npn \@@_forth_exit:n
  #1 #2 \@@_forth_exit_point: {#1}
\cs_new_eq:NN \@@_forth_exit_point: \scan_stop:
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: doc that EXIT is allowed in interpretation mode.
% \begin{macro}[int]{EXIT}
%   Leave the current definition.  See \cs{@@_forth_exit:} and
%   \cs{@@_forth_exit_point:}.  The \cs{use_i:nn} is a bit of a hack, to
%   remove the \texttt{exit_point} that is inserted after the code of
%   |EXIT| itself.
%    \begin{macrocode}
\@@_forth_new_core:nn { EXIT } { \use_i:nn \@@_forth_exit: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{QUIT, ABORT}
% \begin{macro}[aux]{\@@_forth_do_quit:}
%   Empty the return stack and enter interpretation state, then flush
%   all code being run, by jumping to the \texttt{quit_point}.  |ABORT|
%   additionally empties the data stack, and it suppresses the prompt.
%    \begin{macrocode}
\@@_forth_new_core:nn { QUIT } { \@@_forth_do_quit: }
\@@_forth_new_core:nn { ABORT }
  {
    \@@_no_next_prompt:
    \int_set_eq:NN \l_@@_forth_stack_here_int
      \g_@@_forth_stack_min_int
    \@@_forth_do_quit:
  }
\cs_new_protected_nopar:Npn \@@_forth_do_quit:
  {
    \int_set_eq:NN \l_@@_forth_return_here_int
      \g_@@_forth_return_min_int
    \@@_forth_state_to_interpret:
    \@@_forth_quit:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]+ABORT"+
%    \begin{macrocode}
\@@_forth_new_compilation_core:nn { ABORT" }
  {
    \@@_forth_input_until:n { `" }
    \@@_forth_input_set_word:
    \@@_forth_def_code:x
      { \@@_forth_abort_quote:n { \l_@@_forth_word_str } }
  }
\cs_new_protected:Npn \@@_forth_abort_quote:n #1
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \int_compare:nNnF \l_@@_tmpa_int = \c_zero
      {
        \@@_forth_abort:nxx { abort }
          { \@@_forth_signed:N \l_@@_tmpa_int } {#1}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: conceptually, BYE means 'no input left', should be done by runner.
% \begin{macro}[int]{BYE}
%   Set the \texttt{run_loop} function to do nothing, to stop the
%   interpreter loop.  Perform the action of |ABORT|.
%    \begin{macrocode}
\@@_forth_new_core:nn { BYE }
  {
    \cs_set_eq:NN \@@_forth_run_loop: \prg_do_nothing:
    \int_set_eq:NN \l_@@_forth_stack_here_int
      \g_@@_forth_stack_min_int
    \@@_forth_do_quit:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Stacks}
%
% This section defines the words |DEPTH|, |DROP|, |2DROP|, |NIP|,
% |SWAP|, |2SWAP|, |ROT|, |2ROT|, |DUP|, |2DUP|, |OVER|, |2OVER|,
% |TUCK|, |PICK|, |ROLL|, |R>|, |2R>|, |R@|, |2R@|, |>R|, |2>R|, |S>D|,
% |D>S|.
%
% \begin{macro}[int]{DEPTH}
%    \begin{macrocode}
\@@_forth_new_core:nn { DEPTH }
  {
    \@@_forth_push:n
      { \l_@@_forth_stack_here_int - \g_@@_forth_stack_min_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{DROP, 2DROP}
%   Pop stack, once or twice.
%    \begin{macrocode}
\@@_forth_new_core:nn { DROP }
  { \@@_forth_pop_int:N \l_@@_tmpa_int }
\@@_forth_new_core:nn { 2DROP }
  { \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{NIP}
%   Turn \(x_1, x_2\) to \(x_2\).
%    \begin{macrocode}
\@@_forth_new_core:nn { NIP }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push:n \l_@@_tmpb_int
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{SWAP, 2SWAP}
%   Turn \(x_1, x_2\) to \(x_2, x_1\), or \(x_1, x_2, x_3, x_4\) to
%   \(x_3, x_4, x_1, x_2\).
%    \begin{macrocode}
\@@_forth_new_core:nn { SWAP }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push:nn { \l_@@_tmpb_int } { \l_@@_tmpa_int }
  }
\@@_forth_new_core:nn { 2SWAP }
  {
    \@@_forth_pop_int:NNNN
      \l_@@_tmpa_int \l_@@_tmpb_int
      \l_@@_tmpc_int \l_@@_tmpd_int
    \@@_forth_push:nnnn
      { \l_@@_tmpc_int } { \l_@@_tmpd_int }
      { \l_@@_tmpa_int } { \l_@@_tmpb_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{ROT, 2ROT}
%   Turn \(x_1, x_2, x_3\) to \(x_2, x_3, x_1\), or \(a,b,c,d,e,f\) to
%   \(c,d,e,f,a,b\).
%    \begin{macrocode}
\@@_forth_new_core:nn { ROT }
  {
    \@@_forth_pop_int:NNN
      \l_@@_tmpa_int \l_@@_tmpb_int \l_@@_tmpc_int
    \@@_forth_push:nnn
      { \l_@@_tmpb_int } { \l_@@_tmpc_int } { \l_@@_tmpa_int }
  }
\@@_forth_new_core:nn { 2ROT }
  {
    \@@_forth_pop_int:NN \l_@@_tmpe_int \l_@@_tmpf_int
    \@@_forth_pop_int:NN \l_@@_tmpc_int \l_@@_tmpd_int
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push:nnnnnn
      \l_@@_tmpc_int \l_@@_tmpd_int
      \l_@@_tmpe_int \l_@@_tmpf_int
      \l_@@_tmpa_int \l_@@_tmpb_int
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{DUP, 2DUP}
%   Turn \(x\) to \(x, x\), or \(x_1, x_2\) to \(x_1, x_2, x_1, x_2\).
%    \begin{macrocode}
\@@_forth_new_core:nn { DUP }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:nn { \l_@@_tmpa_int } { \l_@@_tmpa_int }
  }
\@@_forth_new_core:nn { 2DUP }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push:nnnn
      { \l_@@_tmpa_int } { \l_@@_tmpb_int }
      { \l_@@_tmpa_int } { \l_@@_tmpb_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{OVER, 2OVER}
%   Turn \(x_1, x_2\) to \(x_1, x_2, x_1\), or \(x_1, x_2, x_3, x_4\) to
%   \(x_1, x_2, x_3, x_4, x_1, x_2\).
%    \begin{macrocode}
\@@_forth_new_core:nn { OVER }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push:nnn
      { \l_@@_tmpa_int } { \l_@@_tmpb_int } { \l_@@_tmpa_int }
  }
\@@_forth_new_core:nn { 2OVER }
  {
    \@@_forth_pop_int:NNNN
      \l_@@_tmpa_int \l_@@_tmpb_int
      \l_@@_tmpc_int \l_@@_tmpd_int
    \@@_forth_push:nnnnnn
      { \l_@@_tmpa_int } { \l_@@_tmpb_int }
      { \l_@@_tmpc_int } { \l_@@_tmpd_int }
      { \l_@@_tmpa_int } { \l_@@_tmpb_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{TUCK}
%   Turn \(x_1, x_2\) to \(x_2, x_1, x_2\).
%    \begin{macrocode}
\@@_forth_new_core:nn { TUCK }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_push:nnn
      { \l_@@_tmpb_int } { \l_@@_tmpa_int } { \l_@@_tmpb_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{PICK, ROLL}
%    \begin{macrocode}
\@@_forth_new_core:nn { PICK }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_check_stack_bottom:n { \l_@@_tmpa_int + \c_one }
    \@@_forth_push_unsafe:n
      {
        \@@_array_item:Nn \g_@@_forth_array
          { \l_@@_forth_stack_here_int - \l_@@_tmpa_int - 1 }
      }
  }
\@@_forth_new_core:nn { ROLL }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_check_stack_bottom:n { \l_@@_tmpa_int + \c_one }
    \int_set:Nn \l_@@_tmpb_int
      {
        \@@_array_item:Nn \g_@@_forth_array
          { \l_@@_forth_stack_here_int - \l_@@_tmpa_int - 1 }
      }
    \int_step_inline:nnnn
      { \l_@@_forth_stack_here_int - \l_@@_tmpa_int }
      { 1 }
      { \l_@@_forth_stack_here_int - 1 }
      {
        \@@_array_gset:Nnn \g_@@_forth_array { #1 - 1 }
          { \@@_array_item:Nn \g_@@_forth_array {#1} }
      }
    \@@_array_gset:Nnn \g_@@_forth_array
      { \l_@@_forth_stack_here_int - 1 }
      { \l_@@_tmpb_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{R>, 2R>}
%   Pop one or two cells from the return stack onto the data stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { R> }
  {
    \@@_forth_return_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:n { \l_@@_tmpa_int }
  }
\@@_forth_new_core:nn { 2R> }
  {
    \@@_forth_return_pop_int:N \l_@@_tmpb_int
    \@@_forth_return_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:nn { \l_@@_tmpa_int } { \l_@@_tmpb_int }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: optimize.
% \begin{macro}[int]{R@, 2R@}
%   Copy one or two cells from the return stack onto the data stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { R@ }
  {
    \@@_forth_return_pop_int:N \l_@@_tmpa_int
    \@@_forth_return_push:n { \l_@@_tmpa_int }
    \@@_forth_push:n { \l_@@_tmpa_int }
  }
\@@_forth_new_core:nn { 2R@ }
  {
    \@@_forth_return_pop_int:N \l_@@_tmpb_int
    \@@_forth_return_pop_int:N \l_@@_tmpa_int
    \@@_forth_return_push:n { \l_@@_tmpa_int }
    \@@_forth_return_push:n { \l_@@_tmpb_int }
    \@@_forth_push:nn { \l_@@_tmpa_int } { \l_@@_tmpb_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{>R, 2>R}
%   Pop one or two cells from the data stack onto the return stack.
%    \begin{macrocode}
\@@_forth_new_core:nn { >R }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_return_push:n \l_@@_tmpa_int
  }
\@@_forth_new_core:nn { 2>R }
  {
    \@@_forth_pop_int:NN \l_@@_tmpa_int \l_@@_tmpb_int
    \@@_forth_return_push:n \l_@@_tmpa_int
    \@@_forth_return_push:n \l_@@_tmpb_int
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{S>D}
%   The most significant part of a double-cell integer is stored on top,
%   thus converting a single cell to a double-cell integer simply
%   requires pushing \(0\) for positive and \(-1\) (all bits set) for
%   negative integers.
%    \begin{macrocode}
\@@_forth_new_core:nn { S>D }
  {
    \@@_forth_pop_int:N \l_@@_tmpa_int
    \@@_forth_push:n { \l_@@_tmpa_int }
    \int_compare:nNnTF
      { \l_@@_tmpa_int } < { \c_@@_forth_mod_int / \c_two }
      { \@@_forth_push:n { 0 } }
      { \@@_forth_push:n { \c_@@_forth_mod_int - \c_one } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{D>S}
%   Since the most significant part of a double is stored on top of the
%   stack, turning a double cell into a single cell integer amounts to
%   dropping the most significant part.
%    \begin{macrocode}
\@@_forth_core_alias:nn { D>S } { DROP }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Messages}
%
% ^^A todo: add details of the pictured numeric output, the terminal
% ^^A input buffer, the source buffer, \etc.
% \begin{macro}[int, EXP]{\@@_forth_footprint:}
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_forth_footprint:
  {
    Summary~of~memory~use.\\\\
    Input~buffer: \
      \int_use:N \l_@@_forth_source_begin_int \ to \
      \int_use:N \l_@@_forth_source_end_int . \\
    Pad: \
      \int_use:N \g_@@_forth_pad_min_int \ to \
      \int_use:N \g_@@_forth_pad_max_int .\\
    Data:
      \int_use:N \g_@@_forth_data_min_int \ to \
      \int_use:N \g_@@_forth_data_max_int , \ split\ as \\
    \iow_indent:n
      {
        \int_eval:n
          { \l_@@_forth_data_here_int - \g_@@_forth_data_min_int }
        \ cells\ of\ variables\ and\ allotted\ data, \\
        \int_compare:nTF
          {
            \l_@@_forth_data_here_int
            <= \l_@@_forth_data_word_int
            <= \l_@@_forth_data_text_int
          }
          {
            \int_eval:n
              {
                \l_@@_forth_data_word_int
                - \l_@@_forth_data_text_int
              }
            \ cells\ for\ WORD\ or\ \#>\ .\\
            \int_eval:n
              {
                \l_@@_forth_data_text_int
                - \l_@@_forth_data_word_int
              }
            \ unassigned\ cells. \\
          }
          {
            \int_eval:n
              {
                \l_@@_forth_data_text_int
                - \l_@@_forth_data_here_int
              }
            \ unassigned\ cells. \\
          }
        \int_eval:n
          { \g_@@_forth_data_max_int - \l_@@_forth_data_text_int }
        \ cells\ for\ literal\ text. \\
      }
    Stack: \
      \int_use:N \g_@@_forth_stack_min_int \ to \
      \int_use:N \g_@@_forth_stack_max_int , \
      \int_eval:n
        { \l_@@_forth_stack_here_int - \g_@@_forth_stack_min_int }
      \ out\ of\
      \int_eval:n
        { \g_@@_forth_stack_max_int - \g_@@_forth_stack_min_int }
      \ occupied.
    \\
    Return stack: \
      \int_use:N \g_@@_forth_return_min_int \ to \
      \int_use:N \g_@@_forth_return_max_int , \
      \int_eval:n
        { \l_@@_forth_return_here_int - \g_@@_forth_return_min_int }
      \ out\ of\
      \int_eval:n
        { \g_@@_forth_return_max_int - \g_@@_forth_return_min_int }
      \ occupied.
    \\
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\msg_new:nnn { runner/forth } { unknown-word }
  { The~word~'#1'~is~not~defined. }
\msg_new:nnn { runner/forth } { empty-stack }
  { The~data~stack~is~empty,~and~there~is~nothing~to~retrieve~there. }
\msg_new:nnn { runner/forth } { empty-return-stack }
  { The~return~stack~is~empty,~and~there~is~nothing~to~retrieve~there. }
\msg_new:nnnn { runner/forth } { out-of-memory }
  { The~Forth~interpreter~ran~out~of~memory. }
  { \@@_forth_footprint: }
\msg_new:nnn { runner/forth } { out-of-bounds }
  { ALLOT~was~called~with~a~negative~argument~that~made~HERE~=~#1. }
\msg_new:nnn { runner/forth } { no-interpretation }
  { The~word~#1~can~only~be~used~in~definitions. }
\msg_new:nnn { runner/forth } { no-def-immediate }
  { Somehow~the~word~#1~cannot~be~found~in~the~dictionary }
\msg_new:nnn { runner/forth } { misplaced }
  { Misplaced~#1. }
\msg_new:nnn { runner/forth } { internal }
  { Internal~error.~Please~report. }
\msg_new:nnn { runner/forth } { not-created }
  { The~execution~token~#1~was~not~generated~with~CREATE. }
\msg_new:nnn { runner/forth } { abort }
  { ABORT~(#1):~#2 }
%    \end{macrocode}
%
% \end{runner-implementation}
% \endinput