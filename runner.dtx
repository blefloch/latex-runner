% \iffalse
%% File: runner.dtx Copyright (C) 2013 Bruno Le Floch
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% -----------------------------------------------------------------------
%
%<*driver>
%\fi
%\iffalse
\documentclass[full]{l3doc}
\usepackage{runner}
\usepackage{booktabs}
\ExplSyntaxOn
\DeclareDocumentCommand { \runnerMapPlang } { m }
  { \clist_map_inline:Nn \g_runner_languages_clist {#1} }
\DeclareDocumentCommand { \runnerDisableDoc } { }
  {
    \cs_set:cpn { runner-documentation }
      {
        \tl_map_function:nN { \{ \} } \char_set_catcode_other:N
        \runner_doc_skip:wN
      }
  }
\cs_new:Npn \runner_doc_skip:wN
    #1 runner-documentation #2 { \group_end: }
\ExplSyntaxOff
\newenvironment{runner-documentation}{}{\endinput}
\newenvironment{runner-implementation}{}{}
\newcommand{\varg}[1]{\texttt{\char`\| }\meta{#1}\texttt{\char`\| }}
\newcommand{\plang}[1]{\texttt{#1}}
\begin{document}
  \DocInput{runner.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{runner} package: \\
%   interpreters for various languages\thanks{This
%     file has version number 0.0a, last revised 2013/04/22.}}
% \author{Bruno Le Floch}
% \date{2013/04/22}
%
% \maketitle
% \tableofcontents
%
% \begin{documentation}
%
% \section{\pkg{runner} documentation}
%
% This package aims to provide interpreters for various languages, with
% code written for all commonly used modern \TeX{} engines (\pdfTeX{},
% \XeTeX{}, and \LuaTeX{}).  Currently, the following languages are
% supported:
% \begin{itemize}
%   \runnerMapPlang{\item \plang{#1},}
% \end{itemize}
% and more will be added as I get time.
%
% \begin{function}{\runner}
%   The main command, \cs{runner}, expects four arguments (or three,
%   since the second is optional):
%   \begin{enumerate}
%   \item The name of a programming language supported by \pkg{runner}
%     (see list above), surrounded by curly braces.
%   \item An optional list of key--value pairs, surrounded by square
%     brackets, which affect how the program is run, where the input is
%     taken from, and where its output goes.
%   \item The program code, given as a verbatim argument (like the
%     argument of \cs{verb}), \ie, it must be surrounded by two
%     identical characters which do not appear in the program.
%   \item The input, also a verbatim argument, delimited by two
%     identical characters (I advise to use the same as those
%     surrounding the program).
%   \end{enumerate}
%   The program code is interpreted in the given language, and is given
%   the last argument as its input.  For instance, since the brainfuck
%   program ``\texttt{,+[-.>,+]}'' outputs its input,
%   \begin{verbatim}
%     \runner{brainfuck}@,+[-.>,+]@@some input@
%   \end{verbatim}
%   will yield ``\texttt{some input}''.  This text will be left to be
%   processed by \TeX{} (as if it were typed directly in the document).
%   To store the result for later reuse, use the \texttt{output} key.
% \end{function}
%
% \begin{function}{output}
%   Using the \texttt{output} key lets us redirect the output of a
%   program to a macro, which can later be used.  Keeping with the same
%   brainfuck program, we can do for instance
%   \begin{verbatim}
%     \runner{brainfuck}[output = \result]@,+[-.>,+]@@some input@
%     \typeout{\result}
%   \end{verbatim}
%   to store ``\texttt{some input}'' in the macro \cs{result}, then
%   print it to the terminal using the \LaTeXe{} command \cs{typeout}.
% \end{function}
%
% ^^A todo: not implemented.
% \begin{function}{input}
%   \textcolor{red}{Not implemented.}
%   A program can take its input from a macro that is already defined.
%   Note that \cs{runner} still takes four arguments, and that the last
%   argument, normally used for the input, must be empty, lest there be
%   an error.
%   \begin{verbatim}
%     \newcommand{\someinput}{some nice text}
%     \runner{brainfuck}[input = \someinput]@,+[-.>,+]@@@
%   \end{verbatim}
%   leaves ``\texttt{some nice text}'' for \TeX{} to process.
% \end{function}
%
% ^^A todo: not implemented.
% \begin{function}{\NewRunner, \RenewRunner, \DeclareRunner}
%   \textcolor{red}{Not implemented.}
%   \begin{verbatim}
%     \NewRunner{\bfcopy}{brainfuck}@,+[-.>,+]@
%     \bfcopy @some input@
%     \bfcopy[output = \result]@other input@
%   \end{verbatim}
%   will leave ``\texttt{some input}'' to be processed by \TeX{}, then
%   store ``\texttt{other input}'' in the macro \cs{result}.
% \end{function}
%
% \runnerMapPlang{\input{runner-#1.dtx}}
%
% \subsection{Useful variables}
%
% \begin{variable}{\g_runner_languages_clist}
%   The list of known languages.
% \end{variable}
%
% \end{documentation}
%
% \appendix
%
% \begin{implementation}
%
% \section{\pkg{runner} implementation}
%
% Some support packages are loaded first, then declare the package's
% name, date, version, and purpose.
%
%<*package>
%    \begin{macrocode}
\RequirePackage{expl3}[2012/12/07]
\RequirePackage{l3str}[2012/12/07]
\RequirePackage{xparse}[2012/12/07]
\ProvidesExplPackage
  {runner} {2013/04/22} {0.0a} {Interpreters for various languages}
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=runner>
%    \end{macrocode}
%
% \subsection{Variables and constants}
%
% \begin{variable}{\g_runner_languages_clist}
%   The list of known languages.
%    \begin{macrocode}
\clist_new:N \g_runner_languages_clist
\clist_gset:Nn \g_runner_languages_clist
  {
    brainfuck,
    forth,
  }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_input_str, \l_@@_output_str, \l_@@_program_str}
%   Input and output common to all the programming languages.  This
%   assumes that there is no need to allow cross-language mixing.
%    \begin{macrocode}
\tl_new:N \l_@@_input_str
\tl_new:N \l_@@_output_str
\tl_new:N \l_@@_program_str
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]
%   {
%     \l_@@_tmpa_tl,
%     \l_@@_tmpb_tl,
%     \l_@@_tmpc_tl,
%     \l_@@_tmpd_tl,
%     \l_@@_tmpa_fp,
%     \l_@@_tmpa_int,
%     \l_@@_tmpb_int,
%     \l_@@_tmpc_int,
%     \l_@@_tmpd_int,
%     \l_@@_tmpa_bool,
%   }
%   Scratch variables used by various languages.
%    \begin{macrocode}
\tl_new:N \l_@@_tmpa_tl
\tl_new:N \l_@@_tmpb_tl
\tl_new:N \l_@@_tmpc_tl
\tl_new:N \l_@@_tmpd_tl
\fp_new:N \l_@@_tmpa_fp
\int_new:N \l_@@_tmpa_int
\int_new:N \l_@@_tmpb_int
\int_new:N \l_@@_tmpc_int
\int_new:N \l_@@_tmpd_int
\bool_new:N \l_@@_tmpa_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\@@_tmp:w}
%   Short-term auxiliary, defined on the fly.
%    \begin{macrocode}
\cs_new_eq:NN \@@_tmp:w ?
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}[int]{\l_@@_output_key_tl}
%   This token list is empty if the output should be left in the input
%   stream, and otherwise contains the macro in which the output should
%   be stored.
%    \begin{macrocode}
\tl_new:N \l_@@_output_key_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\g_@@_array_font_size_int}
%   The size of the last font that was used as an array.
%    \begin{macrocode}
\int_new:N \g_@@_array_font_size_int
%    \end{macrocode}
% \end{variable}
%
% \subsection{Providing arrays for the interpreters}
%
% \begin{macro}[int]{\@@_array_new:Nn}
%   Initialize an array (implemented as a font) |#1| of size |#2|.  If
%   |#2| is negative or zero, complain (we could allow zero if someone
%   asks).  Otherwise, allocate a new font, which is \TeX{}'s \cs{tenrm}
%   at a tiny size which no one would use, and zero out the \(7\) first
%   parameters, to which \TeX{} gives values.  We make sure to change
%   size every time, otherwise we would be back with the same array.
%   Entries go from \(1\) to the array size, which we do not store: the
%   caller is responsible for keeping track of this information, and
%   out-of-bound addressing leads to low-level \TeX{} errors.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_array_new:Nn #1#2
  {
    \cs_new_eq:NN #1 \tex_nullfont:D
    \int_compare:nNnTF {#2} > \c_zero
      {
        \int_gincr:N \g_@@_array_font_size_int
        \tex_global:D \tex_font:D #1 = cmr10~at~
          \g_@@_array_font_size_int sp \scan_stop:
        \int_step_inline:nnnn { 1 } { 1 } { 7 }
          { \tex_fontdimen:D ##1 #1 = \c_zero_dim }
        \tex_fontdimen:D \int_eval:n {#2} #1 = \c_zero_dim
      }
      {
        \msg_error:nnxx { runner } { negative-array-size }
          { \token_to_str:N #1 } { \int_eval:n {#2} }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_array_item:Nn, \@@_array_item:NN}
%   The value stored in a given cell is retrieved by converting the
%   \tn{fontdimen} dimension to a number in \texttt{sp}.  We provide a
%   fast version expecting the item number to be an integer.
%    \begin{macrocode}
\cs_new:Npn \@@_array_item:Nn #1#2
  { \tex_number:D \tex_fontdimen:D \int_eval:n {#2} #1 }
\cs_new:Npn \@@_array_item:NN #1#2
  { \tex_number:D \tex_fontdimen:D #2 #1 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_array_gset:Nnn}
%   Assignments are always global.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_array_gset:Nnn #1#2#3
  {
    \tex_fontdimen:D \int_eval:n {#2} #1
      = \int_eval:n {#3} sp \scan_stop:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Output from programs}
%
% \begin{macro}[int]{\@@_output:n, \@@_output:x}
%   Add a string to the right of the output string.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_output:n #1
  { \str_put_right:Nn \l_@@_output_str {#1} }
\cs_generate_variant:Nn \@@_output:n { x }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_output_char:n}
%   Add a character with arbitrary character code to
%   the right of the output.
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_other:N \^^@
  \cs_new_protected:Npn \@@_output_char:n #1
    {
      \group_begin:
      \char_set_lccode:nn {0} {#1}
      \tl_to_lowercase:n
        { \group_end: \str_put_right:Nn \l_@@_output_str { ^^@ } }
    }
\group_end:
%    \end{macrocode}
% \end{macro}
%
% \subsection{Bit operations}
%
% \begin{variable}{\l_@@_bit_power_int}
%   Holds a power of two during bit operations.
%    \begin{macrocode}
\int_new:N \l_@@_bit_power_int
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]
%   {\@@_bit_and:NNN, \@@_bit_or:NNN, \@@_bit_xor:NNN}
% \begin{macro}[aux]{\@@_bit_aux:nNNN}
%   Compute the logical ``and'', ``or'', or ``xor'' of the last two
%   non-negative integer variables, and store the result in the first.
%   Note that this turns the last two arguments to~\(0\).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_bit_and:NNN #1#2#3
  {
    \@@_bit_aux:nNNN
      {
        \int_if_odd:nT #2
          {
            \int_if_odd:nT #3
              { \int_add:Nn #1 { \l_@@_bit_power_int } }
          }
      }
      #1#2#3
  }
\cs_new_protected:Npn \@@_bit_or:NNN #1#2#3
  {
    \@@_bit_aux:nNNN
      {
        \int_if_odd:nTF #2
          { \int_add:Nn #1 { \l_@@_bit_power_int } }
          {
            \int_if_odd:nT #3
              { \int_add:Nn #1 { \l_@@_bit_power_int } }
          }
      }
      #1#2#3
  }
\cs_new_protected:Npn \@@_bit_xor:NNN #1#2#3
  {
    \@@_bit_aux:nNNN
      {
        \int_if_odd:nTF #2
          { \int_if_odd:nF #3 }
          { \int_if_even:nF #3 }
              { \int_add:Nn #1 { \l_@@_bit_power_int } }
      }
      #1#2#3
  }
\cs_new_protected:Npn \@@_bit_aux:nNNN #1#2#3#4
  {
    \int_zero:N #2
    \int_set_eq:NN \l_@@_bit_power_int \c_one
    \int_do_while:nNnn { #3 + #4 } > \c_zero
      {
        #1
        \tex_divide:D #3 \c_two
        \tex_divide:D #4 \c_two
        \tex_multiply:D \l_@@_bit_power_int \c_two
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_bit_lshift:NN}
%   Shift |#1| by |#2| bits to the left, in place, filling the low-order
%   bits with \(0\).  If |#2| is larger than \(30\), the result is zero.
%   Otherwise, repeatedly multiply by \(2\), dropping the highest bit.
%   Note that \cs{c_max_int} is \(2^{31}-1\): dividing an integer from
%   \([0, 2^{30}-1]\) by this number gives \(0\), and dividing an
%   integer from \(2^{30}\) to the maximum \TeX{} integer gives \(1\).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_bit_lshift:NN #1#2
  {
    \int_compare:nNnTF {#2} > { 30 }
      { \int_zero:N #1 }
      {
        \prg_replicate:nn {#2}
          {
            \int_set:Nn #1
              { \c_two * (#1 - #1 / \c_max_int * ( \c_max_int / 2 ) ) }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: improve behaviour for large |#2|
% \begin{macro}[int]{\@@_bit_rshift:NN}
%   Perform floored division of |#1| by \(2\), |#2| times, to shift that
%   number of bits to the right.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_bit_rshift:NN #1#2
  {
    \prg_replicate:nn {#2}
      {
        \int_if_even:nF {#1} { \int_decr:N #1 }
        \int_set:Nn #1 { #1 / \c_two }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Misc}
%
% \begin{macro}[int, EXP]{\@@_break:n, \@@_break_point:n}
%   A tool to jump to the end of a loop, leaving the appropriate
%   clean-up code (argument of \cs{@@_break_point:n}).
%    \begin{macrocode}
\cs_new:Npn \@@_break:n #1 #2 \@@_break_point:n #3 { #3 #1 }
\cs_new_eq:NN \@@_break_point:n \use:n
%    \end{macrocode}
% \end{macro}
%
% \subsection{Running programs}
%
% \begin{macro}[int]{\@@:nnnn}
%   Four arguments: mandatory programming language name, optional
%   key--values, verbatim program code, verbatim input.  First make sure
%   that the language is loaded.  If this succeeded, then, in a group,
%   set the various keys that affect the run, set the program, input,
%   and output, and call the language-specific runner.  Once this ends,
%   clean up with \cs{@@_finish:w}, which also takes care of sending the
%   output outside the group.
%    \begin{macrocode}
\cs_new_protected:Npn \@@:nnnn #1#2#3#4
  {
    \@@_load_language:nT {#1}
      {
        \group_begin:
          \keys_set:nn { runner } {#2}
          \str_set:Nn \l_@@_program_str {#3}
          \str_set:Nn \l_@@_input_str {#4}
          \tl_clear:N \l_@@_output_str
          \use:c { @@_#1_run: }
          \@@_finish:w
        \group_end:
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, TF]{\@@_load_language:n}
%   If the runner command for the language |#1| is already defined,
%   nothing needs to be done.  Otherwise, load the \texttt{ldf} file if
%   possible.  This file may be defective (if it does not define the
%   runner command), or inexistent, and we raise the appropriate error
%   in those cases.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_load_language:n #1 { T }
  {
    \cs_if_exist:cTF { @@_#1_run: }
      { \prg_return_true: }
      {
        \file_if_exist:nTF { runner - #1 .ldf }
          {
            \group_begin:
              \ExplSyntaxOn
              \file_input:n { runner - #1 .ldf }
            \group_end:
            \cs_if_exist:cTF { @@_#1_run: }
              { \prg_return_true: }
              {
                \msg_error:nnn { runner } { defective-ldf } {#1}
                \prg_return_false:
              }
          }
          {
            \clist_if_in:NnTF \g_runner_languages_clist {#1}
              { \msg_error:nnn { runner } { missing-ldf } {#1} }
              { \msg_error:nnn { runner } { unknown-language } {#1} }
            \prg_return_false:
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_finish:w}
%   The output string \cs{l_@@_output_str} is either left for \TeX{} to
%   digest, or stored in the macro contained in \cs{l_@@_output_key_tl}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_finish:w \group_end:
  {
    \use:x
      {
        \group_end:
        \tl_if_empty:NTF \l_@@_output_key_tl
          { \l_@@_output_str }
          {
            \tl_set:Nn \exp_not:o \l_@@_output_key_tl
              { \l_@@_output_str }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Keys}
%
%    \begin{macrocode}
\keys_define:nn { runner }
  {
    output .tl_set:N = \l_@@_output_key_tl
  }
%    \end{macrocode}
%
% \subsection{User command}
%
% ^^A todo: introduce \str_lowercase:n, use it there.
% \begin{macro}[int]{\@@_process_lang_name:n}
%   Sanitize the language name passed to \cs{runner}, by turning it to a
%   string, removing all spaces, and converting to lowercase.  We use
%   \cs{tl_expandable_lowercase:n} because it is not affected by
%   external settings.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_process_lang_name:n #1
  {
    \str_set:Nn \l_@@_tmpa_tl {#1}
    \tl_remove_all:Nn \l_@@_tmpa_tl { ~ }
    \tl_set:Nx \ProcessedArgument
      { \exp_args:NV \tl_expandable_lowercase:n \l_@@_tmpa_tl }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\runner}
%   Four arguments: mandatory programming language name, optional
%   key--values, verbatim program code, verbatim input.  The programming
%   language name is sanitized using \cs{@@_process_lang_name:n}.  Pass
%   everything to \cs{@@:nnnn}.
%    \begin{macrocode}
\NewDocumentCommand {\runner}
  { > { \@@_process_lang_name:n } m O{} +v +v }
  { \@@:nnnn {#1} {#2} {#3} {#4} }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Messages}
%
%    \begin{macrocode}
\msg_new:nnnn { runner } { unknown-language }
  { The~programming~language~'#1'~is~not~known~to~'runner'. }
  {
    The~code\\\\
    \iow_indent:n {#2}\\\\
    could~not~be~run,~because~there~is~not~support~for~'#1',~yet.
  }
\msg_new:nnnn { runner } { defective-ldf }
  { The~file~'runner-#1.ldf'~does~not~define~a~programming~language. }
  {
    The~language~definition~file~'runner-#1.ldf'~must~define~
    '\iow_char:N \\@@_#1_run:'~to~enable~the~runner~package~
    to~run~programs~written~in~'#1'.
  }
\msg_new:nnnn { runner } { missing-ldf }
  { The~file~'runner-#1.ldf'~cannot~be~found. }
  {
    The~'#1'~programming~language~should~be~supported~by~the~
    'runner'~package,~but~this~requires~the~language~definition~
    file~'runner-#1.ldf',~which~is~nowhere~to~be~found.
  }
\msg_new:nnnn { runner } { negative-array-size }
  { The~array~'#1'~cannot~be~initialized~at~size~'#2'. }
  {
    This~is~probably~an~internal~error~in~the~runner~package.~
    Please~report~it.
  }
%    \end{macrocode}
%
% \runnerDisableDoc
% \runnerMapPlang{\input{runner-#1.dtx}}
%
%</package>
%
% \end{implementation}
%
% \endinput
