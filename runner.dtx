% \iffalse
%% File: runner.dtx Copyright (C) 2013 Bruno Le Floch
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% -----------------------------------------------------------------------
%
%<*driver>
%\fi
%\iffalse
\documentclass[full]{l3doc}
\usepackage{runner}
\usepackage{booktabs}
\ExplSyntaxOn
\DeclareDocumentCommand { \runnerMapPlang } { m }
  { \clist_map_inline:Nn \g_runner_languages_clist {#1} }
\DeclareDocumentCommand { \runnerDisableDoc } { }
  {
    \cs_set:cpn { runner-documentation }
      {
        \tl_map_function:nN { \{ \} } \char_set_catcode_other:N
        \runner_doc_skip:wN
      }
  }
\cs_new:Npn \runner_doc_skip:wN
    #1 runner-documentation #2 { \group_end: }
\ExplSyntaxOff
\newenvironment{runner-documentation}{}{\endinput}
\newenvironment{runner-implementation}{}{}
\newcommand{\varg}[1]{\texttt{\char`\| }\meta{#1}\texttt{\char`\| }}
\newcommand{\plang}[1]{\texttt{#1}}
\begin{document}
  \DocInput{runner.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{runner} package: \\
%   interpreters for various languages\thanks{This
%     file has version number 0.0a, last revised 2013/04/22.}}
% \author{Bruno Le Floch}
% \date{2013/04/22}
%
% \maketitle
% \tableofcontents
%
% \begin{documentation}
%
% \section{\pkg{runner} documentation}
%
% This package aims to provide interpreters for various languages, with
% code written for all commonly used modern \TeX{} engines (\pdfTeX{},
% \XeTeX{}, and \LuaTeX{}).  Currently, the following languages are
% supported:
% \begin{itemize}
%   \runnerMapPlang{\item \plang{#1},}
% \end{itemize}
% and more will be added as I get time.
%
% \begin{function}{\runner}
%   The main command, \cs{runner}, expects four arguments (or three,
%   since the second is optional):
%   \begin{enumerate}
%   \item The name of a programming language supported by \pkg{runner}
%     (see list above), surrounded by curly braces.
%   \item An optional list of key--value pairs, surrounded by square
%     brackets, which affect how the program is run, where the input is
%     taken from, and where its output goes.
%   \item The program code, given as a verbatim argument (like the
%     argument of \cs{verb}), \ie, it must be surrounded by two
%     identical characters which do not appear in the program.
%   \item The input, also a verbatim argument, delimited by two
%     identical characters (I advise to use the same as those
%     surrounding the program).
%   \end{enumerate}
%   The program code is interpreted in the given language, and is given
%   the last argument as its input.  For instance, since the brainfuck
%   program ``\texttt{,+[-.>,+]}'' outputs its input,
%   \begin{verbatim}
%     \runner{brainfuck}@,+[-.>,+]@@some input@
%   \end{verbatim}
%   will yield ``\texttt{some input}''.  This text will be left to be
%   processed by \TeX{} (as if it were typed directly in the document).
%   To store the result for later reuse, use the \texttt{output} key.
% \end{function}
%
% ^^A todo: not implemented.
% \begin{function}{\NewRunner, \RenewRunner, \DeclareRunner}
%   \textcolor{red}{Not implemented.}
%   \begin{verbatim}
%     \NewRunner{\bfcopy}{brainfuck}@,+[-.>,+]@
%     \bfcopy @some input@
%     \bfcopy[output = \result]@other input@
%   \end{verbatim}
%   will leave ``\texttt{some input}'' to be processed by \TeX{}, then
%   store ``\texttt{other input}'' in the macro \cs{result}.
% \end{function}
%
% \begin{function}{\RunnerOptions}
%   Expects a comma-list of key--value pairs.  Sets (locally) the
%   options for all \cs{runner} commands.
% \end{function}
%
% \begin{function}{\runner:nnnn}
%   This is a programming-level version of \cs{runner}, which takes the
%   same arguments.
% \end{function}
%
% \subsection{Program keys}
%
% The program can be obtained from various sources: it can be read from
% a file or a stream, or given directly as \TeX{} code, or as the third
% argument to \cs{runner}.
% \begin{itemize}
% \item First the code given as the \texttt{program} key is run.
% \item Then the code found in each \texttt{program-file} is run.
% \item Then the stream found by reading the \texttt{program-stream} is
%   read for program code.
% \item Finally, the code given directly as an argument to the
%   \cs{runner} command is run.
% \end{itemize}
% The various sources for the code are interpreted as the language would
% treat separate files.
%
% \begin{function}{program}
%   The value of this key is expanded as \TeX{} code, then converted to
%   a string for processing by the language interpreter.
% \end{function}
%
% \begin{function}{program-file}
%   The value of this key is a comma-delimited list of file names.  Each
%   of those files is read in turn and processed by the language
%   interpreter.
% \end{function}
%
% \begin{function}{program-stream}
%   The value of this key must be a stream declared with \cs{ior_new:N},
%   or \LaTeXe{}'s \tn{newread}.  It is read and interpreted line by
%   line using \cs{ior_get_str:NN}.  If the program stops before the
%   stream is exhausted, the stream is still available for further use.
% \end{function}
%
% \subsection{Input keys}
%
% The input can be obtained from various sources: it can be read from a
% file or a stream, or given directly as \TeX{} code, or as the second
% argument to \cs{runner}.
% \begin{itemize}
% \item The \TeX{} code given as the \texttt{input} key is expanded and
%   used as the first part of the input.
% \item Then each of the \texttt{input-file} is used as input.
% \item Then the stream found by reading the \texttt{input-stream} is
%   read for input.
% \item Finally, we use the input given directly as the last argument of
%   \cs{runner}.
% \end{itemize}
% The various sources of input are interpreted as the language would
% treat separate files.
%
% \begin{function}{input}
%   The value of this key is expanded as \TeX{} code, then converted to
%   a string provided as input for the program.
% \end{function}
%
% \begin{function}{input-file}
%   The value of this key is a comma-delimited list of file names.  Each
%   of those files is read in turn and provided as the input of the
%   program.
% \end{function}
%
% \begin{function}{input-stream}
%   The value of this key must be a stream declared with \cs{ior_new:N},
%   or \LaTeXe{}'s \cs{newread}.  It is read line by line using
%   \cs{ior_get_str:NN}, as the program requests input.  If the program
%   stops before the stream is exhausted, the stream is still available
%   for further use.
% \end{function}
%
% \subsection{Output keys}
%
% The output produced when running a program can be stored into various
% places.  By default, the output is inserted by \TeX{} into the
% document (with ``string'' category codes, namely none of the special
% characters is interpreted).  If the \texttt{ouput-rescan} boolean is
% set, the output is treated as if it were typed directly into the
% \TeX{} document, with the current category codes.
%
% When the \texttt{output} key is set (possibly with an empty value),
% the output is not sent to the document.  If several keys among
% \texttt{output}, \texttt{output-file}, and \texttt{output-stream} are
% set, then the output is stored in all of those simultaneously (for
% instance, tis allows logging results for debugging).
%
% \begin{function}{output}
%   The value of this key is empty or a single macro.  The output is
%   stored in the macro after the program stops.  An empty value
%   suppresses the use of the output in the document, without storing
%   the output anywhere (unless one of |output-file| or |output-stream|
%   is set, as those are independent).
% \end{function}
%
% \begin{function}{output-file}
%   The value of this key is a comma-delimited list of file names.  The
%   output is stored in each of the files after the program stops.
% \end{function}
%
% \begin{function}{output-stream}
%   The value of this key must be a stream declared with \cs{iow_new:N}.
%   The program output is written to the output stream line by line, as
%   it is produced.  Once the program ends, the stream is still
%   available for further use.
% \end{function}
%
% \begin{function}{output-rescan}
%   If this boolean is set to \texttt{true}, the output obtained by
%   running the program is read again with the current category codes
%   (see \cs{tl_set_rescan:Nnn}), before being either stored in a macro
%   or used as \TeX{} code.
% \end{function}
%
% \subsection{Useful variables}
%
% \begin{variable}{\g_runner_languages_clist}
%   The list of known languages.
% \end{variable}
%
% \runnerMapPlang{\input{runner-#1.dtx}}
%
% \end{documentation}
%
% \appendix
%
% \begin{implementation}
%
% \section{\pkg{runner} implementation}
%
% Some support packages are loaded first, then declare the package's
% name, date, version, and purpose.
%
%<*package>
%    \begin{macrocode}
\RequirePackage{expl3}[2012/12/07]
\RequirePackage{l3str}[2012/12/07]
\RequirePackage{xparse}[2012/12/07]
\ProvidesExplPackage
  {runner} {2013/04/22} {0.0a} {Interpreters for various languages}
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=runner>
%    \end{macrocode}
%
% \subsection{Variables and helpers}
%
% \subsubsection{Program, input, and output}
%
% \begin{variable}{\g_runner_languages_clist}
%   The list of known languages.
%    \begin{macrocode}
\clist_new:N \g_runner_languages_clist
\clist_gset:Nn \g_runner_languages_clist
  {
    brainfuck,
    forth,
  }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_language_str}
%   The programming language in which the program is written.
%    \begin{macrocode}
\tl_new:N \l_@@_language_str
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]
%   {
%     \l_@@_program_key_seq,
%     \l_@@_program_file_clist,
%     \l_@@_program_stream_tl,
%     \l_@@_program_arg_seq
%   }
%   The (expanded) program code (split into lines), the list of program
%   files, and the program stream (stored as a one-item token list).
%   The \texttt{program_arg} sequence contains the argument given to
%   \cs{runner} or \cs{runner:nnnn}, split into lines.
%    \begin{macrocode}
\seq_new:N \l_@@_program_key_seq
\clist_new:N \l_@@_program_file_clist
\tl_new:N \l_@@_program_stream_tl
\seq_new:N \l_@@_program_arg_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]
%   {
%     \l_@@_input_key_seq,
%     \l_@@_input_file_clist,
%     \l_@@_input_stream_tl,
%     \l_@@_input_arg_seq
%   }
%   The (expanded) \TeX{} code input (split into lines), the list of
%   input files, and the input stream (stored as a one-item token list).
%   The \texttt{input_arg} sequence contains the argument given to
%   \cs{runner} or \cs{runner:nnnn}, split into lines.
%    \begin{macrocode}
\seq_new:N \l_@@_input_key_seq
\clist_new:N \l_@@_input_file_clist
\tl_new:N \l_@@_input_stream_tl
\seq_new:N \l_@@_input_arg_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]
%   {
%     \l_@@_output_use_bool,
%     \l_@@_output_key_tl,
%     \l_@@_output_file_clist,
%     \l_@@_output_stream_tl
%   }
%   A boolean that indicates whether the output should be inserted in
%   the \TeX{} document, the output macro (stored as a one-item token
%   list), the list of output files, and the output stream (stored as a
%   one-item token list).
%    \begin{macrocode}
\bool_new:N \l_@@_output_use_bool
\tl_new:N \l_@@_output_key_tl
\clist_new:N \l_@@_output_file_clist
\tl_new:N \l_@@_output_stream_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_sources_seq, \l_@@_get_line_code_tl}
%   Each item in this sequence is code to setup an input source for the
%   program or for the input.  First comes the program items, then the
%   input items.  The token list temporarily stores the first item of
%   \cs{l_@@_sources_seq} just before redefining \cs{@@_get_line:NTF}.
%    \begin{macrocode}
\seq_new:N \l_@@_sources_seq
\tl_new:N \l_@@_get_line_code_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_ior}
%   Stream used to read program and input files line by line.
%    \begin{macrocode}
\ior_new:N \l_@@_ior
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_iow}
%   Stream used to write the output to a file.
%    \begin{macrocode}
\iow_new:N \l_@@_iow
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_output_line_str, \l_@@_output_str}
%   Output common to all the programming languages.  This assumes that
%   there is no need to allow cross-language mixing.  The
%   \texttt{output_line} contains the current line of the output, and
%   its contents are transferred to the \texttt{output_str} each time an
%   newline character is encountered.
%    \begin{macrocode}
\str_new:N \l_@@_output_line_str
\str_new:N \l_@@_output_str
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\g_@@_output_tl}
%   Holds the code that is performed outside the group to either store
%   the output of the program into a user-defined macro, or rescan the
%   argument, giving it to \TeX{}.
%    \begin{macrocode}
\tl_new:N \g_@@_output_tl
%    \end{macrocode}
% \end{variable}
%
% \subsubsection{Misc}
%
% \begin{variable}[int]
%   {
%     \l_@@_tmpa_tl,
%     \l_@@_tmpb_tl,
%     \l_@@_tmpc_tl,
%     \l_@@_tmpd_tl,
%     \l_@@_tmpa_fp,
%     \l_@@_tmpa_int,
%     \l_@@_tmpb_int,
%     \l_@@_tmpc_int,
%     \l_@@_tmpd_int,
%     \l_@@_tmpa_bool,
%   }
%   Scratch variables used by various languages.
%    \begin{macrocode}
\tl_new:N \l_@@_tmpa_tl
\tl_new:N \l_@@_tmpb_tl
\tl_new:N \l_@@_tmpc_tl
\tl_new:N \l_@@_tmpd_tl
\fp_new:N \l_@@_tmpa_fp
\int_new:N \l_@@_tmpa_int
\int_new:N \l_@@_tmpb_int
\int_new:N \l_@@_tmpc_int
\int_new:N \l_@@_tmpd_int
\bool_new:N \l_@@_tmpa_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\@@_tmp:w}
%   Short-term auxiliary, defined on the fly.
%    \begin{macrocode}
\cs_new_eq:NN \@@_tmp:w ?
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}[int]{\g_@@_array_font_size_int}
%   The size of the last font that was used as an array.
%    \begin{macrocode}
\int_new:N \g_@@_array_font_size_int
%    \end{macrocode}
% \end{variable}
%
%    \begin{macrocode}
\cs_generate_variant:Nn \seq_set_split:Nnn { Nnx , Nxn }
%    \end{macrocode}
%
% \subsection{Keys}
%
% \begin{macro}[int]
%   {
%     runner/program, runner/program-file, runner/program-stream,
%     runner/input  , runner/input-file  , runner/input-stream  ,
%     runner/output , runner/output-file , runner/output-stream ,
%     runner/output-rescan,
%   }
%   Simply store the values provided by the user.  The |program| and
%   |input| keys expand their values before storing.  The |output| key
%   suppresses output to the document by unsetting
%   \cs{l_@@_output_use_bool}.
%    \begin{macrocode}
\keys_define:nn { runner }
  {
    program        .code:n =
      {
        \seq_set_split:Nnx
          \l_@@_program_key_seq { ^^J } {#1}
      } ,
    program-file   .clist_set:N = \l_@@_program_file_clist ,
    program-stream .tl_set:N    = \l_@@_program_stream_tl  ,
    input          .code:n =
      {
        \seq_set_split:Nnx
          \l_@@_input_key_seq { ^^J } {#1}
      } ,
    input-file     .clist_set:N = \l_@@_input_file_clist   ,
    input-stream   .tl_set:N    = \l_@@_input_stream_tl    ,
    output         .code:n =
      {
        \tl_set:Nn \l_@@_output_key_tl {#1}
        \bool_set_false:N \l_@@_output_use_bool
      } ,
    output         .default:n = { } ,
    output-file    .clist_set:N = \l_@@_output_file_clist  ,
    output-stream  .tl_set:N    = \l_@@_output_stream_tl   ,
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Reading program and input}
%
% ^^A todo: actually, the popping an empty sources_seq shouldn't happen.
% \begin{macro}[int]{\@@_get_line:NTF}
% \begin{macro}[int]{\@@_get_line_next_source:NTF}
%   The command \cs{@@_get_line:NTF} finds a new line of program or
%   input, store it in |#1|, and return \texttt{true}.  If nothing is
%   found (end of program or end of input), return \texttt{false}.  The
%   actual code varies as we deplete the various sources.  In fact, the
%   initial definition is a call to \cs{@@_get_line_next_source:NTF},
%   which redefines \cs{@@_get_line:NTF} according to what is found in
%   \cs{l_@@_sources_seq}, then calls the new definition.  The
%   \texttt{next_source} function takes the \texttt{true} branch if it
%   successfully found a line (this may require several redefinitions if
%   some of the input files are empty).  The \texttt{false} branch is
%   taken when all program (or all input) source has ended.  See
%   \cs{@@_get_seq_line:NNTF}, \cs{@@_get_file_line:nNTF} and
%   \cs{@@_get_ior_line:NNTF}, which can all be used (together with an
%   argument) in the definition of \cs{@@_get_line:NTF}.  We do not
%   define \cs{@@_get_line_next_source:NTF} as a \LaTeX3 conditional
%   because the function could not be tail recursive in that case.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_get_line_next_source:NTF #1
  {
    \seq_pop:NNTF \l_@@_sources_seq \l_@@_get_line_code_tl
      {
        \cs_set_protected_nopar:Npx \@@_get_line:NTF
          { \exp_not:V \l_@@_get_line_code_tl }
        \@@_get_line:NTF #1
          { \use_i:nn }
          { \@@_get_line_next_source:NTF #1 }
      }
      { \use_ii:nn }
  }
\cs_new_eq:NN \@@_get_line:NTF \@@_get_line_next_source:NTF
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_get_seq_line:NNTF}
%   Pop the sequence of lines to get a line.  If it is empty, call the
%   \texttt{next_source} function to go to the next source and read from
%   there.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_get_seq_line:NNTF #1#2
  {
    \seq_pop:NNTF #1 #2
      { \use_i:nn }
      { \@@_get_line_next_source:NTF #2 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_split_newline:NnnF}
% \begin{macro}[aux]{\@@_split_newline_aux:w}
%   The newline is found with a delimited function: if there is a
%   newline in |#1|, the first \cs{q_mark} serves as a delimiter, and
%   |#3| and |#4| of the auxiliary are the |#2| and |#3| of the main
%   function.  Otherwise, the second \cs{q_mark} serves as a delimiter,
%   and |#3| and |#4| of the auxiliary take care of performing |#4| and
%   removing spurious tokens.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_split_newline:NnnF #1#2#3#4
  {
    \exp_after:wN \@@_split_newline_aux:w #1
      \q_mark {#2} {#3} ^^J
      \q_mark { #4 \use_none:nn } { }
      \q_stop
  }
\cs_new_protected:Npn \@@_split_newline_aux:w
    #1 ^^J #2 \q_mark #3 #4 #5 \q_stop
  {
    #3 {#1}
    #4 {#2}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_get_file_line:nNTF}
%   Try to open the given file.  If that is possible, then redefine
%   \cs{@@_get_line:NTF} to use \cs{@@_get_ior_line:NNTF} with
%   \cs{l_@@_ior} as its input stream.  Otherwise, complain, and go to
%   the \texttt{next_source}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_get_file_line:nNTF #1#2
  {
    \ior_open:NnTF \l_@@_ior {#1}
      {
        \cs_set_protected_nopar:Npn \@@_get_line:NTF
          { \@@_get_ior_line:NNTF \l_@@_ior }
        \@@_get_line:NTF #2
      }
      {
        \msg_error:nnn { runner } { file-not-found } {#1}
        \@@_get_line_next_source:NTF #2
      }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: do we get an extra blank line at the eof?
% \begin{macro}[int]{\@@_get_ior_line:NNTF}
%   If the stream is exhausted, find the next source.  Otherwise, read
%   one line (as a string), and take the \texttt{true} branch.  Note
%   that we do not close the stream explicitly, as this can be a stream
%   given by the user, and we should not alter, for instance, streams
%   created with \tn{newwrite}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_get_ior_line:NNTF #1#2
  {
    \ior_if_eof:NTF #1
      { \@@_get_line_next_source:NTF #2 }
      {
        \ior_get_str:NN #1#2
        \use_i:nn
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_init_sources:}
% \begin{macro}[aux]{\@@_init_sources_aux:NNNN}
%   The first time \texttt{get_line} is run, it should find the
%   \texttt{next_source}.  We set up the list of sources: first the
%   program sources, namely the |program| key, each |program-file|, the
%   |program-stream| if any, and the argument of \cs{runner}; then a
%   marker \cs{use_iii:nnn} which always takes the \texttt{false}
%   branch, indicating the end of the input; then the input sources,
%   namely the |input| key, each |input_file|, and the |input-stream| if
%   any, followed by the marker \cs{use_iii:nnn}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_init_sources:
  {
    \cs_set_eq:NN \@@_get_line:NTF \@@_get_line_next_source:NTF
    \seq_clear:N \l_@@_sources_seq
    \@@_init_sources_aux:NNNN
      \l_@@_program_key_seq
      \l_@@_program_file_clist
      \l_@@_program_stream_tl
      \l_@@_program_arg_seq
    \seq_put_right:Nn \l_@@_sources_seq { \use_iii:nnn }
    \@@_init_sources_aux:NNNN
      \l_@@_input_key_seq
      \l_@@_input_file_clist
      \l_@@_input_stream_tl
      \l_@@_input_arg_seq
    \seq_put_right:Nn \l_@@_sources_seq { \use_iii:nnn }
  }
\cs_new_protected:Npn \@@_init_sources_aux:NNNN #1#2#3#4
  {
    \seq_put_right:Nn \l_@@_sources_seq
      { \@@_get_seq_line:NNTF #1 }
    \clist_map_inline:Nn #2
      {
        \seq_put_right:Nn \l_@@_sources_seq
          { \@@_get_file_line:nNTF {##1} }
      }
    \int_case:nnn { \tl_count:N #3 }
      {
        { 0 } { }
        { 1 }
          {
            \seq_put_right:Nx \l_@@_sources_seq
              { \@@_get_ior_line:NNTF #3 }
          }
      }
      { \msg_error:nn { runner } { bad-value } }
    \seq_put_right:Nn \l_@@_sources_seq
      { \@@_get_seq_line:NNTF #4 }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Writing to the output}
%
% \begin{macro}[int]{\@@_init_output:}
%   Setting up the ouput.  Most importantly, this is where the
%   \texttt{line_unsafe} function is redefined to also send the line to
%   the stream if any is given.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_init_output:
  {
    \tl_clear:N \l_@@_output_line_str
    \tl_clear:N \l_@@_output_str
    \tl_if_empty:NF \l_@@_output_stream_tl
      {
        \cs_set_protected:Npx \@@_output_line_unsafe:n ##1
          {
            \str_put_right:Nn
              \exp_not:N \l_@@_output_str { ##1 ^^J }
            \iow_now:Nn
              \exp_not:V \l_@@_output_stream_tl {##1}
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_output_line_unsafe:n, \@@_output_line_unsafe:V}
%   This function ignores the current contents of the
%   \cs{l_@@_output_line_str} (but does not affect them).  It sends a
%   line directly to the output, and to the output stream if any.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_output_line_unsafe:n #1
  { \str_put_right:Nn \l_@@_output_str { #1 ^^J } }
\cs_generate_variant:Nn \@@_output_line_unsafe:n { V }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_output_char:n}
%   Add a character with arbitrary character code to the right of the
%   current output line.  If the character code is \(10\) (newline
%   character), the send the output line out instead.
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_other:N \^^@
  \cs_new_protected:Npn \@@_output_char:n #1
    {
      \int_compare:nNnTF {#1} = { `^^J }
        {
          \@@_output_line_unsafe:V \l_@@_output_line_str
          \tl_clear:N \l_@@_output_line_str
        }
        {
          \group_begin:
          \char_set_lccode:nn {0} {#1}
          \tl_to_lowercase:n
            {
              \group_end:
              \str_put_right:Nn \l_@@_output_line_str { ^^@ }
            }
        }
    }
\group_end:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_output:n, \@@_output:x}
%   Add a string to the right of the output string.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_output:n #1
  {
    \str_put_right:Nn \l_@@_output_line_str {#1}
    \@@_split_newline:NnnF \l_@@_output_line_str
      { \@@_output_line_unsafe:n }
      {
        \tl_clear:N \l_@@_output_line_str
        \@@_output:n
      }
      { }
  }
\cs_generate_variant:Nn \@@_output:n { x }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Running programs}
%
% \subsubsection{User commands}
%
% \begin{macro}{\runner}
%   Four arguments: mandatory programming language name, optional
%   key--values, verbatim program code, verbatim input.  Pass everything
%   to \cs{runner:nnnn}.
%    \begin{macrocode}
\NewDocumentCommand { \runner } { m O{} +v +v }
  { \runner:nnnn {#1} {#2} {#3} {#4} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\RunnerOptions}
%   Setting options for use in multiple calls to \cs{runner}.
%    \begin{macrocode}
\NewDocumentCommand { \RunnerOptions } { m }
  { \keys_set:nn { runner } {#1} }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Internal command}
%
% ^^A todo: introduce \str_to_alphanum:n and \str_to_lowercase:n, use them.
% ^^A todo: clarify newline behaviour.
% \begin{macro}{\runner:nnnn}
%   Four arguments: mandatory programming language name, optional
%   key--values, program code, input.  We work in a group to allow
%   languages to safely clobber \TeX{}'s registers.  Clean up the
%   language argument, store it, and try to load the language file.  If
%   that fails, give up (\texttt{load_language} takes care of the error
%   message).  Otherwise, process the keys, and store |#3| and |#4| in
%   the appropriate strings.  We have all the data to initialize the
%   sources for program and input.  Call the language-specific runner.
%   Once this ends, clean up with \cs{@@_finish:}, which also takes care
%   of sending the output outside the group.
%    \begin{macrocode}
\cs_new_protected:Npn \runner:nnnn #1#2#3#4
  {
    \group_begin:
      \str_set:Nn \l_@@_language_str {#1}
      \tl_remove_all:Nn \l_@@_language_str { ~ }
      \str_set:Nx \l_@@_language_str
        { \exp_args:NV \tl_expandable_lowercase:n \l_@@_language_str }
      \exp_args:NV \@@_load_language:nT \l_@@_language_str
        {
          \bool_set_true:N \l_@@_output_use_bool
          \keys_set:nn { runner } {#2}
          \seq_set_split:Nxn \l_@@_program_arg_seq
            { \iow_char:N \^^M } {#3}
          \seq_set_split:Nxn \l_@@_input_arg_seq
            { \iow_char:N \^^M } {#4}
          \@@_init_sources:
          \@@_init_output:
          \use:c { @@_#1_run: }
          \@@_finish:
        }
    \group_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, TF]{\@@_load_language:n}
%   If the runner command for the language |#1| is already defined,
%   nothing needs to be done.  Otherwise, load the \texttt{ldf} file if
%   possible.  This file may be defective (if it does not define the
%   runner command), or inexistent, and we raise the appropriate error
%   in those cases.  The group is strictly speaking not necessary, but
%   it makes sure that no local definitions done within the file leak
%   into the first use of that interpreter.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_load_language:n #1 { T }
  {
    \cs_if_exist:cTF { @@_#1_run: }
      { \prg_return_true: }
      {
        \file_if_exist:nTF { runner - #1 .ldf }
          {
            \group_begin:
              \ExplSyntaxOn
              \file_input:n { runner - #1 .ldf }
            \group_end:
            \cs_if_exist:cTF { @@_#1_run: }
              { \prg_return_true: }
              {
                \msg_error:nnn { runner } { defective-ldf } {#1}
                \prg_return_false:
              }
          }
          {
            \clist_if_in:NnTF \g_runner_languages_clist {#1}
              { \msg_error:nnn { runner } { missing-ldf } {#1} }
              { \msg_error:nnn { runner } { unknown-language } {#1} }
            \prg_return_false:
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: do I get extra lines at the eof?
% ^^A todo: error check the |output| key for length = 1.
% \begin{macro}[int]{\@@_finish:}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_finish:
  {
    \str_put_right:Nx \l_@@_output_str \l_@@_output_line_str
    \clist_map_inline:Nn \l_@@_output_file_clist
      {
        \iow_open:Nn \l_@@_iow {##1}
        \iow_now:Nx \l_@@_iow { \l_@@_output_str }
        \iow_close:N \l_@@_iow
      }
    \tl_gset:Nx \g_@@_output_tl
      {
        \bool_if:NTF \l_@@_output_use_bool
          {
            \bool_if:NTF \l_@@_output_rescan_bool
              { \tl_rescan:nn { } { \l_@@_output_str } }
              { \l_@@_output_str }
          }
          {
            \tl_if_empty:NF \l_@@_output_key_tl
              {
                \bool_if:NTF \l_@@_output_rescan_bool
                  {
                    \tl_set_rescan:Nnn
                      \exp_not:V \l_@@_output_key_tl
                      { } { \l_@@_output_str }
                  }
                  {
                    \tl_set:Nn \exp_not:V \l_@@_output_key_tl
                      { \l_@@_output_str }
                  }
              }
          }
      }
    \group_insert_after:N \g_@@_output_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Programming support}
%
% \subsubsection{Integer array implementation}
%
% \begin{macro}[int]{\@@_array_new:Nn}
%   Initialize an array (implemented as a font) |#1| of size |#2|.  If
%   |#2| is negative or zero, complain (we could allow zero if someone
%   asks).  Otherwise, allocate a new font, which is \TeX{}'s \cs{tenrm}
%   at a tiny size which no one would use, and zero out the \(7\) first
%   parameters, to which \TeX{} gives values.  We make sure to change
%   size every time, otherwise we would be back with the same array.
%   Entries go from \(1\) to the array size, which we do not store: the
%   caller is responsible for keeping track of this information, and
%   out-of-bound addressing leads to low-level \TeX{} errors.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_array_new:Nn #1#2
  {
    \cs_new_eq:NN #1 \tex_nullfont:D
    \int_compare:nNnTF {#2} > \c_zero
      {
        \int_gincr:N \g_@@_array_font_size_int
        \tex_global:D \tex_font:D #1 = cmr10~at~
          \g_@@_array_font_size_int sp \scan_stop:
        \int_step_inline:nnnn { 1 } { 1 } { 7 }
          { \tex_fontdimen:D ##1 #1 = \c_zero_dim }
        \tex_fontdimen:D \int_eval:n {#2} #1 = \c_zero_dim
      }
      {
        \msg_error:nnxx { runner } { negative-array-size }
          { \token_to_str:N #1 } { \int_eval:n {#2} }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_array_item:Nn, \@@_array_item:NN}
%   The value stored in a given cell is retrieved by converting the
%   \tn{fontdimen} dimension to a number in \texttt{sp}.  We provide a
%   fast version expecting the item number to be an integer.
%    \begin{macrocode}
\cs_new:Npn \@@_array_item:Nn #1#2
  { \tex_number:D \tex_fontdimen:D \int_eval:n {#2} #1 }
\cs_new:Npn \@@_array_item:NN #1#2
  { \tex_number:D \tex_fontdimen:D #2 #1 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_array_gset:Nnn}
%   Assignments are always global.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_array_gset:Nnn #1#2#3
  {
    \tex_fontdimen:D \int_eval:n {#2} #1
      = \int_eval:n {#3} sp \scan_stop:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Bit operations}
%
% \begin{variable}{\l_@@_bit_power_int}
%   Holds a power of two during bit operations.
%    \begin{macrocode}
\int_new:N \l_@@_bit_power_int
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]
%   {\@@_bit_and:NNN, \@@_bit_or:NNN, \@@_bit_xor:NNN}
% \begin{macro}[aux]{\@@_bit_aux:nNNN}
%   Compute the logical ``and'', ``or'', or ``xor'' of the last two
%   non-negative integer variables, and store the result in the first.
%   Note that this turns the last two arguments to~\(0\).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_bit_and:NNN #1#2#3
  {
    \@@_bit_aux:nNNN
      {
        \int_if_odd:nT #2
          {
            \int_if_odd:nT #3
              { \int_add:Nn #1 { \l_@@_bit_power_int } }
          }
      }
      #1#2#3
  }
\cs_new_protected:Npn \@@_bit_or:NNN #1#2#3
  {
    \@@_bit_aux:nNNN
      {
        \int_if_odd:nTF #2
          { \int_add:Nn #1 { \l_@@_bit_power_int } }
          {
            \int_if_odd:nT #3
              { \int_add:Nn #1 { \l_@@_bit_power_int } }
          }
      }
      #1#2#3
  }
\cs_new_protected:Npn \@@_bit_xor:NNN #1#2#3
  {
    \@@_bit_aux:nNNN
      {
        \int_if_odd:nTF #2
          { \int_if_odd:nF #3 }
          { \int_if_even:nF #3 }
              { \int_add:Nn #1 { \l_@@_bit_power_int } }
      }
      #1#2#3
  }
\cs_new_protected:Npn \@@_bit_aux:nNNN #1#2#3#4
  {
    \int_zero:N #2
    \int_set_eq:NN \l_@@_bit_power_int \c_one
    \int_do_while:nNnn { #3 + #4 } > \c_zero
      {
        #1
        \tex_divide:D #3 \c_two
        \tex_divide:D #4 \c_two
        \tex_multiply:D \l_@@_bit_power_int \c_two
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_bit_lshift:NN}
%   Shift |#1| by |#2| bits to the left, in place, filling the low-order
%   bits with \(0\).  If |#2| is larger than \(30\), the result is zero.
%   Otherwise, repeatedly multiply by \(2\), dropping the highest bit.
%   Note that \cs{c_max_int} is \(2^{31}-1\): dividing an integer from
%   \([0, 2^{30}-1]\) by this number gives \(0\), and dividing an
%   integer from \(2^{30}\) to the maximum \TeX{} integer gives \(1\).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_bit_lshift:NN #1#2
  {
    \int_compare:nNnTF {#2} > { 30 }
      { \int_zero:N #1 }
      {
        \prg_replicate:nn {#2}
          {
            \int_set:Nn #1
              { \c_two * (#1 - #1 / \c_max_int * ( \c_max_int / 2 ) ) }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: improve behaviour for large |#2|
% \begin{macro}[int]{\@@_bit_rshift:NN}
%   Perform floored division of |#1| by \(2\), |#2| times, to shift that
%   number of bits to the right.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_bit_rshift:NN #1#2
  {
    \prg_replicate:nn {#2}
      {
        \int_if_even:nF {#1} { \int_decr:N #1 }
        \int_set:Nn #1 { #1 / \c_two }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Misc}
%
% \begin{macro}[int, EXP]{\@@_break:n, \@@_break_point:n}
% \begin{macro}[int]{\@@_break_protected:n}
%   A tool to jump to the end of a loop, leaving the appropriate
%   clean-up code (argument of \cs{@@_break_point:n}).
%    \begin{macrocode}
\cs_new:Npn \@@_break:n #1 #2 \@@_break_point:n #3 { #3 #1 }
\cs_new_protected:Npn \@@_break_protected:n
  #1 #2 \@@_break_point:n #3 { #3 #1 }
\cs_new_eq:NN \@@_break_point:n \use:n
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Messages}
%
%    \begin{macrocode}
\msg_new:nnnn { runner } { unknown-language }
  { The~programming~language~'#1'~is~not~known~to~'runner'. }
  {
    The~code\\\\
    \iow_indent:n {#2}\\\\
    could~not~be~run,~because~there~is~not~support~for~'#1',~yet.
  }
\msg_new:nnnn { runner } { defective-ldf }
  { The~file~'runner-#1.ldf'~does~not~define~a~programming~language. }
  {
    The~language~definition~file~'runner-#1.ldf'~must~define~
    '\iow_char:N \\@@_#1_run:'~to~enable~the~runner~package~
    to~run~programs~written~in~'#1'.
  }
\msg_new:nnnn { runner } { missing-ldf }
  { The~file~'runner-#1.ldf'~cannot~be~found. }
  {
    The~'#1'~programming~language~should~be~supported~by~the~
    'runner'~package,~but~this~requires~the~language~definition~
    file~'runner-#1.ldf',~which~is~nowhere~to~be~found.
  }
\msg_new:nnnn { runner } { negative-array-size }
  { The~array~'#1'~cannot~be~initialized~at~size~'#2'. }
  {
    This~is~probably~an~internal~error~in~the~runner~package.~
    Please~report~it.
  }
%    \end{macrocode}
%
% \runnerDisableDoc
% \runnerMapPlang{\input{runner-#1.dtx}}
%
%</package>
%
% \end{implementation}
%
% \endinput
