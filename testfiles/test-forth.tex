\RequirePackage[check-declarations]{expl3}
\RequirePackage{runner}
%%% Tests.
\newcommand{\result}{}
\makeatletter

\runner{forth}[output = \result]|5 6 + 7 8 + * .|||
\typeout{\result}

\runner{forth}[output = \result]|||: hi ." ho"; hi|
\typeout{\result}

\runner{forth}[output = \result]|: HELLO  ( -- )  CR ." Hello, world!" ;||HELLO|
\typeout{\result}

\runner{forth}[output = \result]|: EMIT-Q   81 ( the ASCII value for the character 'Q' ) EMIT ;||EMIT-Q|
\typeout{\result}

\runner{forth}[output = \result]|: BIGGEST OVER OVER < IF SWAP THEN DROP ;|%
|9 5 BIGGEST . 5 9 BIGGEST .|
\typeout{\result}

\runner{forth}[output = \result]|
  : BIGGEST OVER . DUP .
    OVER OVER < IF
      ." a<b " SWAP
    ELSE
      ." a>b "
    THEN
    DROP ;
||9 5 BIGGEST . CR 5 9 BIGGEST .|
\typeout{\result}

\runner{forth}[output = \result]|
  : x 7 2 DO ." *" LOOP ;||x|
\typeout{\result}

\runner{forth}[output = \result]|
  : x 7 2 DO I 64 + EMIT LOOP ;||x|
\typeout{\result}

\runner{forth}[output = \result]|
  : x 10 2 DO I 6 > IF LEAVE THEN I 64 + EMIT LOOP ;||x|
\typeout{\result}

\runner{forth}[output = \result]|
  : x 1500 1 DO I . I +LOOP ;||x|
\typeout{\result}

\runner{forth}[output = \result]|
  : REP-FACTORIAL ( +n1 -- +n2)
  DUP 2 < IF DROP 1 EXIT THEN
  DUP 1- RECURSE *
  ;
  : IT-FACTORIAL ( +n1 -- +n2)
  DUP 2 < IF DROP 1 EXIT THEN
  DUP
  BEGIN DUP 2 > WHILE
  1- SWAP OVER * SWAP
  REPEAT DROP
  ;
||
0 DUP REP-FACTORIAL . IT-FACTORIAL . CR
3 DUP REP-FACTORIAL . IT-FACTORIAL . CR
24 DUP REP-FACTORIAL . IT-FACTORIAL .|
\typeout{\result}

\runner{forth}[output = \result]|
  : FACTORIAL ( +n1 -- +d2)
  DUP 2 < IF DROP 1 0 EXIT THEN
  DUP 1- RECURSE ( n f2 f1)
  ROT SWAP OVER ( f2 n f1 n)
  * ROT ROT ( f1' f2 n)
  UM* ROT +
  ;
||
0 FACTORIAL <# #S #> TYPE CR
8 FACTORIAL <# #S #> TYPE CR
13 FACTORIAL <# #S #> TYPE CR
|
\typeout{\result}

\runner{forth}[output = \result]|
  CHAR foobar EMIT|||
\typeout{\result}

\runner{forth}[output = \result]|
  : x POSTPONE * ; IMMEDIATE :
  four 2 2 x ;
||four . |
\typeout{\result}

\runner{forth}[output = \result]|
  4 CONSTANT four
  5 CONSTANT five
||four five + .|
\typeout{\result}

\runner{forth}[output = \result, program = { 3\space . }]|
  DEPTH DEPTH DEPTH . . .|||
\typeout{\result}

\runner{forth}[output = \result]|
  : show-max-ud HERE 77 , 65 , 88 , 45 , 85 , 68 ,
    6 ENVIRONMENT? IF . . THEN ;||show-max-ud|
\typeout{\result}

\runner{forth}[output = \result]|
  : x 12 ; ' x
  : x 23 ; ' x
  MIN EXECUTE .|||
\typeout{\result}

\runner{forth}[output = \result]|
  3 : x LITERAL ; DEPTH . x .|||
\typeout{\result}

\runner{forth}[output = \result]|
  : show-max-n S" MAX-N" ENVIRONMENT? IF . THEN ;||show-max-n|
\typeout{\result}

\runner{forth}[output = \result]|
  HERE 5 ALLOT
  DUP 2 65 FILL
  DUP 2 + 3 66 FILL
  6 TYPE|||
\typeout{\result}

\runner{forth}[output = \result]|
  65 WORD AAAAbcaA DUP 1+ SWAP @ TYPE
|||
\typeout{\result}

\runner{forth}[output = \result]|
  : x 3 ['] + 2 SWAP EXECUTE ; x . DEPTH .
|||
\typeout{\result}

\runner{forth}[output = \result]|36 . : x|||
\typeout{\result}

\runner{forth}[output = \result]|
  : x HERE 5 ALLOT DUP 3 [CHAR] XYZ FILL 3 TYPE ; x |||
\typeout{\result}

\runner{forth}[output = \result]|
  5 -78 . .
  8 BASE ! 70 DECIMAL .
  16 BASE ! -FF 8 BASE ! .|||
\typeout{\result}

\runner{forth}[output = \result]|
  18 3 OR .
  18 3 AND .
  18 3 XOR .
  18 3 LSHIFT .
  18 3 RSHIFT .
  18 INVERT .|||
\typeout{\result}

\runner{forth}[output = \result]|
  1234567 3456789 M* <# #S #> TYPE|||
\typeout{\result}

\runner{forth}[output = \result]|CHAR \ WORD '\ FIND . DUP EXECUTE ' . .|||
\typeout{\result}

\runner{forth}[output = \result]|
  : Boom -21 ABORT" boom!";
||Boom 3 4 + .|
\typeout{\result}

\runner{forth}[output = \result]|
  CREATE table 0 , 2 , 3 , 5 , 7 , 11 ,
  : th-prime CELLS table + @ ;
||
  1 th-prime .
  2 th-prime .
  2 th-prime th-prime .
|
\typeout{\result}

\runner{forth}[output = \result, program = {123}]|456 . .|||
\typeout{\result}


{
  \ExplSyntaxOn
  \msg_redirect_name:nnn { runner/forth } { unknown-word } { warning }
  \runner{forth}[output, output-stream = \z@]|
    564 . 453 . boom CR boom 897 .
  |||
}

\runner{forth}[output = \result, output-stream = \z@]|
  : const CREATE , DOES> @ ;
||7 const SEVEN SEVEN .|
\typeout{\result}

\runner{forth}[output = \result, output-stream = \z@]|
  : weird CREATE DOES> ." bip" DEPTH . RECURSE ;
||
  weird foobar foobar baz baz bar bar boo
|
\typeout{\result}

\runner{forth}[output = \result]|
  : 2EQ ROT = IF = IF -1 ELSE 0 THEN ELSE 0 THEN ;
||
  1234567 2345678 M*
  0 S>D
  2OVER <# #S #> >NUMBER
  2EQ CHAR Y + EMIT
|
\typeout{\result}
\stop

\runner{forth}[output = \result]|
  0 value ii        0 value jj
  0 value KeyAddr   0 value KeyLen
  create SArray   256 allot   \ state array of 256 bytes
  : KeyArray      KeyLen mod   KeyAddr ;

  : get_byte      + c@ ;
  : set_byte      + c! ;
  : as_byte       255 and ;
  : reset_ij      0 TO ii   0 TO jj ;
  : i_update      1 +   as_byte TO ii ;
  : j_update      ii SArray get_byte +   as_byte TO jj ;
  : swap_s_ij
      jj SArray get_byte
         ii SArray get_byte  jj SArray set_byte
      ii SArray set_byte
  ;

  : rc4_init ( KeyAddr KeyLen -- )
      256 min TO KeyLen   TO KeyAddr
      256 0 DO   i i SArray set_byte   LOOP
      reset_ij
      BEGIN
          ii KeyArray get_byte   jj +  j_update
          swap_s_ij
          ii 255 < WHILE
          ii i_update
      REPEAT
      reset_ij
  ;
  : rc4_byte
      ii i_update   jj j_update
      swap_s_ij
      ii SArray get_byte   jj SArray get_byte +   as_byte SArray get_byte  xor
  ;
|||
\typeout{\result}

\stop